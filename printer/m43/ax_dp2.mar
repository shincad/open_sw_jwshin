	.PROGRAM	apldp2
	.HEADING	"M4324 AX DATA PROCESS PASS 2 MODULE"
	.LIST		NOEXP,NOCOND
;********************************************************
;							*
;	M4324 DATA PROCESS PASS 2 APPLICATION MODULE	*
;							*
;	FILE NAME	AX_DP2.MAR			*
;	CREATED 	04/JUN/1991			*
;							*
;********************************************************
;
	.EXPORT 	DP2TBL
	.EXPORT 	DP2RST,DP2PRT,DP2TPR,D2STX
	.EXPORT 	SETPRR,CLRPRR
;
	.IMPORT 	DP2TCB,DP2STK,GAINI, SWPSTA
	.IMPORT 	PRGID1,PRGID2,PRGID3,SLVVER
	.IMPORT 	GETC,  CHKMD, SETRMG
	.IMPORT 	DP1INI,DP2STA,STENDM,SELKCG
	.IMPORT 	SVDTK, SVDTA, SETPR1,SLKNJ
	.IMPORT 	CNKNJ, CHKKCD,ST10S, UPIG2
	.IMPORT 	SLMOD, STCOL, LFCD1, INBFP
	.IMPORT 	RMVIMG,SETGJD,ROMCG0,ROMCG1
	.IMPORT 	PRINT1,PRINT2,SETUDI,CHKPEO
	.IMPORT 	SETPRN,RSINI, RSHM
;
	.INCLUDE	"COMMON.H"
	.INCLUDE	"SYSLIB.H"
	.INCLUDE	"SYSRAM.H"
	.INCLUDE	"AX_BUF.H"
	.INCLUDE	"M43RTM.H"
	.INCLUDE	"AX_DLD.H"
	.INCLUDE	"AX_DP2.H"
	.INCLUDE	"AX_DP3.H"
	.INCLUDE	"AX_EEP.H"
	.INCLUDE	"AX_IOS.H"
	.INCLUDE	"AX_RAM.H"
	.INCLUDE	"AX_TBF.H"
;
;	<< KEISEN PATTERN CODE CONSTANT >>
;
ZKEISN: .EQU	H'2721                  ; KEISEN CODE FOR H'2C27   920316
ZCLPSA: .EQU	"5"                     ; COLOR POSITION START CODE (A)
ZCLPSB: .EQU	"5"                     ; COLOR POSITION START CODE (B)
ZCLPSC: .EQU	"3"                     ; COLOR POSITION END   CODE (C)
ZCLPSD: .EQU	"3"                     ; COLOR POSITION END   CODE (D)
ZCLPLS: .EQU	55			; SET COLOR POSITION START PULSE
QSPDFX: .EQU	 6			; SPEED FIXED FLAG
	.PAGE
	.SECTION	APL2,CODE,ALIGN=16
;
;	TASK DEFINITION TABLE
;
	.ALIGN		  2
DP2TBL: .DATA.W 	DP2TCB		; TCB
	.DATA.B 	  4		; PRIORITY
	.DATA.B 	ZTIST4		; STATUS
	.DATA.W 	DP2STK		; STACK
	.DATA.W 	DP2INI		; ENTRY
	.DATA.B 	PAGE DP2INI	; CP
	.DATA.B 	  0		; DP
	.DATA.B 	  0		; EP
	.DATA.B 	ZBR		; BR
	.DATA.W 	  0		; NO MAIL BOX
	.DATA.W 	  0		; NO PACKET
;
;
;	INITIALIZE DATA PROCESS PASS 2
;
;	IN	NONE
;
;	OUT	NONE
;
DP2INI: MOV.W	#16*ZK,R5		; SET RAM SIZE
	CALSYS	#INIPBF 		; CHECK AND CLEAR PRINT BUFFER
	MOV.W	#GAINI,R4		;
	CALDPH	#ZPOWN+XWACTF		; INITIALIZE HEAD CONTROL GA
	CLR.W	R4			; SET RAM START ADDRESS
	MOV.W	#32*ZK,R5		; SET RAM SIZE
	CALSYS	#INIRAM 		; CHECK IMAGE BUFFER RAM
	WAIDP3				; WAIT DP3 INITIALIZE END
	JSR	@DP1INI 		; START DATA INPUT
	JSR	@SWPSTA 		; START PANEL SW TASK
	BRA	DP2R_2			;
;
;	RESTART DATA PROCESS PASS 2
;
;	IN	R0 : NEW MODE
;
DP2RST: MOV.W	#DP2STK,SP		; RESET STACK POINTER
	BCLR.B	#QPRTA,@PRMDF:8 	; RESET PRINT JOB ACTIVE
	MOV.B	R0,@DPMDF:8		; SET NEW DATA PROCESS MODE
;-	MOV.B	@UMOD04:8,R0		; 911226+ MESSAGE(MODE)
	CMP.B	#0,R0			; +920427
	BEQ	MD_CHK			; +920427
MD_CK7: MOV.B	R0,@UMOD04:8		; +920427
	CALIOS	#DSPNOR 		; DISPALY NEW MODE
DP2R_2: MOV.B	@DPMDF:8,R0		; GET NEW DATA PROCESS MODE
	MULXU.B #3,R0			;
	JMP	@(DP2R_4:16,R0) 	;
	;
DP2R_4:
	JMP	@DP2STA 		; NORMAL DATA PROCESS MODE
	BRA	SPRA:16 		; SELF PRINT A MODE
	BRA	SPRB:16 		; SELF PRINT B MODE
	BRA	SPRC:16 		; SELF PRINT C MODE
	BRA	HDPW:16 		; HEX DUMP WIDE MODE
	BRA	HDPN:16 		; HEX DUMP NARROW MODE
	.PAGE
;
MD_CHK: 				; +920427
	MOV.B	@EEPBF+E2SIF1,R0	;
	CMP.B	#1,R0
	BEQ	MD_CK1
	CMP.B	#2,R0
	BEQ	MD_CK2
	CMP.B	#3,R0
	BEQ	MD_CK3
	CMP.B	#4,R0
	BEQ	MD_CK4
	CMP.B	#5,R0
	BEQ	MD_CK5
	MOV.B	#0,R0
	BRA	MD_CK7
;
MD_CK1: MOV.B	#6,R0
	BRA	MD_CK7
MD_CK2: MOV.B	#7,R0
	BRA	MD_CK7
MD_CK3: MOV.B	#8,R0
	BRA	MD_CK7
MD_CK4: MOV.B	#9,R0
	BRA	MD_CK7
MD_CK5: MOV.B	#10,R0
	BRA	MD_CK7
	.PAGE
;
;	PRINT DATA PROCESS PASS 2
;
;	IN	R0 : NEW MODE
;
DP2PRT: MOV.B	@DPMDF:8,R0		; GET NEW DATA PROCESS MODE
	MULXU.B #3,R0			;
	JMP	@(DP2P_4:16,R0) 	;
	;
DP2P_4: BRA	PROFF:16		; NORMAL DATA PROCESS MODE
	BRA	SPAPR:16		; SELF PRINT A MODE
	BRA	SPBPR:16		; SELF PRINT B MODE
	BRA	SPCPR:16		; SELF PRINT C MODE
	BRA	HDPWP:16		; HEX DUMP WIDE MODE
	BRA	HDPNP:16		; HEX DUMP NARROW MODE
;
;	<< NORMAL DATA PRECESS MODE -> OFFLINE >>
;
;	OUT	R5 : TEXT BUFFER POINTER
;
PROFF:	BCLR.B	#QPRTON,@APL0F:8	; RESET PRINT ON-LINE FLAG
	BTST.B	#QBSEQR,@APL2F:8	;
	BNE	SPCPR			; BR. IF BAR-CODE SEQUENSE NOT END
	JSR	@SETPRN 		; SET END MARK & PRINT
	BTST.B	#QBCDPR,@PRPTCF:8	;
	BNE	PROF_6			; BR. IF BAR CODE PRESENT (INVALID FULL JUSTIFICATION)
	MOV.W	@TXTBFP:8,R3		; GET TEXT BUFFER POINTER
	CMP.B	#ZIMGFM,@(-ZFMTSZ,R3)	;
	BEQ	PROF_2			; BR. IF IMAGE DATA INTO TEXT BUFFER FLAG
PROF_6: BCLR.B	#QIMGPR,@PRMODF:8	; RESET EXIST IMAGE DATA FLAG
PROF_4: MOV.W	#TXTBF,@TXTBFP:8	; INITIALIZE TEXT BUFFER POINTER
	MOV.W	@CLMCTC:8,R1		; GET CURRENT COLUMN
	MOV.W	R1,@STCLMC:8		; SET START COLUMN
	BCLR.B	#QDELVL,@APL2F:8	; RESET DELETE VALID FLAG
	BCLR.B	#QSPDB,@APL2F:8 	; RESET SPEED B MODE FLAG
	MOV.W	@STCLMC:8,R1		; GET START COUMMN
	MOV.W	R1,@CLMMXS:8		; SAVE COLUMN MAX
	BCLR.B	#QFJSC3,@APL1F:8	; RESET JUSTIFICATION FLAG 3
	BCLR.B	#QPRFST,@PRMDF:8	; RESET PRINT FIRST FLAG
	RTS
	;
PROF_2: MOV.W	@TXTBFP:8,R5		; GET TEXT BUFFER POINTER
	BSR	PROF_4			;
	JMP	@RMVIMG 		; REMOVE IMAGE FORMAT
;
;	<< SELF PRINT A->C MODE & HEX DUMP < WIDE/NARROW > MODE >>
;
HDPWP:
HDPNP:	CLR.B	@DATLNS:8		; RESET DATA COUNTER
SPIDPR: JSR	@SETPR1 		; SET END MARK & PRINT
	BEQ	SPCP_4			; BR. IF NO DATA
SPCP_2:
	CALDP3	#ZPLFCD 		; CALL LINE FEED PACKET TO DP3
SPCP_4: JSR	@INBFP			; SET NEXT LINE START = LEFT MARGIN
	JSR	@CHKPEO 		; CHECK PE OVERRIDE
SPAPR:
SPBPR:
SPCPR:	RTS
	.PAGE
;
;	SELF PRINT A MODE  < KANJI PRINT >
;
SPRA:	BSR	SPRID:16		; PRINT PROGRAM ID
	BSR	SPCP_2			; LINE FEED
	BSR	SPCP_2			; LINE FEED
	CLR.B	@EDWKS1:8		; SET COLOR BIT FOR BLACK
	JSR	@SLKNJ			; SET KANJI MODE
SPRA_2: MOV.W	#H'2121,@KJCDS1:8       ; SET START KANJI CODE
SPRA_4: MOV.B	@EDWKS1:8,R0		; GET COLOR BIT
	JSR	@STCOL			; SET COLOR BIT
	MOV.B	#H'21,@KJCDS2:8         ; SET KANJI 2ND CODE
SPRA_6: MOV.W	@KJCDS1:8,R1		; GET KANJI CODE
	MOV.W	R1,@-SP 		;+ SAVE KANJI CODE
	JSR	@CHKKCD 		; CHECK KANJI CODE
	BNE	SPRA_8			; BR. IF INVALID CODE
	JSR	@SVDTK			; SAVE KANJI CODE TO TEXT BUFFER
SPRA_8: MOV.W	@SP+,R1 		;+ UNSAVE KANJI CODE
	MOV.W	R1,@KJCDS1:8		; SAVE KANJI CODE
	CLR.W	R0			;
	CMP.B	#ZSP,@KJCDS2:8		;
	BEQ	SPRA_A			; BR. IF H'xx20
	CMP.B	#ZDEL,@KJCDS2:8 	;
	BNE	SPRA_C			; BR. IF NOT xx7F
SPRA_A: MOV.W	#27*ZCL180,R0		; GET FULL SPACE COLUMN < 27 x 1/180" >
SPRA_C: ADD.W	#27*2*ZCL180,R0 	; GET SKIP COLUMN < 27 x 2 x 1/180" >
	ADD.W	@CLMCTC:8,R0		;
	MOV.W	R0,@CLMCTC:8		; UPDATE COLUMN COUNTER
	ADD.B	#1,@KJCDS2:8		; UPDATE KANJI 2ND CODE
	ADD.B	#1,@DATLNS:8		; UPDATE DATA COUNTER
	CMP.B	#16,@DATLNS:8		;
	BCS	SPRA_6			; BR. IF NO LINE END
	BSR	SPROUT:16		; PRINT & LF
	CLR.B	@DATLNS:8		; RESET DATA COUNTER
	CMP.B	#H'80,@KJCDS2:8         ;
	BCS	SPRA_6			; BR. IF NOT 2ND CODE END
	ADD.B	#1,@EDWKS1:8		; UPDATE COLOR BIT
	CMP.B	#7,@EDWKS1:8		;
	BCS	SPRA_B			; BR. IF NOT OVERFLOW (0->6)
	CLR.B	@EDWKS1:8		; CLEAR COLOR BIT
SPRA_B:
;318	CMP.B	#H'28,@KJCDS1:8         ;
;318	BEQ	SPRA_D			; BR. IF H'28xx
	CMP.B	#H'2D,@KJCDS1:8         ;
	BEQ	SPRA_E			; BR. IF H'2Dxx
	CMP.B	#H'7E,@KJCDS1:8         ;
	BEQ	SPRA_2			; BR. IF H'7Dxx
	ADD.B	#1,@KJCDS1:8		; UPDATE KANJI 1ST CODE
	BRA	SPRA_4
	;
SPRA_D: MOV.B	#H'2D,@KJCDS1:8         ; SET KANJI 1ST = H'2Dxx
	BRA	SPRA_4
	;
SPRA_E: MOV.B	#H'30,@KJCDS1:8         ; SET KANJI 1ST = H'30xx
	BRA	SPRA_4
	.PAGE
;
;	PRINT PROGRAM ID
;
SPRID:	MOV.B	#1,R0			; SET LQ FLAG
	JSR	@SLMOD			; SELECT LQ MODE
	JSR	@CNKNJ			; RESET KANJI MODE
	BSR	SPRCHK			; CHECK PRINT ENABLE
	CLR.B	@DATLNS:8		; RESET CHARCTER COUNTER
	MOV.W	#PRGID1,R4		; GET PROGRAM ID (MAIN)
	BSR	SPRI_6			;
	MOV.W	#PRGID2,R4		; GET PROGRAM ID (SLAVE)
	BSR	SPRI_6			; 911109
;?316	BSR	SPRI_9			;
; "     MOV.W   #SLVVER,R4              ; GET SLAVE VERSION
; "     BSR     SPRI_6                  ;
	MOV.W	#PRGID3,R4		; GET PROGRAM ID (ROM CG)
SPRI_6: BSR	SPRI_9			;
	BRA	SPROUT			; PRINT & LF
	;
SPRI_8: MOV.W	R4,@-SP 		;
	JSR	@SVDTA			; LOAD PROGRAM ID
	MOV.W	@SP+,R4 		;
SPRI_9: LDC.B	#PAGE PRGID1,EP 	;
	MOV.B	@R4+,R0 		;
	BNE	SPRI_8			; BR. IF NOT STRING END
	RTS
;
;	CHECK PRINT ENABLE
;
SPROT2: MOV.B	@EDWKS3:8,R3		; GET RIBBON SHIFT PULSE COUNTER
	JSR	@STENDM 		; SET END MARK TO TEXT BUFFER
	JSR	@PRINT2 		; PRINT
	BRA	SPRO_4
	;
SPROT3: JSR	@STENDM 		; SET END MARK TO TEXT BUFFER
	JSR	@PRINT1 		; PRINT
SPRO_4: BSR	SPCP_2			; LINE FEED
	TST.B	@DPMDF:8		;
	BEQ	SPRO_6			; BR. IF NOT SELF PRINT MODE (SKIP CHECK PRINT ENABLE)
	BRA	SPRCHK
	;
SPROUT: BSR	SPIDPR			; PRINT & LF
SPRCHK: JSR	@CHKMD			; CHECK ANY REQUEST
	BTST.B	#QPREM,@MODEF:8 	;
	BEQ	SPRCHK			; BR. IF NOT PRINT ENABLE
	BTST.B	#QDIPR,@PSWDF:8 	;
	BNE	SPRCHK			; BR IF NOT INTERRUPT ACTION
SPRO_6: RTS
	.PAGE
;
;	SELF PRINT MODE B  < ANK PRINT >
;
SPRB:	BSR	SPRID			; PRINT PROGRAM ID
	BSR	SPCP_2			; LINE FEED
	BSR	SPCP_2			; LINE FEED
	CLR.B	@EDWKS1:8		; SET COLOR BIT FOR BLACK
	CLR.B	@EDWKS2:8		; SET COLOR CHANGE COUNTER
SPRB_C: MOV.B	#ZSP,R0 		; SET ANK START CODE
SPRB_2: MOV.B	R0,@KJCDS2:8		; SAVE ANK CODE (1)
	MOV.W	R0,@-SP 		;+ SAVE ANK CODE
	MOV.B	@EDWKS1:8,R0		; GET COLOR BIT
	JSR	@STCOL			; SET COLOR BIT
	MOV.W	@SP+,R0 		;+ UNSAVE ANK CODE
SPRB_4: MOV.W	R0,@-SP 		;+ SAVE ANK CODE (2)
	JSR	@SVDTA			; SAVE ANK CODE TO TEXT BUFFER
	MOV.W	@SP+,R0 		;+ UNSAVE ANK CODE
	CMP.B	#ZDEL,R0		;
	BCS	SPRB_6			; BR. IF NOT END
	MOV.B	#ZSP,R0 		; SET ANK CODE (2)
SPRB_6: ADD.B	#1,@DATLNS:8		; UPDATE DATA COUNTER
	ADD.W	#1,R0			; UPDATE ANK CODE (2)
	MOV.B	#136,R5 		; SET FORMS LINE COUNTER
	CMP.B	#ZSHT,@PAMDF:8		;
	BCS	SPRB_7			; BR. IF NOT SHEET/ACSF
	MOV.B	#69,R5			; SET SHEET LINE COUNTER
SPRB_7: CMP.B	@DATLNS:8,R5		;
	BHI	SPRB_4			; BR. IF NOT LINE END
SPRB_8: BSR	SPROUT			; PRINT & LF
	CLR.B	@DATLNS:8		; RESET DATA COUNTER
	ADD.B	#1,@EDWKS2:8		; UPDATE COLOR COUNTER
	CMP.B	#16,@EDWKS2:8		;
	BCS	SPRB_A			; BR. IF NOT COLOR CHANGE
	CLR.B	@EDWKS2:8		; RESET COLOR CHANGE COUNTER
	ADD.B	#1,@EDWKS1:8		; UPDATE COLOR BIT
	CMP.B	#7,@EDWKS1:8		;
	BCS	SPRB_A			; BR. IF NOT OVERFLOW (0->6)
	CLR.B	@EDWKS1:8		; CLEAR COLOR BIT
SPRB_A: MOV.B	@KJCDS2:8,R0		; GET ANK CODE (1)
	ADD.W	#1,R0			; UPDATE ANK CODE (2)
	CMP.B	#ZDEL,R0		;
	BNE	SPRB_2			; BR. IF NOT ANK CODE END (2)
	MOV.B	#ZSP,R0 		; SET ANK START CODE (1)
	BRA	SPRB_2
	.PAGE
;
;	SELF PRINT MODE C
;
;	1. EEPROM DATA DUMP
;	2.  50% EVEN PRINT (1 LINE)
;	3.  50%  ODD PRINT (1 LINE)
;	4. EACH PIN 24 PATTERN PRINT (2 LINE)
;	5. COLOR CHANGE PRINT (8 COLOR -> 8 LINE)
;	6. SPACE SKIP (GAIJI PATTERN 24 x 24 100% -> 20 LINE)
;	7. KEISEN PRINT (BI-DIRECTION) ALL SPEED (5 LINE)
;
SPRC:	BSR	SPRCHK			; CHECK PRINT ENABLE
	BSR	EEDMP			; EEPROM DUMP
	BSR	SPCP_2			; LINE FEED
	BSR	PR50E:16		; PRINT 50% EVEN
	BSR	SPCP_2			; LINE FEED
	BSR	PR50O:16		; PRINT 50% ODD
	BSR	SPCP_2			; LINE FEED
	BSR	PRPIN:16		; PRINT EACH ALL PIN
	BSR	SPCP_2			; LINE FEED
	BSR	PRCOL:16		; PRINT COLOR CHANGE
	BSR	SPCP_2			; LINE FEED
	BSR	PRSKS:16		; PRINT SKIP SPACE
	BSR	SPCP_2			; LINE FEED
SPRC_4: BSR	PRKEI:16		; ADJUST KEISEN PRINT
	BSR	SPCP_2			; LINE FEED
	BRA	SPRC
	.PAGE
;
;	<< EEPROM DUMP >>
;
EEDMP:	JSR	@INBFP			; SET NEXT LINE START = LEFT MARGIN
	CLR.B	@KJCDS1:8		; RESET DATA COUNTER
	MOV.W	#EEPBF,R3		; SET EEPROM BUFFER POINTER
	MOV.B	#128/16,@KJCDS2:8	; SET PRINT LINE COUNTER
EEDM_2: MOV.W	@R3+,R0 		; GET EEPROM DATA
	MOV.W	R3,@-SP 		;+ SAVE BUFFER POINTER
	MOV.W	R0,@-SP 		;+ SAVE EEPROM DATA
	SWAP	R0			;
	BSR	HDPW_6:16		; LOAD HEX CODE
	MOV.W	@SP+,R0 		;+ UNSAVE EEPROM DATA
	BSR	HDPW_6:16		; LOAD HEX CODE
	MOV.W	@SP+,R3 		;+ UNSAVE BUFFER POINTER
	MOV.W	#36*2*ZCL360,R1 	; SET 2 SPACE COLUMN
	ADD.W	@CLMCTC:8,R1		; UPDATE COLUMN COUNTER
	MOV.W	R1,@CLMCTC:8		; SAVE IT
	ADD.B	#1,@KJCDS1:8		; UPDATE DATA COUNTER
	CMP.B	#16,@KJCDS1:8		;
	BCS	EEDM_2			; BR. IF NOT LINE END
	MOV.W	R3,@-SP 		;+ SAVE BUFFER POINTER
	BSR	SPROUT			; PRINT & LF
	MOV.W	@SP+,R3 		;+ UNSAVE BUFFER POINTER
	CLR.B	@KJCDS1:8		; RESET DATA COUNTER
	ADD.B	#-1,@KJCDS2:8		; UPDATE LINE COUNTER
	BNE	EEDM_2			; BR. IF NOT END
	RTS
	.PAGE
;
;	<< PRINT 100% (1 LINE) >>
;
PR100:	JSR	@INBFP			; SET NEXT LINE START = LEFT MARGIN
	MOV.B	#H'FF,R0                ; SET 1->8 PIN DATA
	MOV.B	R0,R1			; SET 9->16 PIN DATA
	MOV.B	R1,R2			; SET 17->24 PIN DATA
	MOV.W	#4896,R3		; SET LINE MAX
	MOV.W	R3,@-SP 		;+ SAVE LINE MAX
	ADD.W	#-1,R3			;
	BSR	STIMGB:16		; SET IMAGE BUFFER POINTER (= EP R4)
PR10_2: BSR	SETDT1:16		; SET DATA TO IMAGE BUFFER
	SCB/F	R3,PR10_2		; BR. IF NOT END
	MOV.W	@SP+,R3 		;+ UNSAVE LINE MAX
	MOV.W	R3,@DATLNS:8		; SAVE LENGTH
	MOV.W	#ZPTC36,R2		; SET 1/360-INCH FLAG
	MOV.W	#03,R1			; SET 1 COLUMN LENGTH
PR10_4: JSR	@ST10S			; SET SPEED (FIXED -> LOW SPEED)
	CLR.W	R3			; CLEAR IGNORE LENGTH
	JSR	@UPIG2			; UPDATE IMAGE BUFFER POINTER
	BRA	SPROUT			; PRINT & LF
;
;	<< PRINT 50% EVEN (1 LINE) >>
;
PR50E:	MOV.B	#H'AA,R0                ; SET 1->8 PIN DATA
	BRA	PR50_2
;
;	<< PRINT 50% ODD (1 LINE) >>
;
PR50O:	MOV.B	#H'55,R0                ; SET 1->8 PIN DATA
PR50_2: JSR	@INBFP			; SET NEXT LINE START = LEFT MARGIN
	MOV.B	R0,R1			; SET 9->16 PIN DATA
	MOV.B	R1,R2			; SET 17->24 PIN DATA
	MOV.W	#4896/2,R3		; SET LINE MAX
	MOV.W	R3,@-SP 		;+ SAVE LINE MAX
	ADD.W	#-1,R3			;
	BSR	STIMGB:16		; SET IMAGE BUFFER POINTER
PR50_4: BSR	SETDT:16		; SET DATA TO IMAGE BUFFER
	SCB/F	R3,PR50_4		; BR. IF NOT END
	MOV.W	@SP+,R3 		;+ UNSAVE LINE MAX
	MOV.W	R3,@DATLNS:8		; SAVE LENGTH
	MOV.W	#ZPTC36,R2		; SET 1/360-INCH FLAG
	MOV.W	#03*2,R1		; SET 1 COLUMN LENGTH
	BRA	PR10_4
	.PAGE
;
;	<< PRINT EACH ALL PIN No. (2 LINE) >>
;
PRPIN:	JSR	@INBFP			; SET NEXT LINE START = LEFT MARGIN
	BSR	PRPN_4			; SET DATA TO IMAGE BUFFER
	JSR	@INBFP			; SET NEXT LINE START = LEFT MARGIN
PRPN_4: MOV.B	#24-1,@DATLNS:8 	; SET LOOP COUNTER (1)
	MOV.B	#H'FF,R5                ; SET ALL PIN ON DATA
	MOV.B	#01,R0			; SET 1 PIN ON DATA
	CLR.B	R1			; CLEAR 9->16 PIN ON DATA
	CLR.B	R2			; CLEAR 17->24 PIN ON DATA
	BSR	STIMGB:16		; SET IMAGE BUFFER POINTER
PRPN_6: MOV.B	R5,@R4+ 		; SET 1->8 PIN ON DATA
	MOV.B	R5,@R4+ 		; SET 9->16 PIN ON DATA
	MOV.B	R5,@R4+ 		; SET 17->24 PIN ON DATA
	MOV.B	R5,@R4+ 		; <----- 2 COLUMN COPY ----->
	MOV.B	R5,@R4+ 		;
	MOV.B	R5,@R4+ 		;
	MOV.W	#98-1,R3		; SET LOOP COUNTER (2)
PRPN_8: BSR	SETDT:16		; SET DATA TO IMAGE BUFFER
	SCB/F	R3,PRPN_8		; BR. IF NOT END
	MOV.B	R5,@R4+ 		; SET 1->8 PIN ON DATA
	MOV.B	R5,@R4+ 		; SET 9->16 PIN ON DATA
	MOV.B	R5,@R4+ 		; SET 17->24 PIN ON DATA
	MOV.B	R5,@R4+ 		; <----- 2 COLUMN COPY ----->
	MOV.B	R5,@R4+ 		;
	MOV.B	R5,@R4+ 		;
	ADDS.B	#3+3+3+3,R4		; UPDATE IMAGE BUFFER POINTER
	SHLL.B	R0			; SHIFT FOR NEXT PIN ON
	ROTXL.B R1			;
	ROTXL.B R2			;
	ADD.B	#-1,@DATLNS:8		; UPDATE LOOP COUNTER (1)
	BPL	PRPN_6			; BR. IF NOT LINE END
	MOV.W	#24*102,@DATLNS:8	; SAVE LENGTH
	MOV.W	#ZPTC36,R2		; SET 1/360-INCH FLAG
	MOV.W	#03*2,R1		; SET 1 COLUMN LENGTH
	BRA	PR10_4
	.PAGE
;
;	<< PRINT COLOR CHANGE (8 COLOR x 8 LINE) >>
;
PRCOL:	JSR	@INBFP			; SET NEXT LINE START = LEFT MARGIN
	JSR	@SLKNJ			; SELECT KANJI MODE
	BTST.B	#QBRBN,@OPTF:8		;
	BEQ	PRCL_G			; BR. IF NOT COLOR RIBBON
PRCL_2: CLR.B	@KFSPLS:8		; SET KANJI LEFT SPACE
	CLR.B	@KFSPRS:8		; SET KANJI RIGHT SPACE
	BSR	SETDT2:16		; SET DATA TO RECEIVE BUFFER
	MOV.W	#H'7E21,R2              ; SET GAIJI CODE
	MOV.W	R2,@-SP 		;+ SAVE GAIJI CODE
	JSR	@SETGJD 		; SET GAIJI DATA TO GAIJI BUFFER
	MOV.W	@SP+,R0 		;+ UNSAVE GAIJI CODE
	MOV.W	R0,@KJCDS1:8		; SAVE GAIJI CODE
	MOV.B	#7,R0			; SET COLOR CODE (1)
	MOV.B	R0,@DATLNS+1:8		; SAVE LINE COUNTER
	MOV.B	#7,@EDWKS1:8		; SAVE DATA COUNTER
	BRA	PRCL_4
	;
PRCL_3: MOV.B	#6,@EDWKS1:8		; SAVE DATA COUNTER
PRCL_4: MOV.B	R0,@DATLNS:8		; SAVE START COLOR FLAG
PRCL_6: CMP.B	#7,R0			;
	BEQ	PRCL_A			; BR. IF WHITE COLOR (SKIP DATA)
PRCL_8: MOV.W	R0,@-SP 		;+ SAVE COLOR FLAG
	JSR	@STCOL			; SET COLOR FLAG
	MOV.W	#12-1,R3		; SET LOOP COUNTER
	BSR	PRSK_B			; SET PATTERN
	MOV.W	@SP+,R0 		;+ UNSAVE COLOR FLAG
	ADD.B	#1,R0			; UPDATE COLOR FLAG
	CMP.B	#7,R0			;
	BNE	PRCL_C			; BR. IF WHITE COLOR
PRCL_A: MOV.W	#24*12*ZCL180,R3	; SET SKIP COLUMN
	BSR	PRSK_D			; UPDATE COLUMN
	CLR.B	R0			; SET BLACK
PRCL_C: ADD.B	#-1,@EDWKS1:8		; UPDATE DATA COUNTER
	BPL	PRCL_8			; BR. IF NOT DATA END
	BSR	SPROUT			; PRINT & LF
	MOV.B	@DATLNS:8,R0		; GET COLOR FLAG
	ADD.B	#1,R0			; UPDATE COLOR FLAG
	CMP.B	#7,R0			;
	BCS	PRCL_D			; BR. IF WHITE COLOR
	CLR.B	R0			; SET BLACK
PRCL_D: ADD.B	#-1,@DATLNS+1:8 	; UPDATE LINE COUNTER
	BPL	PRCL_3			; BR. IF NOT LINE END
PRCL_G: JSR	@CNKNJ			; RESET KANJI MODE
	RTS
	.PAGE
;
;	<< PRINT SKIP SPACE (20 LINE) >>
;
PRSKS:	JSR	@INBFP			; SET NEXT LINE START = LEFT MARGIN
	CLR.B	@KFSPLS:8		; SET KANJI LEFT SPACE
	CLR.B	@KFSPRS:8		; SET KANJI RIGHT SPACE
	CLR.B	R0			;
	JSR	@STCOL			; SET COLOR FOR BLACK
	JSR	@SLKNJ			; SELECT KANJI MODE
	BSR	SETDT3			; SET DATA TO RECEIVE BUFFER
	MOV.W	#H'7F21,R2              ; SET GAIJI CODE
	MOV.W	R2,@-SP 		;+ SAVE GAIJI CODE
	JSR	@SETGJD 		; SET GAIJI DATA TO GAIJI BUFFER
	MOV.W	@SP+,R0 		;+ UNSAVE GAIJI CODE
	MOV.W	R0,@KJCDS1:8		; SAVE GAIJI CODE
;921205 MOV.W	#24,R3			; SET 1/180 INCH FEED VALUE
	MOV.W	#16,R3		;921205 ; SET 1/180 INCH FEED VALUE
	CALDP3	#ZP3LP			; CALL 1/180 INCH LINE FEED PACKET TO DP3
	MOV.B	#10-1,@EDWKS1:8 	; SET LINE COUNTER
PRSK_2: BSR	PRSK_A			; SET PRINT 10 CHARACTER
	BSR	PRSK_C			; SET SKIP SPACE
	BSR	PRSK_A			; SET PRINT 10 CHARACTER
	BSR	PRSK_C			; SET SKIP SPACE
	BSR	PRSK_A			; SET PRINT 10 CHARACTER
	BSR	SPROUT			; PRINT & LF
	ADD.B	#-1,@EDWKS1:8		; UPDATE LINE COUNTER
	BPL	PRSK_2			; BR. IF NOT LINE END
	CALDP3	#ZP6LP			; CALL 1/6 INCH LINE FEED PACKET TO DP3
	JSR	@CNKNJ			; RESET KANJI MODE
	RTS
;
;	<< SET GAIJI CODE x 10 >>
;
PRSK_A: MOV.W	#10-1,R3		; SET LOOP COUNTER
PRSK_B: MOV.W	R3,@-SP 		;+ SAVE COUNTER
	JSR	@SVDTK			; SET GAIJI CODE TO TEXT BUFFER
	MOV.W	@SP+,R3 		;+ UNSAVE COUNTER
	SCB/F	R3,PRSK_B		; BR. IF NOT LOOP END
	RTS
;
;	<< UPDATE COLUMN COUNTER SPACE x 36 >>
;
PRSK_C: MOV.W	#24*36*ZCL180,R3	; SET SPACE x 36 COLUMN
PRSK_D: ADD.W	@CLMCTC:8,R3		; UPDATE COLUMN COUNTER
	MOV.W	R3,@CLMCTC:8		; SAVE IT
	RTS
	.PAGE
;
;	<< VERTICAL LINE (KEISEN) ALL SPEED ADJUST POSITION TEST PRINT >>
;
PRKEI:	MOV.B	#1,R0			; SET START SPEED MODE No.
PRKE_4: MOV.W	R0,@-SP 		;+ SAVE SPEED MODE No.
	BSR	DP2T_4:16		; PRINT ADJUST KEISEN POSITION
	MOV.W	@SP+,R0 		;+ UNSAVE SPEED MODE No.
	ADD.B	#1,R0			; UPDATE SPEED MODE No.
	CMP.B	#8,R0			;
	BCS	PRKE_4			; BR. IF NOT SPEED MODE END
	CALDP3	#ZP6LP			; CALL 1/6 INCH LINE FEED PACKET TO DP3
	RTS
;
;	<< SET IMAGE BUFFER POINTER >>
;
;	OUT	EP R4 : IMAGE BUFFER POINTER
;
STIMGA: MOV.W	#61*36*3,R4		; SET SKIP COLUMN
	ADD.W	#IMGBF,R4		; SET IMAGE BUFFER BASE POINTER
	BRA	STIM_4
	;
STIMGB: MOV.W	#IMGBF,R4		; SET IMAGE BUFFER POINTER
STIM_4: LDC.B	#PAGE IMGBF,EP		; SET IMAGE BUFFER PAGE
	RTS
;
;	<< SET DATA TO IMAGE BUFFER >>
;
;	IN	R0->R2 : IMAGE DATA
;		 EP R4 : IMAGE BUFFER POINTER
;
;	OUT	 EP R4 : NEXT IMAGE BUFFER POINTER
;
SETDT:	MOV.B	R0,@R4+ 		; SET 1->8 PIN DATA
	MOV.B	R1,@R4+ 		; SET 9->16 PIN DATA
	MOV.B	R2,@R4+ 		; SET 17->24 PIN DATA
SETDT1: MOV.B	R0,@R4+ 		; <-----> 2 COLUMN <----->
	MOV.B	R1,@R4+ 		;
	MOV.B	R2,@R4+ 		;
	RTS
;
;	<< SET DATA TO RECEIVE BUFFER >>
;
SETDT3: MOV.W	#ROMCG1,R3		; SET ROM CG POINTER
	BRA	SETD_2
	;
SETDT2: MOV.W	#ROMCG0,R3		; SET ROM CG POINTER
SETD_2: LDC.B	#PAGE ROMCG0,DP 	; SET ROM CG PAGE
	LDC.B	#PAGE DLRBF,EP		; SET RECEIVE BUFFER PAGE
	MOV.W	#DLRBF,R4		; SET RECEIVE BUFFER POINTER
	MOV.W	#ZKCGCL/2-1,R5		;
SETD_4: MOV.W	@R3+,R2 		; GET 1->8 PIN DATA
	MOV.W	R2,@R4+ 		; SAVE IT
	MOV.W	@R3+,R2 		; GET 9->16 PIN DATA
	MOV.W	R2,@R4+ 		; SAVE IT
	MOV.W	@R3+,R2 		; GET 17->24 PIN DATA
	MOV.W	R2,@R4+ 		; SAVE IT
	SCB/F	R5,SETD_4		; BR. IF NOT END
	LDC.B	#0,DP			; RESET < DP >
SETD_6: RTS
;
;	SET/RESET PRINT REVERSE FOR FIXED FLAG
;
SETPRR: BSET.B	#QPRRVS,@PRPTCF:8	; SET PRINT REVERSE FLAG (FIXED)
	RTS

CLRPRR: BCLR.B	#QPRRVS,@PRPTCF:8	; RESET PRINT REVERSE FLAG (FIXED)
	RTS
	.PAGE
;
;	<< TEST PRINT >>
;
;	1. VERTICAL LINE (KEISEN) ADJUST POSITION TEST PRINT
;	2. ADJUST COLOR POSITION TEST PRINT
;	3. HEAD GAP TEST ACTION (NO PRINT)
;
;	IN	R0 : TEST PRINT MODE
;			< 1->7 ..... ADJUST KEISEN POSITION PRINT >
;			<   8  ..... ADJUST COLOR POSITION PRINT >
;
DP2TPR: CMP.B	#8,R0			;
	BHI	SETD_6			; BR. IF ENTRY MODE ERROR
	BEQ	ADCOL:16		; BR. IF COLOR ADJUST POSITION PRINT
DP2T_4: BSR	ADVLN			; BR. IF KEISEN ADJUST POSITION PRINT
	BSR	SPCP_2			; LINE FEED
	RTS
;
;	<< VERTICAL LINE (KEISEN) ADJUST POSITION TEST PRINT >>
;
ADVLN:	MOV.W	R0,@-SP 		;+ SAVE SPEED No. (0->6)
;921205 MOV.W	#24,R3			; SET 1/180 INCH FEED VALUE
	MOV.W	#16,R3		;921205 ; SET 1/180 INCH FEED VALUE
	CALDP3	#ZP3LP			; CALL 1/180 INCH LINE FEED PACKET TO DP3
	MOV.B	#1,R0			;
	JSR	@SETUDI 		; SET UNI-DIRECTION MODE
	MOV.B	#3,R5			; SET LOW SPEED & C MODE (FIXED) (C->FORARD)
	BSR	CLRPRR			; RESET REVERSE PRINT FLAG
ADVL_8: BSR	ADVL_2			; SET DATA TO IMAGE BUFFER
	MOV.W	@SP,R5			; GET SPEED No. (0->6)
	BSR	CLRPRR			; RESET REVERSE PRINT FLAG
	BSR	ADVL_2			; SET DATA TO IMAGE BUFFER (1->FORWARD)
	CLR.B	R0			;
	JSR	@SETUDI 		; RESET UNI-DIRECTION MODE
	BSR	SETPRR			; SET REVERSE PRINT FLAG
	MOV.W	@SP,R5			; GET SPEED No. (0->6)
	BSR	ADVL_2			; SET DATA TO IMAGE BUFFER (2->REVERSE)
	MOV.W	@SP,R5			; GET SPEED No. (0->6)
	BSR	CLRPRR			; RESET REVERSE PRINT FLAG
	BSR	ADVL_2			; SET DATA TO IMAGE BUFFER (3->FORWARD)
	MOV.W	@SP,R5			; GET SPEED No. (0->6)
	BSR	SETPRR			; SET REVERSE PRINT FLAG
	BSR	ADVL_2			; SET DATA TO IMAGE BUFFER (4->REVERSE)
	MOV.W	@SP+,R5 		;+ UNSAVE SPEED No. (0->6)
	MOV.B	#3,R5			; SET LOW SPEED & C MODE (FIXED) (C->FORWARD)
	BSR	CLRPRR			; RESET REVERSE PRINT FLAG
ADVL_2: MOV.W	#ZKEISN,R1		; SET KEISEN PATTERN CODE (H'2C27)
	JSR	@SELKCG 		; SELECT KANJI CG (= EP R4)
	LDC.B	#PAGE IMGBF,DP		; SET IMAGE BUFFER PAGE
	MOV.W	#IMGBF,R0		; SET IMAGE BUFFER START POINTER
	MOV.W	#20-1,FP		; SET LINE COUNTER
ADVL_4: MOV.W	#ZKCGCL-1,R3		;
	MOV.W	R4,@-SP 		;+ SAVE KANJI CG POINTER
ADVL_6: MOV.B	@R4,R2			; GET PATTERN
	MOV.B	R2,@R0+ 		; SAVE 1->8 PIN DATA
	MOV.B	@(1,R4),R2		; GET PATTERN
	MOV.B	R2,@R0+ 		; SAVE 9->16 PIN DATA
	MOV.B	@(2,R4),R2		; GET PATTERN
	MOV.B	R2,@R0+ 		; SAVE 17->24 PIN DATA
	MOV.B	@R4+,R2 		; GET PATTERN
	MOV.B	R2,@R0+ 		; SAVE 1->8 PIN DATA
	MOV.B	@R4+,R2 		; GET PATTERN
	MOV.B	R2,@R0+ 		; SAVE 9->16 PIN DATA
	MOV.B	@R4+,R2 		; GET PATTERN
	MOV.B	R2,@R0+ 		; SAVE 17->24 PIN DATA
	SCB/F	R3,ADVL_6		; BR. IF PATTERN END
	MOV.W	@SP+,R4 		;+ UNSAVE KANJI CG POINTER
	ADD.W	#24*2*3*4,R0		; UPDATE IMAGE BUFFER POINTER
	SCB/F	FP,ADVL_4		; BR. IF NOT LINE END
	LDC.B	#0,DP			; RESET < DP >
	MOV.W	#20*24*5,@DATLNS:8	; SAVE COLUMN LENGTH
	MOV.W	#03*2,R1		; SET 1 COLUMN LENGTH
	EXTU	R5			;
	SHLL.W	R5			; OFFSET x 2
	JSR	@(STSPDP:16,R5) 	;
	JSR	@UPIG2			; UPDATE IMAGE BUFFER POINTER
	BSR	SPROT3			; PRINT & LF
SETS05: RTS
;
;	<< SET SPEED & 1/360 INCH PITCH TABLE >>
;
STSPDP: BRA	SETS05			; (00) SET 0.5 SPEED MODE (NO USE)
	BRA	ST10AS			; (01) SET 1.0 SPEED + A MODE
	BRA	ST10BS			; (02) SET 1.0 SPEED + B MODE
	BRA	ST10CS			; (03) SET 1.0 SPEED + C MODE
	BRA	ST10DS			; (04) SET 1.0 SPEED + D MODE
	BRA	SETS15			; (05) SET 1.5 SPEED MODE
	BRA	SETS20			; (06) SET 2.0 SPEED MODE
	BRA	SETS30			; (07) SET 3.0 SPEED MODE
	;
ST10AS: MOV.B	#Z10ASP,FP		; SET 1.0-A MODE FLAG
	BRA	SETS_4
	;
ST10BS: MOV.B	#Z10BSP,FP		; SET 1.0-B MODE FLAG
	BRA	SETS_4
	;
ST10CS: MOV.B	#Z10CSP,FP		; SET 1.0-C MODE FLAG
	BRA	SETS_4
	;
ST10DS: MOV.B	#Z10DSP,FP		; SET 1.0-D MODE FLAG
	BRA	SETS_4
	;
SETS15: MOV.B	#Z15SPD,FP		; SET 1.5 MODE FLAG
	BRA	SETS_4
	;
SETS20: MOV.B	#Z20SPD,FP		; SET 2.0 MODE FLAG
	BRA	SETS_4
	;
SETS30: MOV.B	#Z30SPD,FP		; SET 3.0 MODE FLAG
SETS_4: OR.B	#ZPTC36,FP		; SET 1/360 INCH PITCH FLAG
	BSET.B	#QSPDFX,FP		; SET SPEED FIXED BIT
	RTS
	.PAGE
;
;	<< ADJUST COLOR POSITION TEST PRINT >>
;
ADCOL:	MOV.W	#RSINI,R4		; SET RIBBON INITIALIZE COMMAND
	CALDPH	#ZPOWN			; CALL RIBBON INITIALIZE PACKET TO DPH
	CALDP3	#ZP6LP			; CALL 1/6 INCH LINE FEED PACKET TO DP3
	MOV.B	#ZCLPSA,@EDWKS1:8	; SET START CODE FOR 1ST
	MOV.B	#ZCLPSB,@EDWKS2:8	; SET START CODE FOR 2ND
	MOV.B	#ZCLPLS,@EDWKS3:8	; SET START PULSE COUNTER
ADCO_2: JSR	@INBFP			; SET NEXT LINE START = LEFT MARGIN
	MOV.W	#54*36*ZCL360,R3	; SET SKIP COLUMN < PICA 55 CHARACTER >
	BSR	PRSK_D			; UPDATE COLUMN COUNTER
	MOV.B	@EDWKS1:8,R0		; GET 1ST CODE
	BSR	HDPW_B:16		; SAVE CODE TO TEXT BUFFER
	MOV.B	@EDWKS2:8,R0		; GET 2ND CODE
	BSR	HDPW_B:16		; SAVE CODE TO TEXT BUFFER
	MOV.W	#4*36*ZCL360,R3 	; SET SKIP COLUMN < PICA 5 CHARACTER >
	BSR	PRSK_D			; UPDATE COLUMN COUNTER
	BSR	STIMGA			; SET IMAGE BUFFER POINTER
	MOV.W	#100,@DATLNS:8		; SAVE LENGTH
	MOV.W	#ZPTC36,R2		; SET 1/360-INCH FLAG
	MOV.W	#03,R1			; SET 1 COLUMN LENGTH
	JSR	@ST10S			; SET SPEED (FIXED -> LOW SPEED)
	CLR.W	R3			; CLEAR IGNORE LENGTH
	JSR	@UPIG2			; UPDATE IMAGE BUFFER POINTER
	CLR.B	R0			; SET 1->8 PIN OFF DATA
	MOV.B	#H'18,R1                ; SET 12->13 PIN ON DATA
	CLR.B	R2			; SET 17->24 PIN OFF DATA
	MOV.W	@DATLNS:8,R3		;
ADCO_4: BSR	SETDT1			; SET DATA FOR IMAGE BUFFER
	SCB/F	R3,ADCO_4		; BR. IF NOT DATA END
	MOV.W	#100*ZCL360,R3		;
	BSR	PRSK_D			; UPDATE COLUMN COUNTER
	BSR	SPROT2			; PRINT & LF
	ADD.B	#-2,@EDWKS2:8		; UPDATE 2ND CODE
	ADD.B	#-2,@EDWKS3:8		; UPDATE PULSE COUNTER
	CMP.B	#"1",@EDWKS2:8          ;
	BCC	ADCO_6			; BR. IF NOT 2ND CODE END
	MOV.B	#"9",@EDWKS2:8          ; SET 2ND CODE
	ADD.B	#-1,@EDWKS1:8		; UPDATE 1ST CODE
ADCO_6: CMP.B	#ZCLPSC,@EDWKS1:8	;
	BNE	ADCO_2			; BR. IF NOT 1ST CODE END
	CMP.B	#ZCLPSD,@EDWKS2:8	;
	BNE	ADCO_2			; BR. IF NOT 2ND CODE END
	BSR	ADCO_8			; LINE FEED
	BSR	ADCO_8			; LINE FEED
	BSR	ADCO_8			; LINE FEED
	BSR	ADCO_8			; LINE FEED
	BSR	ADCO_8			; LINE FEED
ADCO_8: BSR	SPCP_2			; LINE FEED
	MOV.W	#RSHM,R4		; SET RIBBON HOME COMMAND
	CALDP3	#ZPOWN			; CALL RIBBON HOME PACKET TO DPH
	CALDP3	#ZP6LP			; CALL 1/6 INCH LINE FEED PACKET TO DP3
	RTS
	.PAGE
;
;	HEX DUMP WIDE MODE
;
HDPW:
;430	CLR.B	R0			; SET DRAFT FLAG
	MOV.B	#1,R0			; SET LQ FLAG 920430
	JSR	@SLMOD			; SELECT DRAFT MODE
	CLR.B	@DATLNS:8		; CLEAR COUNTER
HDPW_2: JSR	@GETC			; GET CHARACTER
	BSR	HDPW_6			; LOAD HEX CODE
	BSR	HDPN_7:16		; ADJUST 1 SPACE
	ADD.B	#1,@DATLNS:8		; UPDATE CHARCTER COUNT
	CMP.B	#45,@DATLNS:8		;
	BCC	HDPW_4			; BR. IF LINE END
	CMP.B	#ZSHT,@PAMDF:8		;
	BCS	HDPW_2			; BR. IF NOT SHEET
	CMP.B	#23,@DATLNS:8		;
	BCS	HDPW_2			; BR. IF NOT LINE END
HDPW_4: BSR	HDPWP			; SET END MARK TO TEXT BUFFER
	CLR.B	@DATLNS:8		; RESET DATA COUNTER
	BRA	HDPW_2
	;
HDPW_6: MOV.W	R0,@-SP 		;+ SAVE CODE
	SHLR.B	R0			; SHIFT 4 TIMES (GET HIGH NIBBLE)
	SHLR.B	R0			;
	SHLR.B	R0			;
	SHLR.B	R0			;
	BSR	HDPW_8			; LOAD LQ CG
	MOV.W	@SP+,R0 		;+ UNSAVE CODE
HDPW_8: AND.B	#H'0F,R0                ; GET LOW NIBBLE
	CMP.B	#10,R0			;
	BCS	HDPW_A			; BR. IF NUMERIC CODE (BR. IF 0->9)
	ADD.B	#7,R0			; ADJUST CODE (10->15 = 17->22)
HDPW_A: ADD.B	#"0",R0                 ; CONVERTE ASCII CODE
HDPW_B: JMP	@SVDTA			; SAVE CODE TO TEXT BUFFER
;
;	HEX DUMP NARROW MODE
;
HDPN:
;430	CLR.B	R0			; SET DRAFT FLAG
	MOV.B	#1,R0			; SET LQ FLAG 920430
	JSR	@SLMOD			; SELECT DRAFT MODE
	CLR.B	@DATLNS:8		; CLEAR DATA COUNTER
HDPN_2: JSR	@GETC			; GET CHARACTER
	MOV.W	R0,@-SP 		;+ SAVE HEX CODE
	BSR	HDPW_6			; SET HEX CODE
	MOV.W	@SP+,R0 		;+ UNSAVE HEX CODE
	BSR	HDPN_4			; SET ASCII PART POSITION
	BSR	HDPN_6			; ADJUST INTERVAL SPACE
	ADD.B	#1,@DATLNS:8		; UPDATE DATA COUNTER
	CMP.B	#16,@DATLNS:8		;
	BCS	HDPN_2			; BR. IF NOT LINE END
	BSR	HDPNP			; SET END MARK TO TEXT BUFFER
	CLR.B	@DATLNS:8		; RESET DATA COUNTER
	BRA	HDPN_2
	;
HDPN_4: MOV.W	@CLMCTC:8,R1		; GET CURRENT COLUMN
	ADD.W	#12*12,R1		; ADJUST 1 SPACE COLUMN
	MOV.W	R1,@-SP 		;+ SAVE COLUMN
	MOV.B	@DATLNS:8,R2		; UPDATE DATA COUNTER
	EXTU	R2			;
	MULXU.B #12*12,R2		; CALCULATE ASCII COLUMN POSITION
	ADD.W	#12*12*59,R2		; GET ASCII COLUMN POSITION BASE
	MOV.W	R2,@CLMCTC:8		; UPDATE COLUMN COUNTER
	BSR	HDPN_9			; ADJUST INTERVAL SPACE
	CMP.B	#ZSP,R0 		;
	BCC	HDPN_5			; BR. IF NOT FUNCTION CODE
	MOV.B	#".",R0                 ; SET DUMMY CODE
HDPN_5: BSR	HDPW_B			; SAVE ASCII CODE TO TEXT BUFFER
	MOV.W	@SP+,R1 		;+ UNSAVE COLUMN COUNTER
	MOV.W	R1,@CLMCTC:8		; SAVE IT
	RTS
	;
HDPN_9: CMP.B	#8,@DATLNS:8		;
	BCS	HDPN_8			; BR. IF 9TH->16TH DATA
	BRA	HDPN_7
	;
HDPN_6: CMP.B	#7,@DATLNS:8		;
	BNE	HDPN_8			; BR. IF 9TH->16TH DATA
HDPN_7: MOV.W	@CLMCTC:8,R1		; GET COLUMN COUNTER
	ADD.W	#12*12,R1		; ADJUST 1 SPACE
	MOV.W	R1,@CLMCTC:8		; UPDATE COLUMN COUNTER
HDPN_8: RTS
	.PAGE
;
;	STX COMMAND PROCESS
;
;	IN	NONE
;
;	OUT	NONE
;
D2STX:	BTST.B	#QFACTM,@MODEF:8	;
	BEQ	D2ST_2			; BR. IF NOT FACTORY MODE
	JSR	@GETC			; GET NEXT CHARCTER OF STX
	CMP.B	#"A",R0                 ;
	BEQ	D2ST_8			; BR. IF STX + A
	CMP.B	#"C",R0                 ;
	BEQ	D2ST_4			; BR. IF STX + C
	CMP.B	#"R",R0                 ;
	BEQ	D2ST_6			; BR. IF STX + R
	CMP.B	#"W",R0                 ;
	BNE	D2ST_2			; BR. IF NOT STX + W
	CALDP3	#ZPEEW			; CALL WRITE EEPROM PACKET TO DP3
D2ST_2: RTS
	;
D2ST_4: MOV.B	#8,R0			; SET COLOR TEST PRINT MODE
	BRA	D2ST_7
	;
D2ST_6: JSR	@GETC			; GET SPEED No.
	TST.B	R0			;
	BEQ	D2ST_2			; BR. IF ERROR DATA
	CMP.B	#7,R0			;
	BHI	D2ST_2			; BR. IF ERROR DATA
D2ST_7: BRA	DP2TPR
	;
D2ST_8: CLR.W	R4			;
	JSR	@GETC			; GET EEPROM BYTE ADDRESS
	MOV.B	R0,R4			;
	JSR	@GETC			; GET EEPROM BYTE DATA
	MOV.B	R0,R3			;
	CALDP3	#ZPEES			; CALL SET EEPROM PACKET TO DP3
	RTS
	.END
