	.PROGRAM	apldp1
	.HEADING	"M4324 DATA PROCESS PASS 1 MODULE"
	.LIST		NOCOND,NOEXP
;********************************************************
;							*
;	M4324 DATA PROCESS PASS 1 APPLICATION MODULE	*
;							*
;	FILE NAME	AX_DP1.MAR			*
;	CREATED 	04/JUN/1991			*
;							*
;********************************************************
;
	.EXPORT 	INTP0, INTP1, INTDA1,INTDA2,DP1ALM
	.EXPORT 	DP1ON, DP1OFF,DP1OFP,DP1PER,DP1PES
	.EXPORT 	DP1INI,DP1INT,DP1POL,DP1IMG
	.EXPORT 	GETC,  GETI8, GETI24
	.EXPORT 	RSMSC, STMS0, STMS1
	.EXPORT 	CHGPF, CHGMD, REQTP, CHKMD
	.EXPORT 	MDFIX, MDFIX1, MDFIX2		; 911224

	.IMPORT 	DATBF, DATBE, BSRTB
	.IMPORT 	RETIH3,SWPRST,CHKDP3,CLIMB, INSP1
	.IMPORT 	DP2RST,DP2IPR,DP2MDC,DP2PFC,DP2PRT,DP2TPR
	.INCLUDE	"COMMON.H"
	.INCLUDE	"GAINT.H"
	.INCLUDE	"GAIFP.H"
	.INCLUDE	"CPUIO.H"
	.INCLUDE	"SYSRAM.H"
	.INCLUDE	"AX_DP3.H"
	.INCLUDE	"AX_RAM.H"
;
;	DELAY 5uS MACRO
;
	.MACRO	DELAY5
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	NOP
	.ENDM
	.PAGE
;	.SECTION	APLRAM,DUMMY,LOCATE=H'FE00
;
;	DATA INPUT BUFFER THRESHOLD
;
ZDATH1: .EQU	  256			; 0.4mS INTERVAL
ZDATH2: .EQU	 8*ZK			; 0.7mS INTERVAL
ZDATH3: .EQU	12*ZK			; 1.0mS INTERVAL
ZDATH4: .EQU	16*ZK-256		; BUFFER BUSY RESET
ZDATH5: .EQU	16*ZK			; BUFFER BUSY SET
;
;	DATA INPUT INTERVAL
;
ZTDIN1: .EQU	 4000/32-1		; 0.4ms INTERVAL
ZTDIN2: .EQU	 7000/32-1		; 0.7mS INTERVAL
ZTDIN3: .EQU	10000/32-1		; 1.0mS INTERVAL

;
;	DP1 WORK AREA
;
	.ORG	H'FE30
DABIP:	.RES.W	  1			; DATA BUFFER IN POINTER
DABOP:	.RES.W	  1			; DATA BUFFER OUT POINTER
MSB0F:	.RES.B	  1			; INPUT DATA MSB OFF MASK
MSB1F:	.RES.B	  1			; INPUT DATA MSB ON  MASK
ZMSBNC: .EQU	H'FF00                  ;    MSB NOT CHNAGE
ZMSBOF: .EQU	H'7F00                  ;    MSB OFF
ZMSBON: .EQU	H'FF80                  ;    MSB ON

DP1F:	.RES.B	  1			; DATA PROCESS PASS 1 FLAG
QDP1B:	.EQU	  0			;   1:INPUT DATA BUFFER BUSY
QDP1E:	.EQU	  1			;   1:DATA INPUT ENABLE
QPRTRQ: .EQU	  2			;   1:DATA PRINT OUT REQUEST
QPFCRQ: .EQU	  3			;   1:PF CHANGE REQUEST
QIPRRQ: .EQU	  4			;   1:INPUT PRIME REQUEST
QMDCRQ: .EQU	  5			;   1:MODE CHANGE REQUEST
QSELRQ: .EQU	  6			;   1:SELECT MODE REQUEST
QTPRRQ: .EQU	  7			;   1:TEST PRINT REQUEST
XPRTRQ: .EQU	H'04                    ;
XPFCRQ: .EQU	H'08                    ;
XIPRRQ: .EQU	H'10                    ;
XMDCRQ: .EQU	H'20                    ;
XTPRRQ: .EQU	H'80                    ;

DP1MS:	.RES.B	  1			; DATA PROCESS MODE SAVE
;ZNDAP: .EQU	  0			;     NORMAL DATA PROCESS MODE
;ZSPRA: .EQU	  1			;     SELF PRINT A MODE
;ZSPRB: .EQU	  2			;     SELF PRINT B MODE
;ZSPRC: .EQU	  3			;     SELF PRINT C MODE
;ZHDPW: .EQU	  4			;     HEX DUMP WIDE MODE
;ZHDPN: .EQU	  5			;     HEX DUMP NARROW MODE

DP1TS:	.RES.B	  1			; TEST PRINT TYPE SAVE
;	.EQU	  0			;     NO REQUEST
;	.EQU	  0+1			;     PRINT POSITION ADJUST 1
;	.EQU	  1+1			;     PRINT POSITION ADJUST 1
;	.EQU	  2+1			;     PRINT POSITION ADJUST 1
;	.EQU	  3+1			;     PRINT POSITION ADJUST 1
;	.EQU	  4+1			;     PRINT POSITION ADJUST 1
;	.EQU	  5+1			;     PRINT POSITION ADJUST 1
;	.EQU	  6+1			;     PRINT POSITION ADJUST 1
;	.EQU	  7+1			;     RIBBON SHIFT ADJUST

	.RES.B	  7			; RESERVED AREA
;
	.INCLUDE	"AX_TMP.H"      ; 911226
;
	.PAGE
	.SECTION	APL1,CODE,ALIGN=16
;
;	INPUT PRIME INTERRUPT HANDLER
;
INTP1:	BCLR.B	#QBUSY,@IFPOTA		; SET BUSY HIGH
	MOV.B	@IPRB,R0		;
	AND.B	#H'0F,R0                ; DISABLE DATA INPUT INTERRUPT
	MOV.B	R0,@IPRB		;
	BSET.B	#QDIPR,@PSWDF:8 	; SET PANEL SW DISABLE BY INPUT PRIME
	MOV.B	#XMDCRQ+XIPRRQ,@DP1F:8	; SET INPUT PRIME INITIALIZE REQUEST
INTP0:	MOV.W	@SP+,R0 		;
	POPDP				;
	RTE				;

;
;	DATA INPUT INTERRUPT HANDLER	(1 CHARACTER BUSY)
;
INTDA2: 				; TIMER INTERRUPT
	PUSHDP				;
	LDC.B	#0,DP			;
	BCLR.B	#QOCFA,@TCSR1		; RESET TIMER INTERRUPT REQUEST
	BTST.B	#QICF,@TCSR1		;
	BNE	INTDA			; BR IF DATA INPUT
	BRA	INTD_5			; SET DATA INTERRUPT MODE

INTDA1: 				; DATA INTERRUPT
	PUSHDP				;
	LDC.B	#0,DP			;
INTDA:	MOV.W	R1,@-SP 		;
	MOV.W	R0,@-SP 		;
INTD_1: BCLR.B	#QBUSY,@IFPOTA		; SET BUSY HIGH
	MOV.B	@IFREAD,R0		; READ INPUT DATA
	NOT.B	R0			; INVERT BIT ON/OFF
	MOV.B	R0,@DATCLR		; RESET 1 CHARACTER BUSY
	BCLR.B	#QICF,@TCSR1		; RESET DATA INTERRUPT REQUEST
;	CMP.W	#ZDATH5-1,@DABDC:8	;
;	BCC	INTD_3			; BR IF INPUT DATA BUFFER FULL
	LDC.W	#XI2+XI1+XI0,SR 	; DISABLE INTERRUPT
	BTST.B	#QDP1E,@DP1F:8		;
	BEQ	INTD_2			; BR IF DATA INPUT DISABLE
	BSET.B	#QACK,@IFPOTA		; SET ACK LOW
	DELAY5				; DELAY 5uS
	BSET.B	#QBUSY,@IFPOTA		; SET BUSY LOW
	DELAY5				; DELAY 5uS
	BCLR.B	#QACK,@IFPOTA		; SET ACK HIGH
INTD_2: LDC.W	#XI1+XI0,SR		; ENABLE INTERRUPT
INTD_3: MOV.W	@DABIP:8,R1		; GET DATA BUFFER IN POINTER
	MOV.B	R0,@R1+ 		; SAVE INPUT DATA
	CMP.W	#DATBE,R1		;
	BCC	INTD_6			; BR IF INPUT DATA BUFFER END
INTD_4: MOV.W	R1,@DABIP:8		; UPDATE INPUT DATA BUFFER IN POINTER
	ADD:Q.W #1,@DABDC:8		; UPDATE INPUT DATA COUNTER
	MOV.W	@DABDC:8,R1		; GET INPUT DATA COUNT
	CMP.W	#ZDATH1,R1		;
	BCC	INTD_7			; BR IF DATA >= THRESHOLD 1
	BTST.B	#QICF,@TCSR1		;
	BNE	INTD_1			; BR IF DATA INPUT
	MOV.W	@SP+,R0 		;
	MOV.W	@SP+,R1 		;
INTD_5: MOV.B	#XICIE+XCKS1,@TCR1	; SET DATA INTERRUPT MODE
	JMP	@RETIH3 		;
					;
INTD_6: MOV.W	#DATBF,R1		; GET DATA BUFFER START
	BRA	INTD_4			;
					;
INTD_7: MOV.W	#ZTDIN1,R0		; SET DATA INPUT INTERVAL 1
	CMP.W	#ZDATH2,R1		;
	BCS	INTD_8			; BR IF DATA < THRESHOLD 2
	MOV.W	#ZTDIN2,R0		; SET DATA INPUT INTERVAL 2
	CMP.W	#ZDATH3,R1		;
	BCS	INTD_8			; BR IF DATA < THRESHOLD 3
	CMP.W	#ZDATH5,R1		;
	BCC	INTD_9			; BR IF INPUT BUFFER FULL
	MOV.W	#ZTDIN3,R0		; SET DATA INTERVAL 3
INTD_8: MOV.W	R0,@OCRA1		; SET DATA INPUT INTERVAL
	CLR.W	@FRC1			;
	BCLR.B	#QOCFA,@TCSR1		; RESET TIMER INTERRUPT REQUEST
	MOV.B	#XOCIEA+XCKS1,@TCR1	; SET TIMER INTERRUPT MODE
	MOV.W	@SP+,R0 		;
	MOV.W	@SP+,R1 		;
	JMP	@RETIH3 		;
					;
INTD_9: MOV.B	#XCKS1,@TCR1		; DISABLE DATA INPUT INTERRUPT
	BSET.B	#QDP1B,@DP1F:8		; SET INPUT DATA BUFFER BUSY
	MOV.W	@SP+,R0 		;
	MOV.W	@SP+,R1 		;
	JMP	@RETIH3 		;
	.PAGE
;
;	OUTPUT ALARM ERROR SIGNAL
;
;	IN	DP : 0
;		SR : XI2+XI1+XI0
;
;	OUT	SR : XI2+XI1+XI0+?
;
DP1ALM: MOV.B	@IFPOTA,R0		;
	AND.B	#ZN-XBUSY-XFALT,R0	; SET BUSY HIGH, FAULT LOW
	MOV.B	R0,@IFPOTA		;
	BCLR.B	#QPREM,@MODEF:8 	; RESET PRINT ENABLE MODE
	BCLR.B	#QDP1E,@DP1F:8		; SET DATA INPUT DISABLE
	BCLR.B	#QSELRQ,@DP1F:8 	; RESET SELECT MODE REQUEST
	RTS				;
	.PAGE
	.SECTION	APL2,CODE,ALIGN=16
;
;	OUTPUT ONLINE/OFFLINE SIGNAL
;
;	IN	DP : 0
;
;	OUT	NONE
;
DP1ON:	MOV.B	@DPMDF:8,R0		;
	BEQ	DP1O_1			; BR IF NORAML MODE
	BTST.B	#QHDPM,R0		;
	BEQ	DP1O_2			; BR IF NOT HEX DUMP MODE
DP1O_1: BSET.B	#QSELRQ,@DP1F:8 	; SET SELECT MODE REQUEST
DP1O_2: RTS				;
;
DP1OFP: BSET.B	#QPRTRQ,@DP1F:8 	; SET PRINT OUT REQUEST
	BSET.B	#QDOFF,@PSWDF:8 	; SET PANEL SW DISABLE BY OFFLINE PRINT
DP1OFF: STC.W	SR,@-SP 		;
	LDC.W	#XI2+XI1+XI0,SR 	; DISABLE INTERRUPT
	MOV.B	@IFPOTA,R0		;
	AND.B	#ZN-XBUSY-XFALT,R0	; SET BUSY HIGH, FAULT LOW
	MOV.B	R0,@IFPOTA		;
	LDC.W	@SP+,SR 		; ENABLE INTERRUPT
	BCLR.B	#QDP1E,@DP1F:8		; SET DATA INPUT DISABLE
	BCLR.B	#QSELRQ,@DP1F:8 	; RESET SELECT MODE REQUEST
	RTS				;

;
;	OUTPUT PE SIGNAL
;
;	IN	DP : 0
;
;	OUT	NONE
;
DP1PER: BCLR.B	#QPE,@IFPOTA		; SET PE LOW  (NOT PE)
	RTS				;

DP1PES: LDC.W	#XI2+XI1+XI0,SR 	; DISABLE INTERRUPT
	MOV.B	@IFPOTA,R0		;
	AND.B	#ZN-XBUSY-XFALT,R0	; SET BUSY HIGH, FAULT LOW
	BSET.B	#QPE,R0 		; SET PE HIGH (PE)
	MOV.B	R0,@IFPOTA		;
	LDC.W	#0,SR			; ENABLE INTERRUPT
	BCLR.B	#QDP1E,@DP1F:8		; SET DATA INPUT DISABLE
	BCLR.B	#QSELRQ,@DP1F:8 	; RESET SELECT MODE REQUEST
	RTS				;
	.PAGE
;
;	INITIALIZE DATA INPUT
;
;	IN	DP : 0
;
;	OUT	NONE
;
DP1INI: MOV.B	#XCKS1,@TCR1		; SET TIMER CLOCK SELECT, DISABLE INT
	MOV.W	#DATBF,R1		;
	MOV.W	R1,@DABIP:8		; RESET DATA BUFFER IN POINTER
	MOV.W	R1,@DABOP:8		; RESET DATA BUFFER OUT POINTER
	CLR.W	R0			;
	MOV.W	R0,@DABDC:8		; RESET DATA BUFFER IN COUNTER
	MOV.B	R0,@DP1F:8		; SET DATA PROCESS PASS 1 FLAG 1
	BSR	RSMSC			; RESET MSB CONTROL FLAG
	MOV.B	R0,@DATCLR		; RESET 1 CHARACTER BUSY
	MOV.B	@TCSR1,R1		; DUMMY READ FOR IRQ RESET
	MOV.B	#XCCLRA,@TCSR1		; SET OCRA INTERVAL TIMER MODE
	MOV.B	@IPRB,R1		;
	AND.B	#H'0F,R1                ;
	OR.B	#H'30,R1                ; ENABLE DATA INPUT INTERRUPT
	MOV.B	R1,@IPRB		; SET DATA INPUT INTERRUPT LEVEL
	MOV.B	#ZN-XIPRM1,@INTDAT	;
	MOV.B	R0,@INTRST		; RESET INTERRUPT REQUEST
	BSET.B	#QIPRM1,@INTMSK 	; ENABLE INPUT PRIME INTERRUPT
;	BRA	DP1INT			; START INTERRUPT MODE

;
;	SET DATA INPUT INTERRUPT/POLLING MODE
;
;	IN	DP : 0
;
;	OUT	NONE
;
DP1INT: CMP.B	#XCKS1,@TCR1		;
	BNE	DP1I_1			; BR IF ALREADY INTERRUPT MODE
	BTST.B	#QDP1B,@DP1F:8		;
	BNE	DP1I_1			; BR IF INPUT DATA BUFFER BUSY
	MOV.B	#XICIE+XCKS1,@TCR1	; SET DATA INTERRUPT MODE
DP1I_1: RTS				;

DP1IMG: MOV.W	#BSRTB,R2		; SET BIT SEQUENCE REVERSE TABLE
DP1POL: LDC.W	#XI2+XI1+XI0,SR 	; DISABLE INTERRUPT
	MOV.B	#XCKS1,@TCR1		; DISABLE DATA INPUT INTERRUPT
	LDC.W	#0,SR			; INSURE FOR 2 SYSTEM CLOCK
	RTS				;
	.PAGE
;
;	ESC + # 	(MSB CONTROL SEQUENCE CANCEL)
;
RSMSC:	MOV.W	#ZMSBNC,@MSB0F:8	; SET MSB CONTROL FLAG
	RTS

;
;	ESC + = 	(MSB OFF MODE SET)
;
STMS0:	MOV.W	#ZMSBOF,@MSB0F:8	; SET MSB CONTROL FLAG
	RTS

;
;	ESC + > 	(MSB ON MODE SET)
;
STMS1:	MOV.W	#ZMSBON,@MSB0F:8	; SET MSB CONTROL FLAG
	RTS

;
;	CHANGE PRINT FORMAT BY PANEL SW
;
;	IN	NONE
;
;	OUT	NONE
;
CHGPF:	BSET.B	#QDPFC,@PSWDF:8 	; SET PANEL SW DISABLE BY PF CHANGE
	BSET.B	#QPFCRQ,@DP1F:8 	; SET PF CHANGE REQUEST
	RTS				;

;
;	CHANGE MODE BY PANEL SW
;
;	IN	R3 : NEW MODE
;
;	OUT	NONE
;911226 UP
CHGMD:	BSET.B	#QDMDC,@PSWDF:8 	; SET PANEL SW DISABLE BY MODE CHANGE
;
	MOV.B	R3,@UMOD04:8		; 911226+
	CMP.B	#10,R3			;+920520
	BEQ	CHGMD1			;+920520
	CMP.B	#9,R3			;+920316
	BEQ	CHGMD1			;+920316
	CMP.B	#6,R3			; 911226
	BEQ	CHGMD1			;   "
	CMP.B	#7,R3			;   "
	BEQ	CHGMD1			;   "
	CMP.B	#8,R3			; 920222
	BEQ	CHGMD1			;   "
CHGMD2: MOV.B	R3,@DP1MS:8		; SET NEW MODE
	BSET.B	#QMDCRQ,@DP1F:8 	; SET MODE CHANGE REQUEST
	RTS				;
CHGMD1: MOV.B	#0,R3			; 911226
	BRA	CHGMD2			;   "
	.PAGE
;
	.PAGE
;**********************
; 911224
MDFIX:	BSET.B	#QDMDC,@PSWDF:8 	; SET PANEL SW DISABLE BY MODE CHANGE
	MOV.B	R3,@UMOD00:8		; SET NEW MODE
	BSET.B	#QMDCRQ,@DP1F:8 	; SET MODE CHANGE REQUEST
	RTS				;
MDFIX1: BSET.B	#QDMDC,@PSWDF:8 	; SET PANEL SW DISABLE BY MODE CHANGE
	MOV.B	R3,@UMOD02:8		; SET NEW MODE
	BSET.B	#QMDCRQ,@DP1F:8 	; SET MODE CHANGE REQUEST
	RTS
MDFIX2: BSET.B	#QDMDC,@PSWDF:8 	; SET PANEL SW DISABLE BY MODE CHANGE
	MOV.B	R3,@UMOD03:8		; SET NEW MODE
	BSET.B	#QMDCRQ,@DP1F:8 	; SET MODE CHANGE REQUEST
	RTS
	.PAGE
;***********************
;
;	REQUEST TEST PRINT BY PANEL SW
;
;	IN	R0 : TEST PRINT TYPE NO.
;
;	OUT	NONE
;
REQTP:	BTST.B	#QCVRER,@ERRF:8 	;
	BNE	REQT_2			; BR IF COVER OPEN ERROR
	MOV.W	R0,@-SP 		;
	MOV.W	R3,@-SP 		;
	MOV.W	R4,@-SP 		;
	MOV.W	R5,@-SP 		;
	MOV.W	#INSP1,R4		; GET INSERT ENTRY
	CALDPH	#ZPOWN+XWACTF		;
	WAIDP3				;
	MOV.W	@SP+,R5 		;
	MOV.W	@SP+,R4 		;
	MOV.W	@SP+,R3 		;
	MOV.W	@SP+,R0 		;
	MOV.B	@SNSF:8,R1		;
	AND.B	#XBPES+XFPES+XSPES,R1	; GET PE SENSOR STATUS
	BEQ	REQT_2			; BR. IF SENSOR PE
	BSET.B	#QDTPR,@PSWDF:8 	; SET PANEL SW DISABLE BY TEST PRINT
	MOV.B	R0,@DP1TS:8		; SET TEST PRINT TYPE
	BSET.B	#QTPRRQ,@DP1F:8 	; SET TEST PRINT REQUEST
REQT_2: RTS				;

;
;	WAIT DP3 STOP
;
;	IN	DP : 0
;
;	OUT	NONE
;
WTDP3S: JSR	@CHKDP3 		; CHECK DP3 STATUS
	BNE	WTDP3S			; BR IF DP3 ACTIVE
	RTS				;
	.PAGE
;
;	CHECK PRINT/MODE/ACK REQUEST
;
;	IN	DP : 0
;
;	OUT  R0-FP : NOT CHANGE
;		DP : 0
;		EP : NOT CHANGE
;
CHKM_0: MOV.W	@SP+,R0 		;
CHKMD:	BTST.B	#QPRTA,@PRMDF:8 	;
	BNE	CHKM_1			; BR IF PRINT JOB ACTIVE
	BTST.B	#QPRTRQ,@DP1F:8 	;
	BEQ	CHKM_B			; BR IF NO PRINT OUT REQUEST
	JSR	@CHKDP3 		; CHECK DP3 STATUS
	BNE	CHKM_B			; BR IF DP3 TASK ACTIVE
	BCLR.B	#QPRTRQ,@DP1F:8 	;
	BTST.B	#QDP3S,@PRMDF:8 	;
	BNE	CHKM_A			; BR IF DP3 SUSPEND MODE
	PUSHEP				;
	STM	(R0-FP),@-SP		;
	JSR	@DP2PRT 		; PRINT OUT DATA
	BSR	WTDP3S			; WAIT DP3 STOP
	CALDPH	#ZPOFF			; SEND OFFLINE PACKET TO DP3
	LDM	@SP+,(R0-FP)		;
	POPEP				;
CHKM_A: BCLR.B	#QDOFF,@PSWDF:8 	; RESET PANEL SW DISABLE BY OFFLINE
CHKM_1: BTST.B	#QDP3M,@PRMDF:8 	;
	BNE	CHKM_7:16		; BR IF DP3 MULTI BLOCK MODE
CHKM_B: BCLR.B	#QPFCRQ,@DP1F:8 	;
	BEQ	CHKM_2			; BR IF NO PF CHANGE REQUEST
	PUSHEP				;
	STM	(R0-FP),@-SP		;
	BSR	WTDP3S			; WAIT DP3 STOP
	CALDPH	#ZPPFC			; SEND PF CHANGE PACKET TO DP3
	JSR	@DP2PFC 		; CHANGE PRINT FORMAT
	BCLR.B	#QDPFC,@PSWDF:8 	; RESET PANEL SW DISABLE
	LDM	@SP+,(R0-FP)		;
	POPEP				;
CHKM_2: BTST.B	#QMDCRQ,@DP1F:8 	;
	BEQ	CHKM_5:16		; BR IF NO MODE CHANGE REQUEST
	BTST.B	#QIPRRQ,@DP1F:8 	;
	BNE	CHKM_3			; BR IF INPUT PRIME RESET REQUEST
	JSR	@CHKDP3 		; CHECK DP3 STATUS
	BNE	CHKM_7:16		;
	BCLR.B	#QMDCRQ,@DP1F:8 	; CLEAR MODE CHANGE REQUEST FLAG
	CALDPH	#ZPMDC+XWACTF		; SEND MODE CHANGE PACKET TO DP3
	JSR	@DP2MDC 		; INITIALIZE DP2 FOR MODE CHANGE
	JSR	@CLIMB			; CLEAR IAMGE BUFFER
	BSR	CHKM_W:16		; WAIT DP3 ACTION END
	BSR	WTDP3S			; WAIT DP3 STOP
	CALDPH	#ZPMDC+XWACTF		; SEND MODE CHANGE PACKET TO DP3
	JSR	@DP2MDC 		; INITIALIZE DP2 FOR MODE CHANGE
	WAIDP3				; WAIT DP3 ACTION END
	BSR	DP1INT			; SET DATA INTERRUPT MODE
	BCLR.B	#QDMDC,@PSWDF:8 	; SET PANEL SW DISABLE BY MODE CHANGE
	MOV.B	@DP1MS:8,R0		; GET NEW MODE
	JMP	@DP2RST 		; RESTART DATA PROCESS PASS 2
	.PAGE
					;
CHKM_3: BTST.B	#QIPRM1,@INTPRE 	;
	BEQ	CHKM_3			; BR IF INPUT PRIME LOW
	BTST.B	#QCVRER,@ERRF:8 	;
	BNE	CHKM_3			; BR IF COVER ERROR
	BTST.B	#QPRTA,@PRMDF:8 	;
	BEQ	CHKM_9			; BR IF NOT PRINT ACTION
	BTST.B	#QDP3M,@PRMDF:8 	;
	BNE	CHKM_7:16		; BR IF DP3 MULTI BLOCK MODE
CHKM_9: BCLR.B	#QMDCRQ,@DP1F:8 	; RESET MODE CHANGE REQUEST FLAG
	BSET.B	#QIPRM,@MODEF:8 	; SET INPUT PRIME INITIALIZE MODE
	CALDPH	#ZPIPR+XWACTF		; SEND INPU PRIME PACKET
	JSR	@DP2IPR 		; INITIALIZE DP2 FOR INPUT PRIME
	JSR	@CLIMB			; CLEAR IAMGE BUFFER
	BSR	CHKM_W			; WAIT DP3 ACTION END
	BCLR.B	#QPFCM,@MODEF:8 	; RESET PF CHANGE MODE
	BCLR.B	#QSPCM,@MODEF:8 	; RESET SPEC. CHANGE MODE
	BCLR.B	#QSERVM,@MODEF:8	; RESET SERVICE MODE
	BCLR.B	#QIPRM,@MODEF:8 	; RESET INPUT PRIME INITIALIZE MODE
	JSR	@SWPRST 		; RESTART PANEL SW TASK
	BSR	DP1INI			; START DATA INPUT
	BTST.B	#QIPRRQ,@DP1F:8 	;
	BNE	CHKM_3			; BR IF INPUT PRIME RESET REQUEST
	BTST.B	#QPREM,@MODEF:8 	;
	BEQ	CHKM_4			; BR IF NOT PRINT ENABLE MODE
	BSET.B	#QSELRQ,@DP1F:8 	; SET SELECT MODE REQUEST
CHKM_4: BCLR.B	#QDIPR,@PSWDF:8 	; RESET PANEL SW DISABLE
	MOV.B	#ZNDAP,R0		; RESET DATA PROCESSING MODE
	JMP	@DP2RST 		; RESTART DATA PROCESS PASS 2
					;
CHKM_5: BCLR.B	#QTPRRQ,@DP1F:8 	;
	BEQ	CHKM_6			; BR IF NO TEST PRINT REQUEST
	PUSHEP				;
	STM	(R0-FP),@-SP		;
	MOV.B	@DP1TS:8,R0		; GET TEST PRINT TYPE
	JSR	@DP2TPR 		; START TEST PRINT
	CALDP3	#ZPNOP+XWACTF		; SEND DUMMY PACKET
	WAIDP3				; WAIT PRINT END
	BCLR.B	#QDTPR,@PSWDF:8 	; RESET PANEL SW DISABLE BY TEST PRINT
	LDM	@SP+,(R0-FP)		;
	POPEP				;
CHKM_6: BTST.B	#QSELRQ,@DP1F:8 	;
	BEQ	CHKM_7			; BR IF NO SELECT MODE REQUEST
	MOV.W	R0,@-SP 		;
	MOV.B	@DP1F:8,R0		;
	AND.B	#XTPRRQ+XMDCRQ+XPFCRQ+XPRTRQ,R0
	BNE	CHKM_0			; BR IF ANY OTHER REQUEST ON
	MOV.W	@SP+,R0 		;
	BTST.B	#QPEOVM,@PRMDF:8	;
	BEQ	SELON			; BR IF NOT PE OVERRIDE MODE
	BTST.B	#QPRTA,@PRMDF:8 	;
	BNE	CHKM_7			; BR IF PRINT JOB ACTIVE
	JSR	@CHKDP3 		;
	BEQ	SELON			; BR IF NOT DP3 ACTIVE
	BSR	WTDP3S			; WAIT DP3 STOP
	BTST.B	#QSELRQ,@DP1F:8 	;
	BNE	SELON			; BR IF NO SELECT MODE REQUEST
CHKM_7: RTS				;

CHKM_W: BTST.B	#QPRTA,@PRMDF:8 	;
	BEQ	CHKM_Z			; BR IF NOT PRINT ACTION
	BTST.B	#QDP3M,@PRMDF:8 	;
	BEQ	CHKM_Z			; BR IF NOT DP3 MULTI BLOCK MODE
	CALDP3	#ZPPRE			; SEND DP3 TO PRINT END
CHKM_Z:
	WAIDP3				; WAIT DP3 ACTION END
	RTS
	.PAGE
;
;	SET SELECT ON MODE
;
;	IN	NONE
;
;	OUT	NONE
;
SELON:	BTST.B	#QDP1B,@DP1F:8		;
	BEQ	SELO_3			; BR IF NOT INPUT DATA BUFFER BUSY
	LDC.W	#XI2+XI1+XI0,SR 	; DISABLE INTERRUPT
	BCLR.B	#QSELRQ,@DP1F:8 	;
	BEQ	SELO_2			; BR IF NO SELECT MODE REQUEST
SELO_1: BCLR.B	#QPE,@IFPOTA		; SET PE LOW
	BSET.B	#QFALT,@IFPOTA		; SET FAULT HIGH
	LDC.W	#0,SR			; ENABLE INTERRUPT
	BSET.B	#QDP1E,@DP1F:8		; SET DATA INPUT ENABLE
	RTS				;
					;
SELO_2: LDC.W	#0,SR			; ENABLE INTERRUPT
	RTS				;
					;
SELO_3: LDC.W	#XI2+XI1+XI0,SR 	; DISABLE INTERRUPT
	BCLR.B	#QSELRQ,@DP1F:8 	;
	BEQ	SELO_2			; BR IF NO SELECT MODE REQUEST
	BTST.B	#QICF,@TCSR1		;
	BNE	SELO_1			; BR IF DATA INPUT EXIST
	BCLR.B	#QPE,@IFPOTA		; SET PE LOW
	BSET.B	#QFALT,@IFPOTA		; SET FAULT HIGH
	BSET.B	#QACK,@IFPOTA		; SET ACK LOW
	DELAY5				; DEALY 5uS
	BSET.B	#QBUSY,@IFPOTA		; SET BUSY LOW
	DELAY5				; DELAY 5uS
	BCLR.B	#QACK,@IFPOTA		; SET ACK HIGH
	LDC.W	#0,SR			; ENABLE INTERRUPT
	BSET.B	#QDP1E,@DP1F:8		; SET DATA INPUT ENABLE
	RTS				;
	.PAGE
;
;	GET CHARACTER	(1 CHARACTER BUSY)
;
;	IN	NONE
;
;	OUT   R0.L : INPUT DATA
;	     R2-FP : NOT CHANGE
;		DP : 0
;
GETC_0: BTST.B	#QPRFST,@PRMDF:8	;
	BNE	GETC_1			; BR IF DATA CONTINUE
	BSR	CHKMD			; CHECK REQUEST
GETC:	LDC.B	#0,DP			;
	BTST.B	#QDP1E,@DP1F:8		;
	BEQ	GETC_0			; BR IF DATA INPUT DISABLE
GETC_1: MOV.W	@DABDC:8,R0		;
	BEQ	GETC_6			; BR IF INPUT DATA BUFFER EMPTY
GETC_2: MOV.W	@DABOP:8,R1		; GET DATA BUFFER OUT POINTER
	MOV.B	@R1+,R0 		; GET INPUT DATA
	AND.B	@MSB0F:8,R0		; CONTROL MSB OFF MODE
	OR.B	@MSB1F:8,R0		; CONTROL MSB ON MODE
	CMP.W	#DATBE,R1		;
	BCC	GETC_3			; BR IF INPUT DATA BUFFER END
	MOV.W	R1,@DABOP:8		; UPDATE DATA BUFFER OUT POINTER
	ADD:Q.W #-1,@DABDC:8		; UPDATE INPUT DATA COUNTER
	BTST.B	#QDP1B,@DP1F:8		;
	BNE	GETC_4			; BR IF INPUT DATA BUFFER BUSY
	RTS				;
					;
GETC_3: MOV.W	#DATBF,R1		; GET INPUT DATA BUFFER START
	MOV.W	R1,@DABOP:8		; UPDATE DATA BUFFER OUT POINTER
	ADD:Q.W #-1,@DABDC:8		; UPDATE INPUT DATA COUNTER
	BTST.B	#QDP1B,@DP1F:8		;
	BEQ	GETC_5			; BR IF NOT INPUT DATA BUFFER BUSY
GETC_4: CMP.W	#ZDATH4,@DABDC:8	;
	BCC	GETC_5			; BR IF NOT BUFFER READY
;	BSR	OUTACK			; OUTPUT ACK
	BCLR.B	#QDP1B,@DP1F:8		; RESET INPUT DATA BUFFER BUSY
	MOV.B	#XICIE+XCKS1,@TCR1	; SET DATA INTERRUPT MODE
GETC_5: RTS				;
	.PAGE
;
;	GETC AT INPUT BUFFER EMPTY
;
GETC_6: MOV.B	#XCKS1,@TCR1		; DISABLE DATA INPUT INTERRUPT
	NOP				; INSURE FOR 2 SYSTEM CLOCK
	MOV.W	@DABDC:8,R1		;
	BEQ	GETC_9			; BR IF NOT INPUT DATA BUFFER EMPTY
	MOV.B	#XICIE+XCKS1,@TCR1	; SET DATA INTERRUPT MODE
	BRA	GETC_2			;
					;
GETC_7: BSR	CHKMD			; CHECK REQUEST
GETC_8: BTST.B	#QDP1E,@DP1F:8		;
	BEQ	GETC_7			; BR IF DATA INPUT DISABLE
GETC_9: BTST.B	#QICF,@TCSR1		;
	BEQ	GETC_8			; BR IF NOT DATA INPUT
	MOV.B	@IFREAD,R0		; READ INPUT DATA
	BSR	OUTACK			; RESET DATA INPUT, OUTPUT ACK
	NOT.B	R0			; INVERT BIT ON/OFF
	AND.B	@MSB0F:8,R0		; CONTROL MSB OFF MODE
	OR.B	@MSB1F:8,R0		; CONTROL MSB ON MODE
	MOV.B	#XICIE+XCKS1,@TCR1	; SET DATA INTERRUPT MODE
	RTS				;
	.PAGE
;
;	READ IAMGE DATA
;
;	IN	R2 : BIT SEQUENCE REVERSE TABLE
;		DP : 0
;
;	OUT	R2 : IMAGE DATA
;
READ_1: BSR	CHKMD			; CHECK REQUEST
READ_2: BTST.B	#QDP1E,@DP1F:8		;
	BEQ	READ_1			; BR IF DATA INPUT DISABLE
READI:	BTST.B	#QICF,@TCSR1		;
	BEQ	READ_2			; BR IF NOT DATA INPUT
	MOV.B	@IFREAD,R2		; READ INPUT DATA
	NOT.B	R2			; INVERT BIT ON/OFF
	AND.B	@MSB0F:8,R2		; CONTROL MSB OFF MODE
	OR.B	@MSB1F:8,R2		; CONTROL MSB ON MODE
;	BRA	OUTACK			; RESET DATA INPUT, OUTPUT ACK

;
;	ACK OUTPUT
;
;	IN	DP : 0
;
;	OUT  R0-FP : NOT CHANGE
;
OUTACK: BCLR.B	#QBUSY,@IFPOTA		; SET BUSY HIGH
	MOV.B	R0,@DATCLR		; RESET 1 CHARACTER BUSY
	BCLR.B	#QICF,@TCSR1		; RESET DATA INTERRUPT REQUEST
	LDC.W	#XI2+XI1+XI0,SR 	; DISABLE INTERRUPT
	BTST.B	#QDP1E,@DP1F:8		;
	BEQ	OUTA_1			; BR IF DATA INPUT DISABLE
	BSET.B	#QACK,@IFPOTA		; SET ACK LOW
	DELAY5				; DEALY 5uS
	BSET.B	#QBUSY,@IFPOTA		; SET BUSY LOW
	DELAY5				; DELAY 5uS
	BCLR.B	#QACK,@IFPOTA		; SET ACK HIGH
OUTA_1: LDC.W	#0,SR			; ENABLE INTERRUPT
	RTS				;
	.PAGE
;
;	GET 24 PIN IMAGE DATA	(1 CHARACTER BUSY)
;
;	CAUTION : MUST BE IN POLLING MODE
;
;	IN	R2 : BIT SEQUENSE REVERSE TABLE
;		DP : 0
;
;	OUT   R0.L : IMAGE DATA 1
;	      R0.H : IMAGE DATA 2
;	      R1.L : IMAGE DATA 3
;	     R3-FP : NOT CHANGE
;		DP : 0
;
GETH:	BSR	READI			; READ IMAGE DATA
	MOV.B	@R2,R0			; REVERSE BIT SEQUENCE
	SWAP	R0			;
GETH_1: BSR	READI			; READ IMAGE DATA
	MOV.B	@R2,R0			; REVERSE BIT SEQUENCE
	SWAP	R0			;
GETH_2: BSR	READI			; READ IMAGE DATA
	MOV.B	@R2,R1			; REVERSE BIT SEQUENCE
	RTS				;
					;
GETI_0: BTST.B	#QPRFST,@PRMDF:8	;
	BNE	GETI_1			; BR IF DATA CONTINUE
	BSR	CHKMD			; CHECK PRINT/ACK REQUEST
GETI24: BTST.B	#QDP1E,@DP1F:8		;
	BEQ	GETI_0			; BR IF DATA INPUT DISABLE
GETI_1: MOV.W	@DABDC:8,R0		;
	BEQ	GETH			; BR IF INPUT DATA BUFFER EMPTY
	MOV.W	@DABOP:8,R1		; GET DATA BUFFER OUT POINTER
	MOV.B	@R1+,R2 		; GET INPUT DATA
	AND.B	@MSB0F:8,R2		; CONTROL MSB OFF MODE
	OR.B	@MSB1F:8,R2		; CONTROL MSB ON MODE
	MOV.B	@R2,R0			; REVERSE BIT SEQUENCE
	SWAP	R0			;
	CMP.W	#DATBE-2,R1		;
	BCC	GETI_4			; BR IF INPUT DATA BUFFER END
	ADD:Q.W #-1,@DABDC:8		; UPDATE INPUT DATA COUNTER
	BEQ	GETI_2			; BR IF INPUT DATA BUFFER EMPTY
	MOV.B	@R1+,R2 		; GET INPUT DATA
	AND.B	@MSB0F:8,R2		; CONTROL MSB OFF MODE
	OR.B	@MSB1F:8,R2		; CONTROL MSB ON MODE
	MOV.B	@R2,R0			; REVERSE BIT SEQUENCE
	SWAP	R0			;
	ADD:Q.W #-1,@DABDC:8		; UPDATE INPUT DATA COUNTER
	BEQ	GETI_3			; BR IF INPUT DATA BUFFER EMPTY
	MOV.B	@R1+,R2 		; GET INPUT DATA
	AND.B	@MSB0F:8,R2		; CONTROL MSB OFF MODE
	OR.B	@MSB1F:8,R2		; CONTROL MSB ON MODE
	MOV.W	R1,@DABOP:8		; UPDATE DATA BUFFER OUT POINTER
	MOV.B	@R2,R1			; REVERSE BIT SEQUENCE
	ADD:Q.W #-1,@DABDC:8		; UPDATE INPUT DATA COUNTER
	BTST.B	#QDP1B,@DP1F:8		;
	BNE	GETI_8			; BR IF INPUT DATA BUFFER BUSY
	RTS				;
					;
GETI_2: MOV.W	R1,@DABOP:8		; UPDATE DATA BUFFER OUT POINTER
	BRA	GETH_1			;
					;
GETI_3: MOV.W	R1,@DABOP:8		; UPDATE DATA BUFFER OUT POINTER
	BRA	GETH_2			;
					;
GETI_4: CMP.W	#DATBE,R1		;
	BCS	GETI_5			; BR IF NOT INPUT DATA BUFFER END
	MOV.W	#DATBF,R1		;
GETI_5: ADD:Q.W #-1,@DABDC:8		; UPDATE INPUT DATA COUNTER
	BEQ	GETI_2			; BR IF INPUT DATA BUFFER EMPTY
	MOV.B	@R1+,R2 		; GET INPUT DATA
	AND.B	@MSB0F:8,R2		; CONTROL MSB OFF MODE
	OR.B	@MSB1F:8,R2		; CONTROL MSB ON MODE
	MOV.B	@R2,R0			; REVERSE BIT SEQUENCE
	SWAP	R0			;
	CMP.W	#DATBE,R1		;
	BCS	GETI_6			; BR IF NOT INPUT DATA BUFFER END
	MOV.W	#DATBF,R1		;
GETI_6: ADD:Q.W #-1,@DABDC:8		; UPDATE INPUT DATA COUNTER
	BEQ	GETI_3			; BR IF INPUT DATA BUFFER EMPTY
	MOV.B	@R1+,R2 		; GET INPUT DATA
	AND.B	@MSB0F:8,R2		; CONTROL MSB OFF MODE
	OR.B	@MSB1F:8,R2		; CONTROL MSB ON MODE
	CMP.W	#DATBE,R1		;
	BCC	GETI_7			; BR IF INPUT DATA BUFFER END
	MOV.W	R1,@DABOP:8		; UPDATE DATA BUFFER OUT POINTER
	MOV.B	@R2,R1			; REVERSE BIT SEQUENCE
	ADD:Q.W #-1,@DABDC:8		; UPDATE INPUT DATA COUNTER
	BTST.B	#QDP1B,@DP1F:8		;
	BNE	GETI_8			; BR IF INPUT DATA BUFFER BUSY
	RTS				;

GETI_7: MOV.W	#DATBF,R1		;
	MOV.W	R1,@DABOP:8		; UPDATE DATA BUFFER OUT POINTER
	MOV.B	@R2,R1			; REVERSE BIT SEQUENCE
	ADD:Q.W #-1,@DABDC:8		; UPDATE INPUT DATA COUNTER
	BTST.B	#QDP1B,@DP1F:8		;
	BEQ	GETI_9			; BR IF NOT INPUT DATA BUFFER BUSY
GETI_8: CMP.W	#ZDATH4,@DABDC:8	;
	BCC	GETI_9			; BR IF NOT BUFFER READY
;	BSR	OUTACK			; OUTPUT ACK
	BCLR.B	#QDP1B,@DP1F:8		; RESET INPUT DATA BUFFER BUSY
GETI_9: RTS				;
	.PAGE
;
;	GET 8 PIN IMAGE DATA	(1 CHARACTER BUSY)
;
;	IN	R2 : BIT SEQUENCE REVERSE TABLE
;		DP : 0
;
;	OUT   R0.L : IMAGE DATA
;	     R2-FP : NOT CHANGE
;		DP : 0
;
GET8_0: BTST.B	#QPRFST,@PRMDF:8	;
	BNE	GET8_1			; BR IF DATA CONTINUE
	BSR	CHKMD			; CHECK REQUEST
GETI8:	BTST.B	#QDP1E,@DP1F:8		;
	BEQ	GET8_0			; BR IF DATA INPUT DISABLE
GET8_1: MOV.W	@DABDC:8,R0		;
	BEQ	GET8_2			; BR IF INPUT DATA BUFFER EMPTY
	MOV.W	@DABOP:8,R1		; GET DATA BUFFER OUT POINTER
	MOV.B	@R1+,R2 		; GET INPUT DATA
	AND.B	@MSB0F:8,R2		; CONTROL MSB OFF MODE
	OR.B	@MSB1F:8,R2		; CONTROL MSB ON MODE
	MOV.B	@R2,R0			; REVERSE BIT SEQUENCE
	CMP.W	#DATBE,R1		;
	BCC	GETI_7			; BR IF INPUT DATA BUFFER END
	MOV.W	R1,@DABOP:8		; UPDATE DATA BUFFER OUT POINTER
	ADD:Q.W #-1,@DABDC:8		; UPDATE INPUT DATA COUNTER
	BTST.B	#QDP1B,@DP1F:8		;
	BNE	GETI_8			; BR IF INPUT DATA BUFFER BUSY
	RTS				;
					;
GET8_2: BSR	READI			; READ IMAGE DATA
	MOV.B	@R2,R0			; REVERSE BIT SEQUENCE
	RTS				;
;
	.END
