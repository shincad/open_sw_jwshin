	.PROGRAM	pnlios
	.HEADING	"M4324 OPERATION PANEL I/O SYSTEM MODULE"
	.LIST		NOCOND,NOEXP
;********************************************************
;							*
;	M4324 OPERATION PANEL I/O SYSTEM MODULE		*
;							*
;	FILE NAME	PNLIOS.MAR			*
;	CREATED		06/MAR/1990			*
;							*
;********************************************************
;
	.EXPORT		INILCD,INILBF
	.EXPORT		LCDTBL,LCDBLS,LCDBLC
	.EXPORT		LCDCAL,LCDDLD,LCDCON,LCDBFS,LCDLST,LCDLX
	.EXPORT		LCDS1, LCDS2, LCDSX, LCDSTR,LCDCX, LCDCHR
	.EXPORT		LCDHX1,LCDHX2,LCDHX3,LCDHX4,LCDDE0,LCDDEC
	.EXPORT		BZOFF, BZOFF1,BZON1, BZON2
	.EXPORT		BZCON1,BZCON2,BZINT1,BZINT2
	.EXPORT		LEDOFF,LEDON, LEDXOR,LEDSET,LEDBLS,LEDBLC

	.IMPORT		ZTLCD, LCDTCB,LCDSTK,LCDBF, ZRDMD, ZWRMD

	.INCLUDE	"COMMON.H"
	.INCLUDE	"M43RTM.H"
	.INCLUDE	"SYSRAM.H"
	.INCLUDE	"PNLRAM.H"
	.INCLUDE	"GAPNL.H"
	.INCLUDE	"CPUIO.H"
	.PAGE
;
;	LCD FUNCTION CODE
;
;	.EQU	  0			; END OF STRING
;ZLOF:	.EQU	  1			; DISPLAY OFF
;ZLON0:	.EQU	  2			; DISPLAY ON (CURSOR OFF)
;ZLON1:	.EQU	  3			; DISPALY ON (UNDERLINE CURSOR)
;ZLON2:	.EQU	  4			; DISPLAY ON (BLINK CURSOR)
;ZLCL0:	.EQU	  5			; DISPLAY CLEAR
;ZLCL1:	.EQU	  6			; DISPLAY CLEAR TO END OF DISPLAY
;	.EQU	  7			; NO FUNCTION
ZLDL1:	.EQU	  8			; DOWN LOAD CHARACTER 1
ZLPOS:	.EQU	128			; CURSOR POSITION SET
ZLCDSZ:	.EQU	 16			; LCD SIZE PER LINE

;
;	LCD INSTRUCTION CODE
;
ZLCCL:	.EQU	H'01			; DISPLAY CLEAR
ZLCEM	.EQU	H'06			; ENTRY MODE SET
;ZLCOF	.EQU	H'08			; DISPLAY OFF
;ZLCON0:.EQU	H'0C			; DISPLAY ON (CURSOR OFF)
;ZLCON1:.EQU	ZLCON0+H'02		; DISPLAY ON (UNDERLINE CURSOR)
;ZLCON2:.EQU	ZLCON0+H'01		; DISPLAY ON (BLINK CURSOR)
ZLCFN	.EQU	H'38			; FUNCTION SET (8BIT/2LINE/5x7DOT)
QLCCG:	.EQU	  6			; CG RAM ADDRESS SET BIT
QLCDD:	.EQU	  7			; DD RAM ADDRESS SET BIT

;
;	LCD I/O WORK AREA
;
	.SECTION	LCDRAM,DUMMY,LOCATE=H'FEF9
LCDPC:	.RES.B	  1			; LCD DISPLAY POSITION COUNTER
LCDBP:	.RES.W	  1			; LCD BUFFER POINTER
	.PAGE
	.SECTION	SYS1,CODE,ALIGN=16
;
;	LCD BLINK I/O TASK DEFINITION TABLE
;
	.ALIGN		  2
LCDTBL:	.DATA.W		LCDTCB		; TCB
	.DATA.B		  0		; PRIORITY
	.DATA.B		ZTIST4		; STATUS
	.DATA.W		LCDSTK		; STACK
	.DATA.W		LCDINI		; ENTRY
	.DATA.B		PAGE LCDINI	; CP
	.DATA.B		  0		; DP
	.DATA.B		  0		; EP
	.DATA.B		ZBR		; BR
	.DATA.W		  0		; NO MAIL BOX
	.DATA.W		  0		; NO PACKET

;
;	LCD I/O CALL
;
;	IN	R1 : I/O ENTRY
;		R5 : LCD BUFFER NO.
;
;	OUT	FP : LCD BUFFER POINTER
;
LCDCAL:	CMP.B	#1,R5			;
	BEQ	LCDC_1			; BR IF 1ST BUFFER SELECT
	CMP.B	#2,R5			;
	BEQ	LCDC_2			; BR IF 2ND BUFFER SELECT
	TST.B	R5			;
	BEQ	LCDC_3			; BR IF CURRENT BUFFER SELECT
	CLR.W	FP			; SET DIRECT OUTPUT MODE
	JMP	@R1			; EXECUTE LCD I/O
					;
LCDC_1:	MOV.W	#LCDBF1,FP		; GET LCD BUFFER 1 POINTER
	JMP	@R1			; EXECUTE LCD I/O
					;
LCDC_2:	MOV.W	#LCDBF2,FP		; GET LCD BUFFER 2 POINTER
	JMP	@R1			; EXECUTE LCD I/O
					;
LCDC_3:	MOV.W	@LCDBP:8,FP		; GET CURRENT LCD BUFFER POINTER
	JMP	@R1			; EXECUTE LCD I/O
	.PAGE
;
;	INITIALIZE LCD I/O
;
;	IN	NONE
;
;	OUT	NONE
;
INILCD:	MOV.B	#ZLPOS,R0		;
	MOV.B	R0,@LCDPC:8		; RESET CURSOR POSITION COUNTER
	CLR.W	R0			;
	MOV.W	R0,@LCDBP:8		; SET DIRECT OUTPUT MODE
	MOV.B	#ZWRMD,@SWPCNT		; SET CONTROL WORD
	MOV.B	R0,@SWPDBC		; RS, R/W, E = LOW
	MOV.W	#2042,R0		; SET 4.9mS DELAY
	MOV.B	#ZLCFN,R2		;
	BSR	INIL_2			; SET 8 BIT INTERFACE
	BSR	INIL_1			; SET 8 BIT INTERFACE
	BSR	INIL_1			; SET 8 BIT INTERFACE
	BSR	INIL_1			; SET 2 LINE, 5x7 DOT
	MOV.B	#ZLCOF,R2		; DISPLAY OFF
	BSR	INIL_1			;
	MOV.W	#2042,R0		; SET 4.9mS DELAY
	MOV.B	#ZLCCL,R2		; CLEAR DISPLAY
	BSR	INIL_2			;
	MOV.B	#ZLCEM,R2		; SET ENTRY MODE
	BSR	INIL_1			;
	MOV.B	#3,@SWPDBF		; OUTPUT LCD CONTRAST STATUS
	MOV.B	#ZLCON0,R2		; DISPLAY ON
INIL_1:	MOV.W	#50,R0			; SET 120uS DELAY
INIL_2:	BSET.B	#QLCDE,@SWPDBC		; SET E = HIGH
	MOV.B	R2,@SWPDBB		; OUTPUT COMMAND MODE
	BCLR.B	#QLCDE,@SWPDBC		; SET E = LOW
INIL_3:	NOP				;
	SCB/F	R0,INIL_3		;
INIL_4:	RTS				;

;
;	INITIALIZE LCD BUFFER
;
;	IN	NONE
;
;	OUT	NONE
;
INILBF:	MOV.W	#LCDBF,FP		; GET LCD BUFFER POINTER
	BSR	INIL_6			;
INIL_6:	CLR.W	@FP+			; RESET LCD BLINK STATUS
	CLR.W	@FP+			;
	MOV.B	#ZLPOS,@FP+		; RESET CURSOR POSITION
	MOV.B	#ZLCON0,@FP+		; RESET DISPLAY MODE
	MOV.W	#"  ",R0		;
	MOV.W	#ZLCDSZ-1,R5		;
INIL_7:	MOV.W	R0,@FP+			; CLEAR LCD BUFFER
	SCB/F	R5,INIL_7		;
	RTS				;
	.PAGE
;
;	OUTPUT LCD DOWNLOAD CG
;
;	IN   EP R4 : CG PATTERN TABLE POINTER
;
;	OUT	NONE
;
LCDD_1:	AND.B	#H'07,R2		;
	SHLL.B	R2			; CALCULATE CG RAM ADDRESS
	SHLL.B	R2			;
	SHLL.B	R2			;
	BSET.B	#QLCCG,R2		; SET CG RAM SELECT BIT ON
	BSR	LOPI:16			; CG RAM ADDRESS
	MOV.B	#8-1,R5			; SET LCD CG SIZE
LCDD_2:	MOV.B	@R4+,R2			; GET LCD CG PATTERN
	BSR	LOPD:16			; WRITE LCD CG RAM
	SCB/F	R5,LCDD_2		;
LCDDLD:	MOV.B	@R4+,R2			; GET CHARACTER CODE
	BNE	LCDD_1			; BR IF NOT LCD CG END
	RTS				;

;
;	SET LCD CONTRAST
;
;	IN	R3 : LCD CONTRAST STATUS
;
;	OUT	NONE
;
LCDCON:	AND.B	#ZLCDAJ,R3		;
	LDC.W	#XI2+XI1+XI0,SR		; DISABLE INETRRUPT
	MOV.B	@SWPDBF,R0		;
	AND.B	#ZN-ZLCDAJ,R0		;
	OR.B	R3,R0			;
	LDC.W	#0,SR			; ENABLE INETRRUPT
	MOV.B	R0,@SWPDBF		; OUTPUT LCD CONTRAST STATUS
	RTS				;
	.PAGE
;
;	SET DISPLAY BLINK
;
;	IN	R2 : BLINK STATUS OF 1ST LINE
;		R3 : BLINK STATUS OF 2ND LINE
;		FP : LCD BUFFER POINTER
;
;	OUT	NONE
;
LCDBLS:	TST.W	FP			;
	BEQ	LCDB_2			; BR IF DIRECT OUTPUT MODE
	OR.W	@(YLCDS1,FP),R2		;
	MOV.W	R2,@(YLCDS1,FP)		; SET BLINK STATUS
	OR.W	@(YLCDS2,FP),R3		;
	MOV.W	R3,@(YLCDS2,FP)		;
	CMP.W	@LCDBP:8,FP		;
	BNE	LCDB_2			; BR IF NOT CURRENT BUFFER
	OR.W	R2,R3			;
	BEQ	LCDB_2			; BR IF NO BLINK CHARACTER
LCDB_1:	MOV.W	#LCDTCB,R1		;
	BEQ	LCDB_2			; BR IF NO LCD TASK
	MOV.W	#ZTLCD,R2		; SET BLINK INTERVAL
	CYCWUP				; CYCLIC WAKE UP LCD BLINK TASK
LCDB_2:	RTS				;

;
;	CLEAR DISPLAY BLINK
;
;	IN	R2 : BLINK STATUS OF 1ST LINE
;		R3 : BLINK STATUS OF 2ND LINE
;		FP : LCD BUFFER POINTER
;
;	OUT	NONE
;
LCDBLC:	TST.W	FP			;
	BEQ	LCDB_2			; BR IF DIRECT OUTPUT MODE
	NOT.W	R2			;
	AND.W	@(YLCDS1,FP),R2		;
	MOV.W	R2,@(YLCDS1,FP)		; RESET BLINK STATUS
	NOT.W	R3			;
	AND.W	@(YLCDS2,FP),R3		;
	MOV.W	R3,@(YLCDS2,FP)		;
	RTS				;
	.PAGE
;
;	SELECT LCD BUFFER
;
;	IN	FP : LCD BUFFER POINTER
;
;	OUT	NONE
;
LCDBFS:	CMP.W	@LCDBP:8,FP		;
	BEQ	LCDB_2			; BR IF SAME BUFFER
	MOV.W	FP,@LCDBP:8		; SET CURRENT LCD BUFFER
	BEQ	LCDB_2			; BR IF DIRECT OUTPUT MODE
	MOV.B	@(YLCDMD,FP),R2		;
	BSR	LOPI:16			; SET DISPLAY MODE
	BSR	LCDBUF			; DISPLAY LCD BUFFER
	MOV.W	@(YLCDS2,FP),R0		;
	OR.W	@FP,R0			;
	BNE	LCDB_1			; BR IF LCD BLINK MODE
	RTS				;

;
;	LCD BUFFER DISPLAY
;
;	IN	FP : LCD BUFFER POINTER
;
;	OUT	NONE
;
LCDBUF:	MOV.W	FP,R0			; GET LCD BUFFER POINTER
	BSR	LHOM:16			; SET CURSOR HOME
	MOV.W	#ZLCDSZ*2-1,R5		;
LCDB_3:	MOV.B	@R0+,R2			;
	BSR	LDAT1:16		; DISPLAY LCD BUFFER
	SCB/F	R5,LCDB_3		;
	MOV.B	@(YLCDPC,FP),R2		;
	BRA	LPOS1:16		; SET CURSOR POSITION
	.PAGE
;
;	LCD BLINK TASK
;
LCDINI:					;
	SLPTSK				;
	MOV.W	@LCDBP:8,FP		; GET CURRENT LCD BUFFER
	BEQ	LCDI_3			; BR IF DIRECT OUTPUT MODE
	MOV.W	@(YLCDS1,FP),R4		; GET BLINK STATUS
	MOV.W	@(YLCDS2,FP),R5		;
	BNE	LCD1_1			; BR IF BLINK MODE
	TST.W	R4			;
	BEQ	LCDI_3			; BR IF NOT BLINK MODE
LCD1_1:	MOV.W	FP,R0			;
	ADD.W	#-1,R0			;
LCDI_2:	ADD.W	#1,R0			; UPDATE LCD BUFFER POINTER
	SHLL.W	R5			;
	ROTXL.W	R4			; CHECK BLINK STATUS
	BCS	LCDI_4			; BR IF BLINK CHARACTER HIT
	BNE	LCDI_2			; BR IF NOT BLINK CHARCTER END
	TST.W	R5			;
	BNE	LCDI_2			; BR IF NOT BLINK CHARACTER END
	MOV.B	@(YLCDPC,FP),R2		;
	BSR	LPOS1:16		; SET CURRENT CURSOR POSITION
	SLPTSK				;
	MOV.W	@LCDBP:8,FP		; GET CURRENT LCD BUFFER
	BEQ	LCDI_3			; BR IF DIRECT OUTPUT MODE
	BSR	LCDBUF			; DISPLAY LCD BUFFER
	MOV.W	@(YLCDS1,FP),R0		;
	OR.W	@(YLCDS2,FP),R0		;
	BNE	LCDINI			; BR IF BLINK CONTINUE
LCDI_3:	MOV.W	#LCDTCB,R1		;
	CANCYC				; STOP LCD BLINK TASK
	BRA	LCDINI			;
					;
LCDI_4:	MOV.W	R0,R2			;
	SUB.W	FP,R2			; CALCULATE DISPLAY POSITION
	BSET.B	#QLCDD,R2		;
	BSR	LPOS1:16		; SET DISPLAY POSITION
LCDI_5:	MOV.B	#" ",R2			;
	BSR	LDAT1:16		; DISPLAY SPACE
	ADD.W	#1,R0			; UPDATE LCD BUFFER POINTER
	SHLL.W	R5			;
	ROTXL.W	R4			;
	BCS	LCDI_5			; BR IF BLINK CHARCTER HIT
	BRA	LCDI_2			;
	.PAGE
;
;	DISPLAY STRING		LCDS1 : DISPLAY FROM 1ST LINE
;				LCDS2 : DISPLAY FROM 2ND LINE
;				LCDS3 : DISPLAY FROM R2 POSITION
;
;	IN   EP R4 : STRING POINTER
;		FP : LCD BUFFER POINTER
;
;	OUT	NONE
;
LCDS1:	MOV.B	#ZLPOS,R2		; DISPLAY FROM 1ST LINE START
	BRA	LCDSX			;

LCDS2:	MOV.B	#ZLPOS+ZLCDSZ,R2	; DISPLAY FROM 2ND LINE START
	BRA	LCDSX			;

LCDLST:	MOV.B	@R4+,R2			; GET DISPLAY POSITION
LCDLX:	MULXU.B	@R4+,R3			; MESSAGE SIZE x MESSAGE NO.
	ADD.W	R3,R4			; GET MESSAGE POINTER
LCDSX:	BSR	LPOS			; DISPLAY FROM R2 POSITION
LCDSTR:	MOV.B	@R4+,R2			; GET CHARACTER FROM STRING
	BEQ	LCDF_5			; BR IF END OF STRING
	BSR	LCDCHR			; DISPLAY CHARACTER
	BRA	LCDSTR			; BR IF NOT LOOP END

;
;	DISPLAY CHARACTER
;
;	IN	R2 : POSITION, CHARACTER
;		FP : LCD BUFFER POINTER
;
;	OUT	NONE
;
LCDCX:	SWAP	R2			;
	BSR	LPOS			; SET DISPLAY POSITION
	SWAP	R2			;
;	BRA	LCDCHR			; DISPLAY CHARACTER

;
;	DISPLAY CHARACTER
;
;	IN	R2 : CHARACTER
;		FP : LCD BUFFER POINTER
;
;	OUT	NONE
;
LCDCHR:	CMP.B	#ZLDL1,R2		;
	BCS	LCDFNC			; BR IF FUNCTION CODE
	CMP.B	#ZLPOS,R2		;
	BCS	LDAT			; BR IF DATA
	CMP.B	#ZLPOS+ZLCDSZ*2,R2	;
	BCS	LPOS			; BR IF CURSOR POSITION SET
	BRA	LDAT			;
	.PAGE
;
;	LCD FUNCTION CODE
;
LCDF_T:	.DATA.B		  0		; 0
	.DATA.B		ZLCOF		; 1  DISPLAY OFF
	.DATA.B		ZLCON0		; 2  DISPALY ON, CURSOR OFF
	.DATA.B		ZLCON1		; 3  DISPLAY ON, UNDERLINE CURSOR
	.DATA.B		ZLCON2		; 4  DISPLAY ON, BLINK CURSOR
	.DATA.B		254		; 5  DISPLAY CLEAR
	.DATA.B		255		; 6  DISPLAY CLEAR TO END OF DISPLAY
	.DATA.B		  0		; 7
	;
LCDFNC:	EXTU	R2			;
	ADD.W	#LCDF_T,R2		; GET FUNCTION CODE TABLE
	MOV.B	@R2,R2			; GET LCD INSTRUCTION CODE
	BEQ	LCDF_5			; BR IF NO OPERATION
	CMP.B	#254,R2			;
	BCS	LMOD			; BR IF DISPLAY ON/OFF
	BNE	LCDF_1			; BR IF DISPLAY CLEAR TO END OF LINE
	BSR	LHOM			; SET CURSOR HOME
	MOV.B	#ZLCDSZ*2-1,R5		;
	BSR	LCDF_3			; CLEAR DISPLAY ALL
	BRA	LHOM			;
					;
LCDF_1:	MOV.B	@LCDPC:8,R0		; GET CURSOR POSITION
	TST.W	FP			;
	BEQ	LCDF_2			; BR IF BUFFER MODE
	MOV.B	@(YLCDPC,FP),R0		; GET CURSOR POSITION
LCDF_2:	BCLR.B	#QLCDD,R0		; CLEAR DD RAM BIT
	MOV.B	#ZLCDSZ*2-1,R5		;
	SUB.B	R0,R5			; CALCULATE SPACE COUNT
	BCS	LCDF_5			; BR IF NO ROOM FOR SPACE
LCDF_3:	EXTU	R5			;
LCDF_4:	MOV.B	#" ",R2			;
	BSR	LDAT			; DISPLAY SPACE
	SCB/F	R5,LCDF_4		;
LCDF_5:	RTS				;
	.PAGE
;
;	OUTPUT INSTRUCTION/DATA TO LCD
;
;	IN	R2 : INSTRUCTION DATA
;		FP : LCD BUFFER POINTER
;
;	OUT	FP : NOT CHANGED
;
LMOD:	TST.W	FP			;
	BEQ	LOPI			; BR IF DIRECT OUTPUT MODE
	MOV.B	R2,@(YLCDMD,FP)		; SAVE LCD MODE
	CMP.W	@LCDBP:8,FP		;
	BEQ	LOPI			; BR IF CURRENT BUFFER
	RTS				;

LHOM:	MOV.B	#ZLPOS,R2		; SET HOME POSITION
LPOS:	TST.W	FP			;
	BEQ	LPOS1			; BR IF DIRECT OUTPUT MODE
	MOV.B	R2,@(YLCDPC,FP)		; SAVE CURSOR POSITION
	CMP.W	@LCDBP:8,FP		;
	BNE	LDAT_1			; BR IF NOT CURRENT BUFFER
LPOS1:	MOV.B	R2,@LCDPC:8		; SET CURSOR POSITION
	CMP.B	#ZLPOS+ZLCDSZ,R2	;
	BCS	LOPI			; BR IF 1ST LINE
LPOS_1:	ADD.B	#64-ZLCDSZ,R2		; CALCULATE 2ND LINE ADDRESS
LOPI:	BSR	LRDY			; WAIT UNTIL LCD READY
	CLR.B	@SWPDBC			; SET INSTRUCTION OUTPUT MODE
	BRA	LOPD_1			; OUTPUT INSTRUCTION

LDAT:	TST.W	FP			;
	BEQ	LDAT1			; BR IF DIRECT OUTPUT MODE
	CLR.W	R0			;
	MOV.B	@(YLCDPC,FP),R0		; GET CURSOR POSITION
	BCLR.B	#QLCDD,R0		;
	CMP.B	#ZLCDSZ*2,R0		;
	BCC	LDAT_1			; BR IF OVER LCD DISPLAY SIZE
	ADD.W	FP,R0			;
	MOV.B	R2,@R0			; SAVE DISPLAY DATA
	ADD.B	#1,@(YLCDPC,FP)		; UPDATE CURSOR POSITION
	CMP.W	@LCDBP:8,FP		;
	BNE	LDAT_1			; BR IF NOT CURRENT BUFFER
LDAT1:	BSR	LOPD			; DISPALY DATA
	ADD.B	#1,@LCDPC:8		; UPDATE CURSOR POSITION
	MOV.B	#ZLPOS+ZLCDSZ,R2	; SET 2ND LINE START POSITION
	CMP.B	@LCDPC:8,R2		;
	BEQ	LPOS_1			; BR IF 1ST LINE END
LDAT_1:	RTS				;
	.PAGE
;
;	OUTPUT LCD DATA
;
;	IN	R2 : LCD OUTPUT DATA
;
;	OUT	NONE
;
LOPD:	BSR	LRDY			; WAIT UNTIL LCD READY
LOPD_1:	BSET.B	#QLCDE,@SWPDBC		; SET E=HIGH
	MOV.B	R2,@SWPDBB		; OUTPUT LCD DATA
	BCLR.B	#QLCDE,@SWPDBC		; SET E=LOW
	RTS

;
;	WAIT UNTIL LCD READY
;
;	IN	NONE
;
;	OUT	NONE
;
LRDY:	MOV.B	#ZRDMD,@SWPCNT		; SET READ MODE
	MOV.B	#XLCDRW,@SWPDBC		; SET RS=LOW, R/W=HIGH, E=LOW
LRDY_1:	NOP				;
	BSET.B	#QLCDE,@SWPDBC		; SET E=HIGH
	TST.B	@SWPDBB			; READ LCD STATUS
	BCLR.B	#QLCDE,@SWPDBC		; SET E=LOW
	BMI	LRDY_1			; BR IF LCD BUSY
	MOV.B	#ZWRMD,@SWPCNT		; SET WRITE MODE
	MOV.B	#XLCDRS,@SWPDBC		; SET RS=HIGH, R/W=LOW, E=LOW
	RTS				;
	.PAGE
;
;	DISPLAY HEX CHARACTER
;
;	IN	R3 : VALUE
;		FP : LCD BUFFER POINTER
;
;	OUT	NONE
;
LCDHX4:	SWAP	R3			;
	BSR	LCDHX2			; DISPLAY 4TH, 3RD DIGIT
	BRA	LCDH_1			;
					;
LCDHX3:	SWAP	R3			;
	BSR	LCDHX1			; DISPLAY 3RD DIGIT
LCDH_1:	SWAP	R3			;
LCDHX2:	MOV.B	R3,R2			;
	SHLR.B	R2			; GET HIGH NIBBLE
	SHLR.B	R2			;
	SHLR.B	R2			;
	SHLR.B	R2			;
	BSR	LCDH_2			; DISPLAY HIGH NIBBLE
LCDHX1:	MOV.B	R3,R2			;
	AND.B	#H'0F,R2		; GET LOW NIBBLE
LCDH_2:	CMP.B	#10,R2			;
	BCS	LCDH_3			; BR IF CHARACTER < 10
	ADD.B	#7,R2			;
LCDH_3:	ADD.B	#"0",R2			; CONVERT TO ASCII HEX CHARACTER
	BRA	LDAT			; DISPLAY DATA
	.PAGE
;
;	DISPLAY DECIMAL CHARACTER
;
;	IN	R3 : VALUE
;		R4 : DIGIT SIZE
;		FP : LCD BUFFER POINTER
;
;	OUT	NONE
;
LCDDE0:	MOV.B	#"0",R1			; SET LEADING CHARACTER
	BRA	LCDD

LCDDEC:	MOV.B	#" ",R1			; SET LEADING CHARACTER
LCDD:	XCH	R4,R3			;
	MOV.B	#5,R0			;
	MOV.W	#10000,R2		;
	BSR	LCDD_3			; DISPLAY 10000'S DIGIT
	MOV.B	#4,R0			;
	MOV.W	#1000,R2		;
	BSR	LCDD_3			; DISPLAY 1000'S DIGIT
	MOV.B	#3,R0			;
	MOV.W	#100,R2			;
	BSR	LCDD_3			; DISPLAY 100'S DIGIT
	MOV.B	#2,R0			;
	MOV.W	#10,R2			;
	BSR	LCDD_3			; DISPLAY 10'S DIGIT
	MOV.B	#1,R0			;
	MOV.W	R4,R5			;
	BRA	LCDD_4			; DISPLAY 1'S DIGIT
					;
LCDD_3:	MOV.W	R4,R5			;
	CLR.W	R4			;
	DIVXU.W	R2,R4			;
	TST.B	R5			;
	BEQ	LCDD_5			; BR IF ZERO
LCDD_4:	MOV.B	#"0",R1			;
LCDD_5:	MOV.B	R5,R2			;
	ADD.B	R1,R2			;
	CMP.B	R0,R3			;
	BCC	LDAT			; BR IF DISPLAY DIGIT
	RTS				;
	.PAGE
;
;	BUZZER OFF
;
;	IN	NONE
;
;	OUT	NONE
;
BZOFF:	MOV.W	#BUZT,FP		; GET BUZZER TIMER POINTER
	BCLR.B	#QOCIEA,@TCR2		; DISABLE INTPNL
BZOF_1:	BSET.B	#QBZON,@P7DR		; SET BUZZER OFF
	BCLR.B	#QBZOF,@PNLCF:8		; RESET STOP PANEL SW ON
	CLR.W	R2			; ADJUST FOR BUZZER ON START
	MOV.W	R2,@(YBZT1,FP)		; RESET BUZZER ON TIMER
	MOV.W	R2,@(YBZT2,FP)		; RESET BUZZER OFF TIMER
	MOV.W	R2,@(YBZC,FP)		; RESET BUZZER ON/OFF COUNTER
	MOV.W	R2,@(YBZC,FP)		; RESET BUZZER ON/OFF COUNTER
	BSET.B	#QOCIEA,@TCR2		; ENABLE INTPNL
	RTS

;
;	STOP BUZZER INTERMITTENT ON
;
;	IN	R3 : BUZZER ON TIME
;		R4 : BUZZER OFF TIME
;
;	OUT	NONE
;
BZOFF1:	MOV.W	#BUZT,FP		; GET BUZZER TIMER POINTER
	BCLR.B	#QOCIEA,@TCR2		; DISABLE INTPNL
	MOV.W	@(YBZC,FP),R0		;
	BEQ	BZOF_2			; BR IF NOT BUZZER INTERMITTENT MODE
	CMP.W	@(YBZTS1,FP),R3		;
	BNE	BZOF_2			; BR IF NOT SAME ON TIME
	CMP.W	@(YBZTS2,FP),R4		;
	BEQ	BZOF_1			; BR IF SAME OFF TIME
BZOF_2:	BSET.B	#QOCIEA,@TCR2		; ENABLE INTPNL
	RTS
	.PAGE
;
;	BUZZER SINGLE SHOT ON		BZON1 : STOP BY PANEL SW ON
;					BZON2 : NOT STOP BY PANEL SW
;
;	IN	R2 : BUZZER ON TIME
;
;	OUT	NONE
;

BZON1:	BCLR.B	#QOCIEA,@TCR2		; DISABLE INTPNL
	BSET.B	#QBZOF,@PNLCF:8		; SET STOP BY PANEL SW ON
	BRA	BZON			;

BZON2:	BCLR.B	#QOCIEA,@TCR2		; DISABLE INTPNL
	BCLR.B	#QBZOF,@PNLCF:8		; RESET STOP BY PANEL SW ON
BZON:	MOV.W	#BUZT,FP		; GET BUZZER TIMER POINTER
	BSET.B	#QBZON,@P7DR		; STOP PREVIOUS BUZZER ON
BZON_1:	ADD.W	#1,R2			; ADJUST FOR BUZZER ON START
	BCC	BZON_2			; BR IF NOT OVERFLOW
	MOV.W	#ZNN,R2			;
BZON_2:	MOV.W	R2,@FP			; SET BUZZER ON TIME
	CLR.W	R0			;
	MOV.W	R0,@(YBZT2,FP)		; RESET BUZZER OFF TIMER
	MOV.W	R0,@(YBZC,FP)		; RESET BUZZER ON/OFF COUNTER
	BSET.B	#QOCIEA,@TCR2		; ENABLE INTPNL
BZON_3:	RTS				;
	.PAGE
;
;	BUZZER CONTINUOUS ON		BZCON1 : STOP BY PANEL SW ON
;					BZCON2 : NOT STOP BY PANEL SW
;
;	IN	R2 : BUZZER ON TIME
;
;	OUT	NONE
;

BZCON1:	BCLR.B	#QOCIEA,@TCR2		; DISABLE INTPNL
	BSET.B	#QBZOF,@PNLCF:8		; SET STOP BY PANEL SW ON
	BRA	BZCON			;

BZCON2:	BCLR.B	#QOCIEA,@TCR2		; DISABLE INTPNL
	BCLR.B	#QBZOF,@PNLCF:8		; RESET STOP BY PANEL SW ON
BZCON:	MOV.W	R2,R3			;
	MOV.W	#BUZT,FP		; GET BUZZER TIMER POINTER
BZCO_1:	BCLR.B	#QOCIEA,@TCR2		; DISABLE INTPNL
	MOV.W	@FP,R0			;
	BEQ	BZON_1			; BR IF BUZZER ON START
	MOV.W	R0,R2			;
	ADD.W	R3,R2			; SET BUZZER ON CONTINUE
	BCC	BZON_2			; BR IF NOT OVERFLOW
	BSET.B	#QOCIEA,@TCR2		; ENABLE INTPNL
BZCO_2:	BTST.B	#QDALM,@PSWDF:8		;
	BNE	BZON_3			; BR IF ALARM ERROR MODE
	MOV.W	@FP,R2			;
	BEQ	BZON_3			; BR IF BUZZER CANCEL
	ADD.W	R3,R2			;
	BCC	BZCO_1			; BR IF NOT OVERFLOW
	BRA	BZCO_2			;
	.PAGE
;
;	BUZZER INTERMITTENT ON		BZINT1 : STOP BY PANEL SW ON
;					BZINT2 : NOT STOP BY PANEL SW ON
;
;	IN	R2 : 1ST BUZZER ON TIME
;		R3 : BUZZER ON TIME
;		R4 : BUZZER OFF TIME
;		R5 : COUNTER
;
;	OUT	NONE
;
BZINT1:	BCLR.B	#QOCIEA,@TCR2		; DISABLE INTPNL
	BSET.B	#QBZOF,@PNLCF:8		; SET STOP BY PANEL SW ON
	BRA	BZINT			;

BZINT2:	BCLR.B	#QOCIEA,@TCR2		; DISABLE INTPNL
	BCLR.B	#QBZOF,@PNLCF:8		; RESET STOP BY PANEL SW ON
BZINT:	MOV.W	#BUZT,FP		; GET BUZZER TIMER POINTER
	MOV.W	@(YBZC,FP),R0		;
	BEQ	BZIN_2			; BR IF NOT BUZZER INTERMITTENT MODE
	CMP.W	@(YBZTS1,FP),R3		;
	BNE	BZIN_1			; BR IF NOT SAME ON TIME
	CMP.W	@(YBZTS2,FP),R4		;
	BEQ	BZIN_3			; BR IF SAME OFF TIME
BZIN_1:	BSET.B	#QBZON,@P7DR		; SET BUZZER OFF
BZIN_2:	ADD.W	#1,R2			; ADJUST FOR BUZZER ON START
	MOV.W	R2,@FP			; SET 1ST BUZZER ON TIME
	CLR.W	@(YBZT2,FP)		; RESET BUZZER OFF TIMER
	MOV.W	R3,@(YBZTS1,FP)		; SET BUZZER ON TIME
	MOV.W	R4,@(YBZTS2,FP)		; SET BUZZER OFF TIME
BZIN_3:	MOV.W	R5,@(YBZC,FP)		; SET BUZZER ON/OFF COUNT
	BSET.B	#QOCIEA,@TCR2		; ENABLE INTPNL
	RTS				;
	.PAGE
;
;	SET LED ON
;
;	IN	R2 : LED STATUS
;
;	OUT	NONE
;
LEDOFF:	LDC.W	#XI2+XI1+XI0,SR		; DISABLE INETRRUPT
	OR.B	@LEDF:8,R2		; OR LED STATUS
	LDC.W	#0,SR			; ENABLE INETRRUPT
	MOV.B	R2,@LEDF:8		;
	RTS				;

;
;	SET LED OFF
;
;	IN	R2 : LED STATUS
;
;	OUT	NONE
;
LEDON:	LDC.W	#XI2+XI1+XI0,SR		; DISABLE INETRRUPT
	NOT.B	R2			;
	AND.B	@LEDF:8,R2		; AND LED STATUS
	LDC.W	#0,SR			; ENABLE INETRRUPT
	MOV.B	R2,@LEDF:8		;
	RTS				;

;
;	CHNAGE LED ON/OFF
;
;	IN	R2 : LED STATUS
;
;	OUT	NONE
;

LEDXOR:	LDC.W	#XI2+XI1+XI0,SR		; DISABLE INETRRUPT
	XOR.B	@LEDF:8,R2		; XOR LED STATUS
	LDC.W	#0,SR			; ENABLE INETRRUPT
;	MOV.B	R2,@LEDF:8		; SET LED STATUS
;	RTS				;

;
;	SET LED STATUS
;
;	IN	R2 : LED STATUS
;
;	OUT	NONE
;
LEDSET:	MOV.B	R2,@LEDF:8		; SET LED STATUS
	RTS				;
	.PAGE
;
;	SET LED BLINK STATUS
;
;	IN	R2 : LED BLINK STATUS
;		R3 : LED BLINK INTERVAL
;		R5 : LED BLINK TIMER NO.
;
;	OUT	NONE
;
LEDBLS:	CMP.B	#ZLEDTC,R5		;
	BCC	LEDB_2			; BR IF INVALID TIMER NO.
	MULXU.B	#YLEDSZ,R5		;
	MOV.W	R5,FP			;
	ADD.W	#LEDT,FP		; GET BLINK TIMER POINTER
	BCLR.B	#QOCIEA,@TCR2		; DISABLE INTPNL
	MOV.B	R2,@(YLEDS,FP)		; SET LED BLINK STATUS
	MOV.B	R3,@(YLEDTS,FP)		; SET BLINK INTERVAL TIME
	MOV.B	@(YLEDT,FP),R0		;
	BNE	LEDB_1			; BR IF ALREADY BLINK START
	ADD.B	#1,@FP			; START LED BLINK TIMER
LEDB_1:	BSET.B	#QOCIEA,@TCR2		; ENABLE INTPNL
LEDB_2:	RTS				;

;
;	CLEAR LED BLINK STATUS
;
;	IN	R5 : LED BLINK TIMER NO.
;
;	OUT	NONE
;
LEDBLC:	CMP.B	#ZLEDTC,R5		;
	BCC	LEDB_2			; BR IF INVALID TIMER NO.
	MULXU.B	#YLEDSZ,R5		;
	MOV.W	R5,FP			;
	ADD.W	#LEDT,FP		; GET BLINK TIMER POINTER
	CLR.B	@FP			; STOP LED BLINK TIMER
	RTS				;
	.END
