	.PROGRAM	aplimg
	.HEADING	"M4324 AX IMAGE DATA SEQUENSE MODULE"
	.LIST		NOEXP,NOCOND,NOCODE
;********************************************************
;							*
;	M4324 AX IMAGE DATA SEQUENCE MODULE		*
;							*
;	FILE NAME	AX_IMG.MAR			*
;	CREATED 	08/MAY/1991			*
;********************************************************
;
	.EXPORT 	GETIBP,REIMG, DODIG, HDDIG, SETIPG
	.EXPORT 	SIDIG, SLIMG, QUAIG, UPIG2
	.EXPORT 	RMVIMG,ST10S
	.EXPORT 	I_IMG1,I_IMG2			; 911113
;
	.IMPORT 	DP1INT,DP1IMG,GETC,  GETI24,GETI8
	.IMPORT 	INBFC, INBFP, LFCD1, UPTBFP,STPVF
	.IMPORT 	STLSM, STPRNT,CKTXTB,STCOMN,SETPR1
	.IMPORT 	IMGTB1,CHKJST
;
	.INCLUDE	"AX_BUF.H"
	.INCLUDE	"AX_DP2.H"
	.INCLUDE	"AX_RAM.H"
	.INCLUDE	"AX_TBF.H"
	.INCLUDE	"COMMON.H"
;
;	<< EACH CONSTANT >>
;
QKNJHS: .EQU	  7			; KANJI HIGH SPEED MODE BIT
QSPDFX: .EQU	  6			; SPEED FIXED FLAG
	.PAGE
	.SECTION	APL2,CODE,ALIGN=16
;
;	ESC + * + m + n1 + n2 + d1+....+dK
;
;	SELECT IMAGE MODE
;
SLIMG:	JSR	@GETC			; GET DATA (m)
	MOV.B	R0,R3			; SAVE (m)
SLIMG2: CMP.B	#H'08,R3                ;
	BLS	SLIM_2			; BR. IF H'00->H'08
	SUB.B	#H'20,R3                ; MAKE 24 PIN TABLE OFFSET
	CMP.B	#H'08,R3                ;
	BHI	RDDM_8			; BR. IF H'28 < (m) (INVALID)
	MOV.B	R3,R4			; SAVE OFFSET
	MULXU.B #3,R4			; (m) x 3 = TABLE OFFSET
	MOV.B	R3,R5			;
	EXTU	R5			;
	LDC.B	#PAGE CKIMT1,EP 	; SET CHECK TABLE PAGE
	TST.B	@(CKIMT2:16,R5) 	;
	BEQ	RDDM_8			; BR IF IGNORE DATA
	BSR	RCVLNG			; GET DATA LENGTH (= @DATLNS)
	BEQ	RDDM_8			; BR. IF LENGTH = 0
	BTST.B	#QBCDPR,@PRPTCF:8	;
	BNE	RDDM24			; BR. IF BAR CODE MODE
	JMP	@(IMTB2:16,R4)		; EACH 24 PIN IMAGE MODE
;
;	<< 8 PIN IMAGE >>
;
SLIM_2: MOV.B	R3,R4			; SAVE OFFSET
	MULXU.B #3,R4			; (m) x 3 = TABLE OFFSET
	MOV.B	R3,R5			;
	EXTU	R5			;
	LDC.B	#PAGE CKIMT1,EP 	; SET CHECK TABLE PAGE
	TST.B	@(CKIMT1:16,R5) 	;
	BEQ	RDDM_8			; BR IF IGNORE DATA
	BSR	RCVLNG			; GET DATA LENGTH (= @DATLNS)
	BEQ	RDDM_8			; BR. IF LENGTH = 0
	BTST.B	#QBCDPR,@PRPTCF:8	;
	BNE	RDDM8			; BR. IF BAR CODE MODE
	JMP	@(IMTB1:16,R4)		; EACH 8 PIN IMAGE MODE
;
;	<< IMAGE 24 PIN IGNORE DATA FOR BAR CODE MODE >>
;
RDDM24: JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
	MOV.W	@DATLNS:8,R3		; GET RECEIVE LENGTH
	ADD.W	#-1,R3			;
RDDM_2: JSR	@GETI24 		; GET IMAGE DATA (= 3 byte)
	SCB/F	R3,RDDM_2		; BR. IF NOT END
	BRA	RDDM_6
;
;	<< IMAGE 8 PIN IGNORE DATA FOR BAR CODE MODE >>
;
RDDM8:	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
	MOV.W	@DATLNS:8,R3		; GET RECEIVE LENGTH
	ADD.W	#-1,R3			;
RDDM_4: JSR	@GETI8			; GET IMAGE DATA (= 1 byte)
	SCB/F	R3,RDDM_4		; BR. IF NOT END
RDDM_6: JSR	@DP1INT 		; GET INPUT DATA IS INTERRUPT
RDDM_8: RTS
	.PAGE
;
; << SUB >>	RECEIVE PARAMETER LENGTH
;
;	OUT	DATLNS : PARAMETER LENGTH
;		ZERO BIT->ON : PARAMETER LENGTH = 0
;
;	USE	R0,R2
;
RCVLNG: JSR	@GETC			; GET DATA (n1)
	MOV.B	R0,R2			; SAVE DATA (n1)
	JSR	@GETC			; GET DATA (n2)
	AND.B	#H'1F,R0                ; MASK EXCEPT HIGH 3 BITS
	SWAP	R0			;
	MOV.B	R2,R0			; DATA (n1) = LOW/(n2) = HIGH
	MOV.W	R0,@DATLNS:8		; SAVE PARAMETER LENGTH
	RTS
;
;	<< IMAGE JUMP TABLE >>
;
IMTB1:	BRA	IG60E:16		; 0:SINGLE-DENSITY		<  8 pin >
	BRA	IG12E:16		; 1:DOUBLE-DENSITY		<  8 pin >
	BRA	IG12HE:16		; 2:HIGH-SPEED DOUBLE-DENSITY	<  8 pin >
	BRA	IG24E:16		; 3:QUADRUPLE DENSITY		<  8 pin >
	BRA	IG80E:16		; 4:CRT-1			<  8 pin >
	BRA	RDDM_8:16		; 5:CRT-1			<  8 pin >
	BRA	IG90E:16		; 6:CRT-2			<  8 pin >
	BRA	RDDM_8:16		; 7:NO DEFINED			<  8 pin >
	BRA	RDDM_8:16		; 8:NO DEFINED			<  8 pin >
	;
IMTB2:	BRA	IG60T:16		; 32:SINGLE-DENSITY		< 24 pin >
	BRA	IG12T:16		; 33:DOUBLE-DENSITY		< 24 pin >
	BRA	RDDM_8:16		; 34:HIGH-SPEED DOUBLE-DENSITY	< 24 pin >
	BRA	RDDM_8:16		; 35:QUADRUPLE DENSITY		< 24 pin >
	BRA	RDDM_8:16		; 36:CRT-1			< 24 pin >
	BRA	RDDM_8:16		; 37:CRT-1			< 24 pin >
	BRA	IG90T:16		; 38:CRT-2			< 24 pin >
	BRA	IG18T:16		; 39:TRIPLE-DENSITY		< 24 pin >
	BRA	IG36T:16		; 40:HEX-DENSITY		< 24 pin >
;
;	<< CHECK VALID IMAGE TABLE >>
;
;	.DATA.B    1 ... VALID
;
;		H'00+H'01+H'02+H'03+H'04+H'05+H'06+H'07+H'08
CKIMT1: .DATA.B    1,	1,   1,   1,   1,   0,	 1,   0,   0	;  8 PIN
;		H'20+H'21+H'22+H'23+H'24+H'25+H'26+H'27+H'28
CKIMT2: .DATA.B    1,	1,   0,   0,   0,   0,	 1,   1,   1	; 24 PIN
	.PAGE
;
;	ESC + ? + (n) + (m)
;
;	REASSIGN IMAGE MODE
;
REIMG:	JSR	@GETC			; GET DATA (n)
	MOV.B	R0,R3			; SAVE (n)
	JSR	@GETC			; GET DATA (m)
	MOV.B	R0,R2			; SAVE (m)
	LDC.B	#PAGE CKIMT1,EP 	; SET CHECK TABLE PAGE
	MOV.W	#CKIMT1,R5		; SET CHECK TABLE POINTER (8 PIN)
	CMP.B	#H'08,R0                ;
	BLS	REIM_2			; BR. IF 8 PIN IMAGE
	MOV.W	#CKIMT2,R5		; SET CHECK TABLE POINTER (24 PIN)
	SUB.B	#H'20,R0                ; SET 24 PIN IMAGE OFFSET
	CMP.B	#H'08,R0                ;
	BHI	REIM_8			; BR. IF ERROR CODE (INVALID)
REIM_2: EXTU	R0			;
	ADD.W	R0,R5			; TABLE BASE + OFFSET
	TST.B	@R5			;
	BEQ	REIM_8			; BR. IF ERROR CODE (INVALID)
	CLR.W	R0			; SET ESC + K SAVE AREA OFFSET
	CMP.B	#"K",R3                 ;
	BEQ	REIM_4			; BR. IF (n) = "K"
	ADD.W	#1,R0			; UPDATE OFFSET
	CMP.B	#"L",R3                 ;
	BEQ	REIM_4			; BR. IF (n) = "L"
	ADD.W	#1,R0			; UPDATE OFFSET
	CMP.B	#"Y",R3                 ;
	BEQ	REIM_4			; BR. IF (n) = "Y"
	ADD.W	#1,R0			; UPDATE OFFSET
	CMP.B	#"Z",R3                 ;
	BNE	REIM_8			; BR. IF NOT (n) = "Z"
REIM_4: MOV.B	R2,@(ESCKES,R0) 	; SET CHANGE IMAGE MODE
REIM_8: RTS
	.PAGE
;
;	ESC + K + n1 + n2 + d1+.....+dk
;
;	SINGLE-DENSITY IMAGE MODE
;
SIDIG:	MOV.B	@ESCKES:8,R3		; SET < ESC + K > ENTRY
	BRA	SLIMG2
;
;	ESC + L + n1 + n2 + d1+.....+dk
;
;	DOUBLE-DENSITY IMAGE MODE
;
DODIG:	MOV.B	@ESCLES:8,R3		; SET < ESC + L > ENTRY
	BRA	SLIMG2
;
;	ESC + Y + n1 + n2 + d1+.....+dk
;
;	HIGH-SPEED DOUBLE-DENSITY IMAGE MODE
;
HDDIG:	MOV.B	@ESCYES:8,R3		; SET < ESC + Y > ENTRY
	BRA	SLIMG2
;
;	ESC + Z + n1 + n2 + d1+.....+dk
;
;	QUADRUPLE-DENSITY IMAGE MODE
;
QUAIG:	MOV.B	@ESCZES:8,R3		; SET < ESC + Z > ENTRY
	BRA	SLIMG2
	.PAGE
;
;	<< 1/60-INCH PITCH IMAGE ( x 3.0) >>		<< 8 pin >>
;
IG60E:	MOV.W	#ZCL60,R1		; SET 1/60-INCH COLUMN
	MOV.W	#ZPTC12,R2		; SET 1/120-INCH FLAG
	BCLR.B	#QIMG24,@APL1F:8	; SET IMAGE 8 PIN FLAG
	BSR	ICHSL:16		; CHECK IMAGE DATA LENGTH
	MOV.W	#03*2,R1		; SET 1 COLUMN LENGTH
	BSR	ST30S:16		; SET SPEED (FIXED -> SUPER SPEED)
	BSR	UPIG2:16		; UPDATE IMAGE BUFFER POINTER
	BTST.B	#QJSTPR,@APL2F:8	; CHECK COLUMN POSITION
	BEQ	SV08P1:16		; BR. IF CURRENT POSITION = MAX COLUMN POSITION
	MOV.W	R3,@-SP 		;+ SAVE IGNORE LENGTH
	MOV.W	R4,@-SP 		;+ SAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@DATLNS:8,R3		; GET LOOP COUNTER
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
	MOV.W	#IMGTB1,FP		; SET IMAGE DATA CHANGE TABLE 1 POINTER
IG60_E: JSR	@GETI8			; GET IMAGE DATA
	MOV.B	R0,R2			;
	MOV.B	@R2,R0			;
	MOV.B	R0,FP			; SAVE 1ST BYTE DATA
	MOV.B	@(0,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4+ 		; SAVE 1->8 PIN DATA
	MOV.B	@(256,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4+ 		; SAVE 9->16 PIN DATA
	MOV.B	@(256*2,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4			; SAVE 17->24 PIN DATA
	ADDS.B	#3+1,R4 		; UPDATE POINTER
	SCB/F	R3,IG60_E		; BR. IF NOT END
	MOV.W	@SP+,R4 		;+ UNSAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@SP+,R3 		;+ UNSAVE IGNORE LENGTH
	BRA	SVIMG2:16		; READ IGNORE DATA & IMAGE PRINT
	.PAGE
;
;	<< 1/120-INCH PITCH IMAGE ( x 1.5) >>		<< 8 pin >>
;
IG12E:	MOV.W	#ZCL120,R1		; SET 1/120-INCH COLUMN
	MOV.W	#ZPTC24,R2		; SET 1/240-INCH FLAG
	BCLR.B	#QIMG24,@APL1F:8	; SET IMAGE 8 PIN FLAG
	BSR	ICHSL:16		; CHECK IMAGE DATA LENGTH
	MOV.W	#03*2,R1		; SET 1 COLUMN LENGTH
	BSR	ST15S:16		; SET SPEED (FIXED -> MIDDLE SPEED)
	BSR	UPIG2:16		; UPDATE IMAGE BUFFER POINTER
	BTST.B	#QJSTPR,@APL2F:8	; CHECK COLUMN POSITION
	BEQ	SV08P1:16		; BR. IF CURRENT POSITION = MAX COLUMN POSITION
	MOV.W	R3,@-SP 		;+ SAVE IGNORE LENGTH
	MOV.W	R4,@-SP 		;+ SAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@DATLNS:8,R3		; GET LOOP COUNTER
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
	MOV.W	#IMGTB1,FP		; SET IMAGE DATA CHANGE TABLE 1 POINTER
IG12_E: JSR	@GETI8			; GET IMAGE DATA
	MOV.B	R0,R2			;
	MOV.B	@R2,R0			;
	MOV.B	R0,FP			; SAVE 1ST BYTE DATA
	MOV.B	@(0,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4+ 		; SAVE 1->8 PIN DATA
	MOV.B	@(256,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4+ 		; SAVE 9->16 PIN DATA
	MOV.B	@(256*2,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4			; SAVE 17->24 PIN DATA
	ADDS.B	#3+1,R4 		; UPDATE POINTER
	SCB/F	R3,IG12_E		; BR. IF NOT END
	MOV.W	@SP+,R4 		;+ UNSAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@SP+,R3 		;+ UNSAVE IGNORE LENGTH
	BRA	SVIMG2:16		; READ IGNORE DATA & IMAGE PRINT
	.PAGE
;
;	<< 1/120-INCH PITCH IMAGE (HIGH SEED) ( x 3.0) >>	<< 8 pin >>
;
IG12HE: MOV.W	#ZCL120,R1		; SET 1/120-INCH COLUMN
	MOV.W	#ZPTC12,R2		; SET 1/120-INCH FLAG
	BCLR.B	#QIMG24,@APL1F:8	; SET IMAGE 8 PIN FLAG
	BSR	ICHSL:16		; CHECK IMAGE DATA LENGTH
	MOV.W	#03,R1			; SET 1 COLUMN LENGTH
	BSR	ST30S:16		; SET SPEED (FIXED -> SUPER SPEED)
	BSR	UPIG2:16		; UPDATE IMAGE BUFFER POINTER
	BTST.B	#QJSTPR,@APL2F:8	; CHECK COLUMN POSITION
	BEQ	SV08P0:16		; BR. IF CURRENT POSITION = MAX COLUMN POSITION
	MOV.W	R3,@-SP 		;+ SAVE IGNORE LENGTH
	MOV.W	R4,@-SP 		;+ SAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@DATLNS:8,R3		; GET LOOP COUNTER
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
	MOV.W	#IMGTB1,FP		; SET IMAGE DATA CHANGE TABLE 1 POINTER
IG12_H: JSR	@GETI8			; GET IMAGE DATA
	MOV.B	R0,R2			;
	MOV.B	@R2,R0			;
	MOV.B	R0,FP			; SAVE 1ST BYTE DATA
	MOV.B	@(0,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4+ 		; SAVE 1->8 PIN DATA
	MOV.B	@(256,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4+ 		; SAVE 9->16 PIN DATA
	MOV.B	@(256*2,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4+ 		; SAVE 17->24 PIN DATA
	SCB/F	R3,IG12_H		; BR. IF NOT END
	MOV.W	@SP+,R4 		;+ UNSAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@SP+,R3 		;+ UNSAVE IGNORE LENGTH
	BRA	SVIMG2:16		; READ IGNORE DATA & IMAGE PRINT
	.PAGE
;
;	<< 1/240-INCH PITCH IMAGE ( x 1.5) >>		<< 8 pin >>
;
IG24E:	MOV.W	#ZCL240,R1		; SET 1/240-INCH COLUMN
	MOV.W	#ZPTC24,R2		; SET 1/240-INCH FLAG
	BCLR.B	#QIMG24,@APL1F:8	; SET IMAGE 8 PIN FLAG
	BSR	ICHSL:16		; CHECK IMAGE DATA LENGTH
	MOV.W	#03,R1			; SET 1 COLUMN LENGTH
	BSR	ST15S:16		; SET SPEED (FIXED -> MIDDLE SPEED)
	BSR	UPIG2:16		; UPDATE IMAGE BUFFER POINTER
	BTST.B	#QJSTPR,@APL2F:8	; CHECK COLUMN POSITION
	BEQ	SV08P0:16		; BR. IF CURRENT POSITION = MAX COLUMN POSITION
	MOV.W	R3,@-SP 		;+ SAVE IGNORE LENGTH
	MOV.W	R4,@-SP 		;+ SAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@DATLNS:8,R3		; GET LOOP COUNTER
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
	MOV.W	#IMGTB1,FP		; SET IMAGE DATA CHANGE TABLE 1 POINTER
IG24_E: JSR	@GETI8			; GET IMAGE DATA
	MOV.B	R0,R2			;
	MOV.B	@R2,R0			;
	MOV.B	R0,FP			; SAVE 1ST BYTE DATA
	MOV.B	@(0,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4+ 		; SAVE 1->8 PIN DATA
	MOV.B	@(256,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4+ 		; SAVE 9->16 PIN DATA
	MOV.B	@(256*2,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4+ 		; SAVE 17->24 PIN DATA
	SCB/F	R3,IG24_E		; BR. IF NOT END
	MOV.W	@SP+,R4 		;+ UNSAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@SP+,R3 		;+ UNSAVE IGNORE LENGTH
	BRA	SVIMG2:16		; READ IGNORE DATA & IMAGE PRINT
	.PAGE
;
;	<< 1/80-INCH PITCH IMAGE ( x 1.5) >>		<< 8 pin >>
;
IG80E:	MOV.W	#ZCL80,R1		; SET 1/80-INCH COLUMN
	MOV.W	#ZPTC24,R2		; SET 1/240-INCH FLAG (1/240" x 1/3)
	BCLR.B	#QIMG24,@APL1F:8	; SET IMAGE 8 PIN FLAG
	BSR	ICHSL:16		; CHECK IMAGE DATA LENGTH
	MOV.W	#03*3,R1		; SET 1 COLUMN LENGTH
	BSR	ST15S:16		; SET SPEED (FIXED -> MIDDLE SPEED)
	BSR	UPIG2:16		; UPDATE IMAGE BUFFER POINTER
	BTST.B	#QJSTPR,@APL2F:8	; CHECK COLUMN POSITION
	BEQ	SV08P2:16		; BR. IF CURRENT POSITION = MAX COLUMN POSITION
	MOV.W	R3,@-SP 		;+ SAVE IGNORE LENGTH
	MOV.W	R4,@-SP 		;+ SAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@DATLNS:8,R3		; GET LOOP COUNTER
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
	MOV.W	#IMGTB1,FP		; SET IMAGE DATA CHANGE TABLE 1 POINTER
IG80_E: JSR	@GETI8			; GET IMAGE DATA
	MOV.B	R0,R2			;
	MOV.B	@R2,R0			;
	MOV.B	R0,FP			; SAVE 1ST BYTE DATA
	MOV.B	@(0,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4+ 		; SAVE 1->8 PIN DATA
	MOV.B	@(256,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4+ 		; SAVE 9->16 PIN DATA
	MOV.B	@(256*2,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4			; SAVE 17->24 PIN DATA
	ADDS.B	#6+1,R4 		; UPDATE POINTER
	SCB/F	R3,IG80_E		; BR. IF NOT END
	MOV.W	@SP+,R4 		;+ UNSAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@SP+,R3 		;+ UNSAVE IGNORE LENGTH
	BRA	SVIMG2:16		; READ IGNORE DATA & IMAGE PRINT
	.PAGE
;
;	<< 1/90-INCH PITCH IMAGE ( x 2.0) >>		<< 8 pin >>
;
IG90E:	MOV.W	#ZCL90,R1		; SET 1/90-INCH COLUMN
	MOV.W	#ZPTC18,R2		; SET 1/180-INCH FLAG
	BCLR.B	#QIMG24,@APL1F:8	; SET IMAGE 8 PIN FLAG
	BSR	ICHSL:16		; CHECK IMAGE DATA LENGTH
	MOV.W	#03*2,R1		; SET 1 COLUMN LENGTH
	BSR	ST20S:16		; SET SPEED (FIXED -> HIGH SPEED)
	BSR	UPIG2:16		; UPDATE IMAGE BUFFER POINTER
	BTST.B	#QJSTPR,@APL2F:8	; CHECK COLUMN POSITION
	BEQ	SV08P1			; BR. IF CURRENT POSITION = MAX COLUMN POSITION
	MOV.W	R3,@-SP 		;+ SAVE IGNORE LENGTH
	MOV.W	R4,@-SP 		;+ SAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@DATLNS:8,R3		; GET LOOP COUNTER
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
	MOV.W	#IMGTB1,FP		; SET IMAGE DATA CHANGE TABLE 1 POINTER
IG90_E: JSR	@GETI8			; GET IMAGE DATA
	MOV.B	R0,R2			;
	MOV.B	@R2,R0			;
	MOV.B	R0,FP			; SAVE 1ST BYTE DATA
	MOV.B	@(0,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4+ 		; SAVE 1->8 PIN DATA
	MOV.B	@(256,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4+ 		; SAVE 9->16 PIN DATA
	MOV.B	@(256*2,FP),R5		; GET CHANGE DATA
	OR.B	@R4,R5			; OR WITH CHANGE DATA TO OLD DATA
	MOV.B	R5,@R4			; SAVE 17->24 PIN DATA
	ADDS.B	#3+1,R4 		; UPDATE POINTER
	SCB/F	R3,IG90_E		; BR. IF NOT END
	MOV.W	@SP+,R4 		;+ UNSAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@SP+,R3 		;+ UNSAVE IGNORE LENGTH
	BRA	SVIMG2:16		; READ IGNORE DATA & IMAGE PRINT
	.PAGE
;
; << SUB >>	SAVE 8 PIN IMAGE (CLMCTC = CLMMXS)
;
;	IN	    R3 : IGNORE COLUMN
;		 EP R4 : IMAGE BUFFER START POINTER
;		DATLNS : IMAGE PRINT COLUMN
;
SV08P0: MOV.W	#1,R5			; SET SKIP 0 COLUMN
	BRA	SV08_2
	;
SV08P1: MOV.W	#3+1,R5 		; SET SKIP 1 COLUMN VALUE
	BRA	SV08_2
	;
SV08P2: MOV.W	#3+3+1,R5		; SET SKIP 2 COLUMN VALUE
SV08_2: MOV.W	R3,@-SP 		;+ SAVE IGNORE LENGTH
	MOV.W	R4,@-SP 		;+ SAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@DATLNS:8,R3		; GET LOOP COUNTER
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
	MOV.W	#IMGTB1,FP		; SET IMAGE DATA CHANGE TABLE 1 POINTER
SV08_4: JSR	@GETI8			; GET IMAGE DATA
	MOV.B	R0,R2			;
	MOV.B	@R2,R0			;
	MOV.B	R0,FP			; SAVE 1ST BYTE DATA
	MOV.B	@(0,FP),R1		; CHANGE DATA WITH 1ST IMAGE DATA
	MOV.B	R1,@R4+ 		; SAVE 1->8 PIN DATA
	MOV.B	@(256,FP),R1		; CHANGE DATA WITH 2ND IMAGE DATA
	MOV.B	R1,@R4+ 		; SAVE 9->16 PIN DATA
	MOV.B	@(256*2,FP),R1		; CHANGE DATA WITH 3RD IMAGE DATA
	MOV.B	R1,@R4			; SAVE 17->24 PIN DATA
	ADDS.B	R5,R4			; UPDATE POINTER
	SCB/F	R3,SV08_4		; BR. IF NOT END
	MOV.W	@SP+,R4 		;+ UNSAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@SP+,R3 		;+ UNSAVE IGNORE LENGTH
	BRA	SVIMG2:16		; READ IGNORE DATA & IMAGE PRINT
	.PAGE
;
;	<< 1/60-INCH PITCH IMAGE ( x 3.0) >>		<< 24 pin >>
;
IG60T:	MOV.W	#ZCL60,R1		; SET 1/60-INCH COLUMN
	MOV.W	#ZPTC12,R2		; SET 1/120-INCH FLAG
	BSET.B	#QIMG24,@APL1F:8	; SET IMAGE 24 PIN FLAG
	BSR	ICHSL:16		; CHECK IMAGE DATA LENGTH
	MOV.W	#03*2,R1		; SET 1 COLUMN LENGTH
	BSR	ST30S:16		; SET SPEED (FIXED -> SUPER SPEED)
	BSR	UPIG2:16		; UPDATE IMAGE BUFFER POINTER
	BTST.B	#QJSTPR,@APL2F:8	; CHECK COLUMN POSITION
	BEQ	SV24P1:16		; BR. IF CURRENT POSITION = MAX COLUMN POSITION
	MOV.W	R3,@-SP 		;+ SAVE IGNORE LENGTH
	MOV.W	R4,@-SP 		;+ SAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@DATLNS:8,R3		; GET IMAGE SAVE DATA LENGTH
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
IG60_T: JSR	@GETI24 		; GET IMAGE DATA (= 3 byte)
	OR.B	@R4,R0			; OR WITH OLD DATA TO DATA
	MOV.B	R0,@R4+ 		; SET 1->8 PIN DATA
	SWAP	R0			; GET 2ND BYTE DATA
	OR.B	@R4,R0			; OR WITH OLD DATA TO DATA
	MOV.B	R0,@R4+ 		; SET 9->16 PIN DATA
	OR.B	@R4,R1			; OR WITH OLD DATA TO DATA
	MOV.B	R1,@R4			; SET 17->24 PIN DATA
	ADDS.B	#3+1,R4 		; UPDATE POINTER
	SCB/F	R3,IG60_T		; BR. IF NOT END
	MOV.W	@SP+,R4 		;+ UNSAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@SP+,R3 		;+ UNSAVE IGNORE LENGTH
	BRA	SVIMG3:16		; READ IGNORE DATA & IMAGE PRINT
	.PAGE
;
;	<< 1/120-INCH PITCH IMAGE ( x 1.5) >>		<< 24 pin >>
;
;
IG12T:	MOV.W	#ZCL120,R1		; SET 1/120-INCH COLUMN
	MOV.W	#ZPTC24,R2		; SET 1/240-INCH FLAG
	BSET.B	#QIMG24,@APL1F:8	; SET IMAGE 24 PIN FLAG
	BSR	ICHSL:16		; CHECK IMAGE DATA LENGTH
	MOV.W	#03*2,R1		; SET 1 COLUMN LENGTH
	BSR	ST15S:16		; SET SPEED (FIXED -> MIDDLE SPEED)
	BSR	UPIG2:16		; UPDATE IMAGE BUFFER POINTER
	BTST.B	#QJSTPR,@APL2F:8	; CHECK COLUMN POSITION
	BEQ	SV24P1:16		; BR. IF CURRENT POSITION = MAX COLUMN POSITION
	MOV.W	R3,@-SP 		;+ SAVE IGNORE LENGTH
	MOV.W	R4,@-SP 		;+ SAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@DATLNS:8,R3		; GET IMAGE SAVE DATA LENGTH
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
IG12_T: JSR	@GETI24 		; GET IMAGE DATA (= 3 byte)
	OR.B	@R4,R0			; OR WITH OLD DATA TO DATA
	MOV.B	R0,@R4+ 		; SET 1->8 PIN DATA
	SWAP	R0			; GET 2ND BYTE DATA
	OR.B	@R4,R0			; OR WITH OLD DATA TO DATA
	MOV.B	R0,@R4+ 		; SET 9->16 PIN DATA
	OR.B	@R4,R1			; OR WITH OLD DATA TO DATA
	MOV.B	R1,@R4			; SET 17->24 PIN DATA
	ADDS.B	#3+1,R4 		; UPDATE POINTER
	SCB/F	R3,IG12_T		; BR. IF NOT END
	MOV.W	@SP+,R4 		;+ UNSAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@SP+,R3 		;+ UNSAVE IGNORE LENGTH
	BRA	SVIMG3:16		; READ IGNORE DATA & IMAGE PRINT
	.PAGE
;
;	<< 1/90-INCH PITCH IMAGE ( x 2.0) >>		<< 24 pin >>
;
I_IMG2:
IG90T:	MOV.W	#ZCL90,R1		; SET 1/90-INCH COLUMN
	MOV.W	#ZPTC18,R2		; SET 1/180-INCH FLAG
	BSET.B	#QIMG24,@APL1F:8	; SET IMAGE 24 PIN FLAG
	BSR	ICHSL:16		; CHECK IMAGE DATA LENGTH
	MOV.W	#03*2,R1		; SET 1 COLUMN LENGTH
	BSR	ST20S:16		; SET SPEED (FIXED -> MIDDLE SPEED)
	BSR	UPIG2:16		; UPDATE IMAGE BUFFER POINTER
	BTST.B	#QJSTPR,@APL2F:8	; CHECK COLUMN POSITION
	BEQ	SV24P1:16		; BR. IF CURRENT POSITION = MAX COLUMN POSITION
	MOV.W	R3,@-SP 		;+ SAVE IGNORE LENGTH
	MOV.W	R4,@-SP 		;+ SAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@DATLNS:8,R3		; GET IMAGE SAVE DATA LENGTH
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
IG90_T: JSR	@GETI24 		; GET IMAGE DATA (= 3 byte)
	OR.B	@R4,R0			; OR WITH OLD DATA TO DATA
	MOV.B	R0,@R4+ 		; SET 1->8 PIN DATA
	SWAP	R0			; GET 2ND BYTE DATA
	OR.B	@R4,R0			; OR WITH OLD DATA TO DATA
	MOV.B	R0,@R4+ 		; SET 9->16 PIN DATA
	OR.B	@R4,R1			; OR WITH OLD DATA TO DATA
	MOV.B	R1,@R4			; SET 17->24 PIN DATA
	ADDS.B	#3+1,R4 		; UPDATE POINTER
	SCB/F	R3,IG90_T		; BR. IF NOT END
	MOV.W	@SP+,R4 		;+ UNSAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@SP+,R3 		;+ UNSAVE IGNORE LENGTH
	BRA	SVIMG3:16		; READ IGNORE DATA & IMAGE PRINT
	.PAGE
;
;	<< 1/180-INCH PITCH IMAGE ( x 1.0) >>		<< 24 pin >>
;
I_IMG1: 				; 911113
IG18T:	MOV.W	#ZCL180,R1		; SET 1/180-INCH COLUMN
	MOV.W	#ZPTC36,R2		; SET 1/360-INCH FLAG
	BSET.B	#QIMG24,@APL1F:8	; SET IMAGE 24 PIN FLAG
	BSR	ICHSL:16		; CHECK IMAGE DATA LENGTH
	MOV.W	#03*2,R1		; SET 1 COLUMN LENGTH
	BSR	ST10S:16		; SET PANEL SPEED
	BSR	UPIG2:16		; UPDATE IMAGE BUFFER POINTER
	BTST.B	#QJSTPR,@APL2F:8	; CHECK COLUMN POSITION
	BEQ	SV24P5:16		; BR. IF CURRENT POSITION = MAX COLUMN POSITION
	MOV.W	R3,@-SP 		;+ SAVE IGNORE LENGTH
	MOV.W	R4,@-SP 		;+ SAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@DATLNS:8,R3		; GET IMAGE SAVE DATA LENGTH
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
	MOV.B	@KJCDS1:8,R5		; GET SPEED/PITCH
	AND.B	#ZSPDMK,R5		; MASK SPEED FLAG
	CMP.B	#Z15SPD,R5		;
	BEQ	IG18_U			; BR. IF IMAGE MIDDLE SPEED
IG18_T: JSR	@GETI24 		; GET IMAGE DATA (= 3 byte)
	MOV.B	@R4,R5			; GET OLD DATA
	OR.B	R0,R5			; OR WITH OLD DATA TO DATA
	MOV.B	R5,@R4+ 		; SET 1->8 PIN DATA
	SWAP	R0			; GET 2ND BYTE DATA
	MOV.B	@R4,R5			; GET OLD DATA
	OR.B	R0,R5			; OR WITH OLD DATA TO DATA
	MOV.B	R5,@R4+ 		; SET 9->16 PIN DATA
	MOV.B	@R4,R5			; GET OLD DATA
	OR.B	R1,R5			; OR WITH OLD DATA TO DATA
	MOV.B	R5,@R4			; SET 17->24 PIN DATA
	ADDS.B	#4,R4			; UPDATE IMAGE BUFFER POINTER
	SCB/F	R3,IG18_T		; BR. IF NOT END
	MOV.W	@SP+,R4 		;+ UNSAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@SP+,R3 		;+ UNSAVE IGNORE LENGTH
	BRA	SVIMG3:16		; READ IGNORE DATA & IMAGE PRINT
;
;	<< IMAGE MIDDLE SPEED (SAME KANJI PITCH) >>
;
IG18_U: JSR	@GETI24 		; GET IMAGE DATA (= 3 byte)
	MOV.B	@R4,R5			; GET OLD DATA
	OR.B	R0,R5			; OR WITH OLD DATA TO DATA
	MOV.B	R5,@R4			; SET 1->8 PIN DATA
	SWAP	R0			; GET 2ND BYTE DATA
	MOV.B	@(1,R4),R5		; GET OLD DATA
	OR.B	R0,R5			; OR WITH OLD DATA TO DATA
	MOV.B	R5,@(1,R4)		; SET 9->16 PIN DATA
	MOV.B	@(2,R4),R5		; GET OLD DATA
	OR.B	R1,R5			; OR WITH OLD DATA TO DATA
	MOV.B	R5,@(2,R4)		; SET 17->24 PIN DATA (-> 1 Column END)
	ADDS.B	#3,R4			; UPDATE IMAGE BUFFER POINTER
	SWAP	R0			; GET 1ST BYTE DATA
	MOV.B	@R4,R5			; GET OLD DATA
	OR.B	R0,R5			; OR WITH OLD DATA TO DATA
	MOV.B	R5,@R4+ 		; SET 1->8 PIN DATA
	SWAP	R0			; GET 2ND BYTE DATA
	MOV.B	@R4,R5			; GET OLD DATA
	OR.B	R0,R5			; OR WITH OLD DATA TO DATA
	MOV.B	R5,@R4+ 		; SET 9->16 PIN DATA
	MOV.B	@R4,R5			; GET OLD DATA
	OR.B	R1,R5			; OR WITH OLD DATA TO DATA
	MOV.B	R5,@R4+ 		; SET 17->24 PIN DATA
	SCB/F	R3,IG18_U		; BR. IF NOT END
	MOV.W	@SP+,R4 		;+ UNSAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@SP+,R3 		;+ UNSAVE IGNORE LENGTH
	BRA	SVIMG3:16		; READ IGNORE DATA & IMAGE PRINT
	.PAGE
;
;	<< 1/360-INCH PITCH IMAGE ( x 1.0) >>		<< 24 pin >>
;
IG36T:	MOV.W	#ZCL360,R1		; SET 1/360-INCH COLUMN
	MOV.W	#ZPTC36,R2		; SET 1/360-INCH FLAG
	BSET.B	#QIMG24,@APL1F:8	; SET IMAGE 24 PIN FLAG
	BSR	ICHSL:16		; CHECK IMAGE DATA LENGTH
	MOV.W	#03,R1			; SET 1 COLUMN LENGTH
	BSR	ST10S:16		; SET PANEL SPEED
	BSR	UPIG2:16		; UPDATE IMAGE BUFFER POINTER
	BTST.B	#QJSTPR,@APL2F:8	; CHECK COLUMN POSITION
	BEQ	SV24P2			; BR. IF CURRENT POSITION = MAX COLUMN POSITION
	MOV.W	R3,@-SP 		;+ SAVE IGNORE LENGTH
	MOV.W	R4,@-SP 		;+ SAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@DATLNS:8,R3		; GET IMAGE SAVE DATA LENGTH
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
	MOV.B	@KJCDS1:8,R5		; GET SPEED/PITCH
	AND.B	#ZSPDMK,R5		; MASK SPEED FLAG
	CMP.B	#Z15SPD,R5		;
	BEQ	SV24_6			; BR. IF IMAGE MIDDLE SPEED
IG36_T: JSR	@GETI24 		; GET IMAGE DATA (= 3 byte)
	MOV.B	@R4,R5			; GET OLD DATA
	OR.B	R0,R5			; OR WITH OLD DATA TO DATA
	MOV.B	R5,@R4+ 		; SET 1->8 PIN DATA
	SWAP	R0			; GET 2ND BYTE DATA
	MOV.B	@R4,R5			; GET OLD DATA
	OR.B	R0,R5			; OR WITH OLD DATA TO DATA
	MOV.B	R5,@R4+ 		; SET 9->16 PIN DATA
	MOV.B	@R4,R5			; GET OLD DATA
	OR.B	R1,R5			; OR WITH OLD DATA TO DATA
	MOV.B	R5,@R4+ 		; SET 17->24 PIN DATA
	SCB/F	R3,IG36_T		; BR. IF NOT END
	MOV.W	@SP+,R4 		;+ UNSAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@SP+,R3 		;+ UNSAVE IGNORE LENGTH
	BRA	SVIMG3:16		; READ IGNORE DATA & IMAGE PRINT
	.PAGE
;
; << SUB >>	SAVE 24 PIN IMAGE (CLMCTC = CLMMXS)
;
;	IN	    R3 : IGNORE COLUMN
;		 EP R4 : IMAGE BUFFER START POINTER
;		DATLNS : IMAGE PRINT COLUMN
;
SV24P2: MOV.B	@KJCDS1:8,R5		; GET SPEED/PITCH
	AND.B	#ZSPDMK,R5		; MASK SPEED FLAG
	CMP.B	#Z15SPD,R5		;
	BNE	SV24P0			; BR. IF NOT IMAGE MIDDLE SPEED
	MOV.W	R3,@-SP 		;+ SAVE IGNORE LENGTH
	MOV.W	R4,@-SP 		;+ SAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@DATLNS:8,R3		; GET LOOP COUNTER
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
SV24_6: JSR	@GETI24 		; GET IMAGE DATA (= 3 byte)
	MOV.B	@R4,R5			; GET OLD DATA
	OR.B	@(3,R4),R5		;
	OR.B	R0,R5			;
	MOV.B	R5,@R4			; SAVE 1->8 PIN DATA
	SWAP	R0			;
	MOV.B	@(1,R4),R5		; GET OLD DATA
	OR.B	@(4,R4),R5		;
	OR.B	R0,R5			;
	MOV.B	R5,@(1,R4)		; SAVE 9->16 PIN DATA
	MOV.B	@(2,R4),R5		; GET OLD DATA
	OR.B	@(5,R4),R5		;
	OR.B	R1,R5			;
	MOV.B	R5,@(2,R4)		; SAVE 17->24 PIN DATA
	ADDS.B	#3,R4			; UPDATE IMAGE BUFFER POINTER
	SCB/F	R3,SV24_6		; BR. IF NOT END
	BRA	SV24_8
	;
SV24P0: MOV.W	#1,R5			; SET SKIP 0 COLUMN
	BRA	SV24_2
	;
SV24P1: MOV.W	#3+1,R5 		; SET SKIP 1 COLUMN VALUE
SV24_2: MOV.W	R3,@-SP 		;+ SAVE IGNORE LENGTH
	MOV.W	R4,@-SP 		;+ SAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@DATLNS:8,R3		; GET LOOP COUNTER
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
SV24_4: JSR	@GETI24 		; GET IMAGE DATA (= 3 byte)
	MOV.B	R0,@R4+ 		; SAVE 1->8 PIN DATA
	SWAP	R0			;
	MOV.B	R0,@R4+ 		; SAVE 9->16 PIN DATA
	MOV.B	R1,@R4			; SAVE 17->24 PIN DATA
	ADDS.B	R5,R4			; UPDATE POINTER
	SCB/F	R3,SV24_4		; BR. IF NOT END
	BRA	SV24_8
	;
SV24P5: MOV.B	@KJCDS1:8,R5		; GET SPEED/PITCH
	AND.B	#ZSPDMK,R5		; MASK SPEED FLAG
	CMP.B	#Z15SPD,R5		;
	BNE	SV24P1			; BR. IF NOT IMAGE MIDDLE SPEED
SV24_C: MOV.W	R3,@-SP 		;+ SAVE IGNORE LENGTH
	MOV.W	R4,@-SP 		;+ SAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@DATLNS:8,R3		; GET LOOP COUNTER
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
SV24_A: JSR	@GETI24 		; GET IMAGE DATA (= 3 byte)
	MOV.B	R0,@R4+ 		; SAVE 1->8 PIN DATA
	SWAP	R0			;
	MOV.B	R0,@R4+ 		; SAVE 9->16 PIN DATA
	MOV.B	R1,@R4+ 		; SAVE 17->24 PIN DATA
	SWAP	R0			;
	MOV.B	R0,@R4+ 		; SAVE 1->8 PIN DATA
	SWAP	R0			;
	MOV.B	R0,@R4+ 		; SAVE 9->16 PIN DATA
	MOV.B	R1,@R4+ 		; SAVE 17->24 PIN DATA
	SCB/F	R3,SV24_A		; BR. IF NOT END
SV24_8: MOV.W	@SP+,R4 		;+ UNSAVE IMAGE BUFFER SAVE START POINTER
	MOV.W	@SP+,R3 		;+ UNSAVE IGNORE LENGTH
	BRA	SVIMG3			; READ IGNORE DATA & IMAGE PRINT
	.PAGE
;
;	IN	    R3 : IGNORE LENGTH
;		 EP R4 : IMAGE START BUFFER POINTER
;		IMGBFP : IMAGE END   BUFFER POINTER
;
SVIMG1: MOV.W	@SP+,R0 		;+ ADJUST STACK POINTER
	JSR	@DP1IMG 		; GET IMAGE DATA POOLING & SET BIT REVERSE TABLE
	BTST.B	#QIMG24,@APL1F:8	;
	BNE	SVIMG3			; BR. IF IMAGE 24 PIN RECEIVE
SVIMG2: TST.W	R3			;
	BEQ	SVIM_6			; BR. IF IGNORE DATA = 0
	ADD.W	#-1,R3			;
SVIM_2: JSR	@GETI8			; GET IGNORE DATA
	SCB/F	R3,SVIM_2		; BR. IF NOT END
	BRA	SVIM_6
	;
SVIMG3: TST.W	R3			;
	BEQ	SVIM_6			; BR. IF IGNORE DATA = 0
	ADD.W	#-1,R3			;
SVIM_4: JSR	@GETI24 		; GET IGNORE DATA (= 3 byte)
	SCB/F	R3,SVIM_4		; BR. IF NOT END
SVIM_6: JSR	@DP1INT 		; GET INPUT DATA IS INTERRUPT
	BSET.B	#QIMGDT,@APL0F:8	; SET IMAGE DATA FLAG
	BSET.B	#QIMGPR,@PRMODF:8	; SET IMAGE DATA INTO TEXT BUFFER FLAG
	BCLR.B	#QIMGRV,@APL2F:8	; RESET IMAGE DATA RECEIVE FLAG
	RTS
;
;	<< CHECK MIDDLE SPEED FOR 1/180 INCH / 1/360 INCH >>
;
;	OUT	ZERO FLAG :	= 0 ... MIDDLE SPEED
;			    NOT = 0 ... NOT MIDDLE SPEED
;
;	USE	FP
;
SVIM_A: MOV.W	@TXTBFP:8,FP		; GET TEXT BUFFER POINTER
	SUBS.B	#ZFMTSZ,FP		; ADJUST 1 FORMAT (BEFORE FORMAT)
	MOV.B	@(YSPDPF,FP),FP 	; GET SPEED/PITCH FLAG
	AND.B	#ZSPDMK,FP		; GET SPEED FLAG
	CMP.B	#Z15SPD,FP		;
	RTS
	.PAGE
;
; << SUB >>	CHECK IMAGE DATA LENGTH & UPDATE COLUMN COUNTER
;
;	IN	    R1 : IMAGE SET COLUMN
;		    R2 : IMAGE PITCH
;		DATLNS : IMAGE DATA COLUMN LENGTH
;
;	OUT	    R1 : IMAGE SET COLUMN
;		    R2 : IMAGE PITCH (= EDIT)
;		    R3 : IMAGE IGNORE COLUMN LENGTH
;		DATLNS : IMAGE PRINT COLUMN LENGTH
;
;	USE	R0->FP,EP
;
ICHSL:	MOV.W	R1,@-SP 		;+ SAVE IMAGE SET COLUMN
	MOV.W	@RMARGS:8,R0		; GET RIGHT MARGIN
	SUB.W	@CLMCTC:8,R0		; - CURRENT FULL COLUMN
	BCS	ICHS_2			; BR. IF RIGHT MARGIN < CURRENT COLUMN
	CMP.W	R1,R0			;
	BCC	ICHS_3			; BR. IF (FULL-CURRENT) >= (COLUMN/DOT)
ICHS_2: MOV.W	R2,@-SP 		;+ SAVE PITCH FLAG
	JSR	@SETPR1 		; SET END MARK TO TEXT BUFFER & PRINT
	JSR	@LFCD1			; LINE FEED (= BUFFER FULL)
	MOV.W	@SP+,R2 		;+ UNSAVE PITCH FLAG
	MOV.W	@SP+,R1 		;+ UNSAVE IMAGE SET COLUMN
	MOV.W	@RMARGS:8,R0		; GET RIGHT MARGIN
	SUB.W	@CLMCTC:8,R0		; - CURRENT FULL COLUMN
	CMP.W	R1,R0			;
	BCC	ICHSL			; BR. IF (FULL-CURRENT) >= (COLUMN/DOT)
	MOV.W	@DATLNS:8,R3		; GET IGNORE LENGTH
	CLR.W	@DATLNS:8		; SET PRINT COLUMN LENGTH
	BRA	ICHS_E
	;
ICHS_3: MOV.W	R0,@-SP 		;+ SAVE REMAIN COLUMN OF LINE
ICHS_4: MOV.W	R2,@-SP 		;+ SAVE PITCH (= EDIT)
	CMP.W	#TXTBF,@TXTBFP:8	;
	BEQ	ICHS_C			; BR. IF NO DATA
	JSR	@CHKJST 		; CHECK JUSTIFICATION
	BEQ	ICHS_5			; BR. IF NOT JUSTIFICATION
	BSET.B	#QIMGDT,@APL0F:8	; SET IMAGE DATA FLAG
ICHS_5: MOV.B	@PRPTCF:8,R1		; GET PRINT PITCH SAVE AREA
	BCLR.B	R2,R1			; RESET CURRENT PITCH FLAG
	AND.B	#XPT120+XPT180+XPT240+XPT360,R1
	BNE	ICHS_A			; BR. IF NOT SAME PITCH
	MOV.W	@TXTBFP:8,FP		; SET TEXT BUFFER POINTER
	SUBS.B	#ZFMTSZ,FP		; - 1 FORMAT SIZE (POINT = BEFORE FORMAT)
	MOV.B	@PTMD3F:8,R0		; GET PRINT MODE 3 (= COLOR FLAG)	;DEL ? 1217+
	AND.B	#XCOLMK,R0		; GET CURRENT COLOR FLAG		;DEL ? 1217+
	MOV.B	@(YCOLRF,FP),R1 	; GET BEFORE COLOR FLAG
	AND.B	#ZN-H'80,R1             ; CLEAR MSB
	CMP.B	R1,R0			;
	BNE	ICHS_A			; BR. IF NOT SAME COLOR
	BTST.B	#QCLMLT,@COLORF:8	;
	BNE	ICHS_A			; BR. IF MULTI COLOR
	MOV.B	@PRMODF:8,R5		; GET PRINT VARIATION FLAG
	AND.B	#XDBST2+XAKVEP+XAKRLP+XKJVEP+XKJOLP+XKJULP,R5		;DEL ? 1217+
	BNE	ICHS_A			; BR. IF PRINT VARIATION CHANGE ;DEL ? 1217+
	BTST.B	#QCP7P,@COLORF:8	;
	BNE	ICHS_C			; BR. IF PANEL COPY MODE
	BTST.B	#QDBSTR,@PTMD1F:8	;
	BEQ	ICHS_B			; BR. IF NOT DOUBLE-STRIKE MODE
	BTST.B	#7,@(YCOLRF,FP) 	;
	BEQ	ICHS_A			; BR. IF NOT SAME MODE (DOUBLE-STRIKE)
	BRA	ICHS_C			;
	;
ICHS_B: BTST.B	#7,@(YCOLRF,FP) 	;
	BEQ	ICHS_C			; BR. IF SAME MODE (DOUBLE-STRIKE)
ICHS_A: JSR	@STPRNT 		; SET END MARK TO TEXT BUFFER & PRINT
	JSR	@INBFC			; SET NEXT LINE START = CURRENT COLUMN
ICHS_C: BSET.B	#QDELVL,@APL2F:8	; RESET DELETE CODE VALID
	BSET.B	#QIMGRV,@APL2F:8	; SET IMAGE DATA RECEIVE FLAG
	MOV.W	@SP+,R2 		;+ UNSAVE PITCH (= EDIT)
	BSET.B	R2,@PRPTCF:8		; SET PRINT PITCH FLAG (1 LINE)
	MOV.W	@SP+,R1 		;+ UNSAVE REMIAN COLUMN
	MOV.W	@SP+,FP 		;+ UNSAVE SET COLUMN
	CLR.W	R0			;
	DIVXU.W FP,R0			; GET (FULL-CURRENT) / SET COLUMN
	CLR.W	R3			; SET IGNORE COLUMN LENGTH = 0
	CMP.W	@DATLNS:8,R1		;
	BCC	ICHS_E			; BR. IF IMAGE LENGTH =< LINE LENGTH
	MOV.W	@DATLNS:8,R3		; GET IMAGE COLUMN LENGTH
	SUB.W	R1,R3			; SET IGNORE COLUMN LENGTH
	MOV.W	R1,@DATLNS:8		; SET IMAGE PRINT COLUMN LENGTH
ICHS_E: TST.W	@DATLNS:8		;
	BEQ	SVIMG1			; BR. IF COLUMN LENGTH = 0
	MOV.B	FP,@KJCDS2:8		; UNSAVE SET COLUMN
	CLR.W	@CHRWDS:8		; CLEAR COLUMN FOR BS
;	BRA	CKPOS			; CHECK COLUMN POSITION
;
; << SUB >>	CHECK COLUMN POSITION
;
;	OUT	R5 : = 0     CLMCTC = CLMMXS
;		     NOT = 0 CLMCTC < CLMMXS
;
CKPOS:	MOV.W	@CLMCTC:8,R5		; GET CURRENT COLUMN
	CMP.W	@CLMMXS:8,R5		;
	BCS	CKPS_2			; BR. IF CURRENT < MAX COLUMN
	CLR.W	R5			;
	BCLR.B	#QJSTPR,@APL2F:8	;
	RTS
	;
CKPS_2: MOV.W	#01,R5			;
	BSET.B	#QJSTPR,@APL2F:8	;
	RTS
	.PAGE
;
; << SUB >>	UPDATE IMAGE BUFFER POINTER
;
;	IN	    R1 : IMAGE 1 COLUMN LENGTH
;		    R3 : IMAGE IGNORE COLUMN LENGTH
;		    FP : IMAGE PRINT SPEED/PITCH PARAMETER
;		DATLNS : IMAGE PRINT COLUMN LENGTH
;
;	OUT	    R3 : IMAGE IGNORE COLUMN LENGTH
;		 EP R4 : IMAGE SAVE START POINTER
;		DATLNS : IMAGE PRINT COLUMN LENGTH (ADJUST -1)
;
;	USE	R0->R4,EP
;
UPIG2:	MOV.W	R3,@-SP 		;+ SAVE IGNORE COLUMN LENGTH
	MOV.W	R1,@-SP 		;+ SAVE 1 COLUMN LENGTH
	MOV.W	FP,@-SP 		;+ SAVE SPEED/PITCH PARAMETER
	BSR	GTIMGP			; GET IMAGE BUFFER POINTER
	MOV.W	@SP+,FP 		;+ UNSAVE SPEED/PITCH PARAMETER
	MOV.W	@SP+,R0 		;+ UNSAVE 1 COLUMN LENGTH
	MOV.W	@DATLNS:8,R2		; GET IMAGE PRINT COLUMN LENGTH
	EXTU	R0			;
	MULXU.W R0,R2			; CALCULATE IMAGE POINTER ADJUST VALUE (= R3)
	MOV.W	R3,@-SP 		;+ SAVE SKIP COLUMN LENGTH
	BSR	SVIMG			; SAVE IMAGE FORMAT TO TEXT BUFFER
	MOV.W	@SP+,R2 		;+ UNSAVE SKIP COLUMN LENGTH
	MOV.W	@IMGBFP:8,R4		; GET START POINTER
	ADD.W	@IMGBFP:8,R2		; + SKIP COLUMN
	MOV.W	R2,@IMGBFP:8		; UPDATE IMAGE BUFFER POINTER (= END POINTER)
	MOV.W	@SP+,R3 		;+ UNSAVE IGNORE COLUMN LENGTH
	ADD.W	#-1,@DATLNS:8		; ADJUST PRINT LENGTH (-> LOOP COUNTER)
SETIPG: LDC.B	#PAGE IMGBF,EP		; SET IMAGE BUFFER PAGE
	RTS
	.PAGE
;
; << SUB >>	GET IMAGE BUFFER SAVE START POINTER
;
;	IN	    FP : IMAGE SPEED/PITCH PARAMETER
;			GETIBP : ANK/KANJI ONLY
;			GTIMGP : IMAGE ONLY
;
;	OUT	    R1 : IMAGE BUFFER START POINTER
;		IMGBFP : IMAGE BUFFER SAVE START POINTER
;
;	USE	R0->FP,EP
;
GTIMGP: MOV.W	@CLMCTC:8,R1		; GET CURRENT COLUMN
	MOV.B	FP,R3			; SAVE SPEED/PITCH PARAMETER
	BSR	GETIBP			; GET IMAGE BUFFER START POINTER
	ADD.W	#IMGBF,R1		; + IMAGE BUFFER BASE
	MOV.W	R1,@IMGBFP:8		; SAVE IT
	RTS
;
;	IN	R1 : CURRENT COLUMN
;		R3 : SPEED/PITCH FLAG
;
GETIBP: SHLR.B	R3			; GET PITCH PARAMETER (SHIFT 4 TIMES RIGHT)
	SHLR.B	R3			;
	SHLR.B	R3			;
	SHLR.B	R3			;
	CLR.W	R0			; CLEAR HIGH DATA
	CMP.B	#ZPTC24,R3		;
	BEQ	GTIM_4			; BR. IF 240 DPI
	CMP.B	#ZPTC18,R3		;
	BEQ	GTIM_5			; BR. IF 180 DPI
	BCC	GTIM_6			; BR. IF 120 DPI
	DIVXU.W #1440/360,R0		; CALCULATE 1/360 INCH COLUMN
	BRA	GTIM_7
	;
GTIM_4: DIVXU.W #1440/240,R0		; CALCULATE 1/240 INCH COLUMN
	BRA	GTIM_7
	;
GTIM_5: DIVXU.W #1440/180,R0		; CALCULATE 1/180 INCH COLUMN
	BRA	GTIM_7
	;
GTIM_6: DIVXU.W #1440/120,R0		; CALCULATE 1/120 INCH COLUMN
GTIM_7: MOV.W	R1,R0			; SAVE EACH UNIT COLUMN
	MULXU.W #3,R0			; COLUMN x 3 = BYTE
	RTS
	.PAGE
;
; << SUB >>	SAVE IMAGE FORMAT TO TEXT BUFFER
;
;	IN	    R3 : SKIP COLUMN SIZE
;		    FP : IMAGE PRINT SPEED/PITCH PARAMETER
;		IMGBFP : IMAGE BUFFER POINTER
;
;	OUT	CLMCTC : NEXT COLUMN
;
;	USE	R0->FP,EP
;
SVIMG:	MOV.W	FP,R5			; SAVE SPEED/PITCH FLAG
	BTST.B	#QPRFST,@PRMDF:8	;
	BNE	SVIG_2			; BR. IF NOT LINE START
	MOV.W	R3,@-SP 		;+ SAVE SKIP COLUMN SIZE
	MOV.W	R5,@-SP 		;+ SAVE PRINT SPEED/PITCH FLAG
	JSR	@STLSM			; SET LINE START MODE
	MOV.W	@SP+,R5 		;+ UNSAVE PRINT SPEED/PITCH FLAG
	MOV.W	@SP+,R3 		;+ UNSAVE SKIP COLUMN SIZE
SVIG_2: CMP.W	#TXTBF,@TXTBFP:8	;
	BEQ	SVIG_4			; BR. IF NO DATA
	MOV.W	@TXTBFP:8,FP		; GET TEXT BUFFER POINTER
	SUBS.B	#ZFMTSZ,FP		; - 1 FORMAT SIZE
	CMP.B	#ZIMGFM,@(YFMATF,FP)	;
	BNE	SVIG_4			; BR. IF NOT SAME FORMAT
	CMP.B	@(YSPDPF,FP),R5 	;
	BNE	SVIG_4			; BR. IF NOT SAME PITCH
	BSR	SVIG_A			; UPDATE COLUMN COUNTER
	MOV.W	@(YIMGED,FP),R1 	; GET BEFORE END POINTER
	ADD.W	R3,R1			; + SKIP COLUMN (= END POINTER)
	MOV.W	R1,@(YIMGED,FP) 	; SAVE END SAVE POINTER
	JMP	@STPVF			; SET PRINT VARIATION FLAG
;
;	<< NOT SAME BEFORE FORMAT PITCH TO CURRENT PITCH >>
;
SVIG_4: MOV.W	R3,@-SP 		;+ SAVE SKIP COLUMN SIZE
	MOV.B	R5,@KJCDS1:8		;+ <<--- SAVE IMAGE SPEED/PITCH PARAMETER --->>
	JSR	@CKTXTB 		; CHECK TEXT BUFFER POINTER
	MOV.B	#ZIMGFM,R2		; SET IMAGE FORMAT FLAG
	CLR.W	R1			; CLEAR CHARACTER PITCH (= 0)
	JSR	@STCOMN 		; SET COMMON MODE TO TEXT BUFFER
	MOV.W	@SP+,R3 		;+ UNSAVE SKIP COLUMN SIZE
	BSR	SVIG_A			; UPDATE COLUMN COUNTER
	CLR.B	@(YRSRV1,FP)		; CLEAR RESERVE AREA
	MOV.B	@KJCDS1:8,R2		;+ <<--- UNSAVE IMAGE SPEED/PITCH PARAMETER --->>
	BSR	SVIG_E			; CHECK KANJI HIGH SPEED MODE
	MOV.B	R2,@(YSPDPF,FP) 	; SAVE IMAGE SPEED/PITCH PARAMETER
	MOV.W	@IMGBFP:8,R1		; GET SAVE START POINTER
	MOV.W	R1,@(YIMGST,FP) 	; SAVE START SAVE POINTER
SVIG_6: ADD.W	R3,R1			; + SKIP COLUMN (= END POINTER)
	MOV.W	R1,@(YIMGED,FP) 	; SAVE END SAVE POINTER
SVIG_8: JSR	@STPVF			; SET PRINT VARIATION FLAG
	JMP	@UPTBFP 		; UPDATE TEXT BUFFER POINTER
	.PAGE
SVIG_A: MOV.W	@DATLNS:8,R0		; GET DATA LENGTH
	MOV.B	@KJCDS2:8,R1		; GET IMAGE SET COLUMN
	EXTU	R1			;
	MULXU.W R1,R0			; CALCULATE SKIP PITCH (COLUMN FOR 1/1440 inch)
	ADD.W	@CLMCTC:8,R1		; + CURRENT COLUMN
	MOV.W	R1,@CLMCTC:8		; UPDATE COLUMN COUNTER
	CMP.W	@CLMMXS:8,R1		;
	BCS	SVIG_C			; BR. IF MAX COLUMN > CURRENT COLUMN
	MOV.W	R1,@CLMMXS:8		; UPDATE MAX COLUMN
SVIG_C: RTS
	;
SVIG_E: MOV.B	R2,R5			; SAVE SPEED/PITCH FLAG
	BCLR.B	#QSPDFX,R5		; RESET FIXED SPEED FLAG
	SHLR.B	R5			; SHIFT 4 TIMES (MAKE HIGH NIBBLE)
	SHLR.B	R5			;
	SHLR.B	R5			;
	SHLR.B	R5			;
	CMP.B	#ZPTC36,R5		;
	BNE	SVIG_H			; BR. IF NOT 1/360 INCH PITCH
	BTST.B	#QSPDFX,R2		;
	BNE	SVIG_H			; BR. IF FIXED SPEED FLAG (SELF PRINT C & SERVICE MODE)
SVIG_D: MOV.B	@PSPDFS:8,R1		; GET PANEL SPEED
	BCLR.B	#QKNJHS,R1		; RESET KANJI HIGH SPEED MODE
	BTST.B	#QKNJHS,@PSPDFS:8	;
	BEQ	SVIG_I			; BR. IF NOT KANJI HIGH SPEED MODE
	CMP.B	#ZSPD15,R1		;
	BCC	SVIG_F			; BR. IF PANEL SPEED >= LOW SPEED
	MOV.B	#Z20SPD,R1		; SET KANJI HIGH SPEED (HIGH SPEED -> LQ/PROPORTIONAL/KANJI)
	BRA	SVIG_G
	;
SVIG_I: CMP.B	#ZSPD10,R1		;
	BNE	SVIG_F			; BR. IF NOT PANEL = LOW SPEED
	MOV.B	#Z10SPD,R1		; SET ALTER SPEED FLAG
	BRA	SVIG_G
	;
SVIG_F: ADDS.B	#4,R1			; ADJUST PANEL SPEED
SVIG_G: AND.B	#ZPTCMK,R2		; GET PRINT PITCH
	OR.B	R1,R2			; OR WITH CURRNT PANEL SPEED
	MOV.B	R2,@KJCDS1:8		;+ <<--- SAVE IMAGE SPEED/PITCH PARAMETER --->>
SVIG_H: BCLR.B	#QSPDFX,R2		; RESET FIXED SPEED FLAG
RMVI_2: RTS
	.PAGE
;
; << SUB >>	REMOVE IMAGE FORMAT	< OFFLINE ONLY >
;
;	IN	R5 : TEXT BUFFER POINTER (END MARK)
;
RMVIMG: LDC.B	#PAGE TXTBF,EP		; SET TEXT BUFFER PAGE
	SUBS.B	#ZFMTSZ,R5		; ADJUST BEFORE 1 FORMAT
	MOV.W	@TXTBFP:8,R4		; GET CURRENT TEXT BUFFER POINTER
	MOV.W	@R5+,R0 		; GET FORMAT FLAG & COLOR FLAG
	MOV.W	R0,@R4+ 		; SAVE IT (REMOVE)
	MOV.W	@R5+,R0 		; GET COLUMN COUNTER
	MOV.W	R0,@R4+ 		; SAVE IT (REMOVE)
	MOV.W	@R5+,R0 		; GET SPEED/PITCH FLAG & RESERVE AREA
	MOV.W	R0,@R4+ 		; SAVE IT (REMOVE)
	MOV.W	@R5+,R0 		; GET IMAGE START POINTER
	MOV.W	R0,@R4+ 		; SAVE IT (REMOVE)
	MOV.W	@R5,R0			; GET IMAGE END POINTER
	MOV.W	R0,@R4			; SAVE IT (REMOVE)
	BSR	SVIG_8			; SET PRINT VARIATION FLAG & UPDATE TEXT POINTER
	JMP	@STLSM			; SET LINE START MODE
;
; << SUB >>	SET PRINT SPEED FLAG
;
;	IN	R2 : PRINT PITCH
;
;	OUT	FP : IMAGE PRINT SPEED/PITCH PARAMETER
;
ST10S:	MOV.B	#Z10SPD,FP		; SET LOW SPEED FLAG
	BRA	ST30_4
	;
ST15S:	MOV.B	#Z15SPD,FP		; SET MIDDLE SPEED FLAG
	BRA	ST30_4
	;
ST20S:	MOV.B	#Z20SPD,FP		; SET HIGH SPEED FLAG
	BRA	ST30_4
	;
ST30S:	MOV.B	#Z30SPD,FP		; SET SUPER SPEED FLAG
ST30_4: SHLL.B	R2			; SHIFT 4 TIMES (MAKE HIGH NIBBLE)
	SHLL.B	R2			;
	SHLL.B	R2			;
	SHLL.B	R2			;
	OR.B	R2,FP			; MAKE IMAGE SPEED/PITCH PARAMETER
	RTS
	.END
