	.PROGRAM	sysdp3
	.HEADING	"M4324 DATA PROCESS PASS 3 MODULE"
	.LIST		NOCOND,NOEXP
;********************************************************
;							*
;	M4324 DATA PROCESS PASS 3 SYSTEM MODULE		*
;							*
;	FILE NAME	SYSDP3.MAR			*
;	CREATED		16/JUL/1991			*
;							*
;********************************************************
;
	.EXPORT		DP3INI,CALDPH,CALDP3,WAIDP3,RELDP3
	.EXPORT		WTACTF,WTCMDE,WTESCE,WTPRTF
	.EXPORT		CLRLFP,GETLFP,SETLFP,SETRS1,SETRS2,SETRS3
	.EXPORT		HSADJ1,HSADJ2,HSADJ3,HSPUMV,HSUP,  HSDOWN
	.EXPORT		HSINIT,HSAMD, HSMMD, HSPUOP
	.EXPORT		HSOPSR,HSOPSS,HSOPEN,HSOPN1,HSOPN2,HSAUTO,HSFIX
	.EXPORT		LFRVS0,LFRVS, LFRVSN,LFFWD, PRCHK
	.EXPORT		EJCFRM,EJCBTM,EJCSHT,INISHT
	.EXPORT		INSFRM,INSSHT,INS260,INSAF1,INSAF2,INSAF3,INSAF4
	.EXPORT		SETPRT,SETPRS,SETPRD,SETPM2,RETPM2,PBHOC,PBHOC1
	.EXPORT		PRT11, PRT12, PRT13, PRT2,  PRT2L
	.EXPORT		PRT3,  PRT3L, PRT4,  PRT4L

	.IMPORT		ZPRTLC,ZHST,  ZHSNZ, ZBLN1, ZBLN2, ZLFN4, ZIAN2
	.IMPORT		ZLFPC, ZLFP1, ZLFP2, ZLFP3, ZLFP4, ZLFP5, ZLFP6
	.IMPORT		ZLFP7, ZLFP8, ZLFP9, ZLF3P1,ZLF3P2
	.IMPORT		SYS$TP,D3HPKT,D3LPKT
	.IMPORT		ACFTB, ACFTB1,ACFTB2,ACFTB3,ACFTB4
	.IMPORT		RBSTB1,RBSTB2,RBSTB3,HSNYTB
	.IMPORT		PRTTB1,PRTTB2,PRTTB3,PRTTB4
	.IMPORT		PCLMTB,PDPITB,PGAPTB
	.IMPORT		SYSCAL,UPDOTC,RDHSNT,DP3STA,DP3LI, PRTINI
	.IMPORT		SETECD,SELPMS,SELPMF,SELPMB,SELPMA,RETPM, CHKPM
	.IMPORT		CRHM,  CRCHK, CRMVPR
	.IMPORT		HSPH,  HSINI, HSOP,  HSMVP, HSMV,  HSPUSH,HSPU
	.IMPORT		RSHM,  RSMVX, RSADJ, SETRSH,RSMV1
	.IMPORT		PBCL,  PBCL1, PBOP,  PBHO
	.IMPORT		LVPM,  LVFM,  LVSH,  LFPO
	.IMPORT		LFF1,  LFFW,  LFR1,  LFRW
	.IMPORT		SETLF1,SETLF2,SETLF3,SETLF4
	.IMPORT		GETBLC,GETEJF,GETEJS,GETEJB
	.IMPORT		ESCF,  EJCF,  EJCB,  EJCA,  EJCS
	.IMPORT		INSF,  INS2,  INSA
	.IMPORT		SELPRB,UPSEQ, SENDP

	.INCLUDE	"COMMON.H"
	.INCLUDE	"M43RTM.H"
	.INCLUDE	"ALARM.H"
	.INCLUDE	"SCIIOS.H"
	.INCLUDE	"SYSEEP.H"
	.INCLUDE	"SYSDP3.H"
	.INCLUDE	"SYSPRT.H"
	.INCLUDE	"GAHEAD.H"
	.INCLUDE	"GAINT.H"
	.INCLUDE	"SYSRAM.H"
	.PAGE
;	.SECTION	SYSRAM,DUMMY,LOCATE=H'FEC0
;
;	DP3 CONSTANT
;
ZP3MAX:	.EQU	19584			; MAX PRINT COLUMN FOR 3.0 SPEED
ZPRNP:	.EQU	XBPE+XBPL+XPRE		; NORMAL PRINT PASS
ZPR1P:	.EQU	XBPE+XBPL+XPRE+XPR2P	; HIGH DUTY 1ST PASS
ZPR2P:	.EQU	XBPE+XBPL+XPRE+XPR2+XPR2P; HIGH DUTY PRINT 2ND PASS

;
;	SYSDP3 LOCAL WORK AREA
;
	.ORG	H'FED4
HSRSF:	.RES.B	  1			; HEAD SHIFT/RIBBON SHIFT STATUS FLAG
QHSMM:	.EQU	  0			;   1:HEAD SHIFT MANUAL MODE
QHSDN:	.EQU	  1			;   1:HEAD SHIFT DONE
QHSFD:	.EQU	  2			;   1:HEAD SHIFT FIX DONE
QHSNZ:	.EQU	  3			;   1:HEAD SHIFT NZ > 35
QHSSK:	.EQU	  4			;   1:HEAD SHIFT OPEN SKIP
QHOPON:	.EQU	  5			;   1:HALF OPEN ON
QPMDG2:	.EQU	  6			;   1:PAPER MODE GROUP 2
QRSDN:	.EQU	  7			;   1:RIBBON SHIFT DOWN MODE

HSNTS:	.RES.B	  1			; HEAD SHIFT Nt SAVE
PRTLC:	.RES.B	  1			; PRINT LINE COUNTER
RBSTP:	.RES.B	  1			; RIBBON SHIFT TABLE POINTER
LFPC:	.RES.W	  1			; LF POSITION COUNTER
LFPS:	.RES.W	  1			; LF POSITION COUNTER SAVE (SHEET)
	.RES.W	  1			; reserve area
	.PAGE
	.SECTION	SYS1,CODE,ALIGN=16
;
;	DP3 CALL
;
;	IN	R2 : PACKET CODE
;	     R3-R5 : PARAMETER
;
;	OUT	NONE
;
CALDPH:	MOV.W	#D3HPKT,R1		; SELECT HIGH PRIORITY PACKET
	BRA	CALD_1			;

CALDP3:	MOV.W	#D3LPKT,R1		; SELECT LOW PRIORITY PACKET
CALD_1:	TST.B	R2			;
	BPL	CALD_2			; BR IF NOT ACTION WAIT
	MOV.W	@SYS$TP:8,R5		; GET CURRENT TCB POINTER
CALD_2:	MOV.B	#SNDPKT,R0		; CALL DP3 BY PACKET
	JMP	@SYSCAL			;

;
;	WAIT DP3 ACTION END
;
;	IN	NONE
;
;	OUT	NONE
;
WAIDP3:	MOV.B	#XTFOR+XTFCL1+XTFCL0,R3	;
	MOV.W	#FACTF,R2		;
	MOV.B	#WAIFLG,R0		; WAIT DP3 ACTION END
	JMP	@SYSCAL			;
	.PAGE
	.SECTION	SYS2,CODE,ALIGN=16
;
;	DP3 TASK INITIALIZE
;
;	IN	NONE
;
;	OUT	NONE
;
DP3INI:	JSR	@PRTINI			; INITIALIZE SYSPRT
	CLRFLG	@DP3TCB			; CLEAR DP3 EVENT FLAG
	BSR	HSMMD:16		; SET HEAD SHIFT MANUAL MODE
	CALIOS	#SCIVER			; SEND SLAVE CPU VERSION NO. REQUEST
	CALIOS	#SCISNS			; SEND SENSOR STATUS REQUEST
	CLR.W	R0			;
	MOV.B	@SNSF:8,R2		; GET PE SENSOR STATUS
	BTST.B	#QSPES,R2		;
	BEQ	DP3I_1			; BR IF SHEET PE
	MOV.W	R0,@SOPC:8		; SET SHEET OPC
DP3I_1:	BTST.B	#QFPES,R2		;
	BEQ	DP3I_2			; BR IF FORMS PE
	MOV.W	R0,@FOPC:8		; SET FORMS OPC
DP3I_2:	BTST.B	#QBPES,R2		;
	BEQ	DP3I_3			; BR IF BOTTOM PE
	MOV.W	R0,@BOPC:8		; SET BOTTOM OPC
DP3I_3:	JSR	@DP3LI			; INITIALIZE SYSDP3L
	JMP	@DP3STA			; START DP3 TASK

;
;	RELEASE PACKET DATA
;
;	IN	R1 : PACKET POINTER
;
;	OUT  R2-R5 : PACKET CODE
;		 C : 1=NO PACKET DATA
;
RELDP3:					;
	POLPKT				; DELETE DATA FROM PACKET
	BCS	RELD_2			; BR IF NO PACKT DATA
	TST.B	R2			;
	BPL	RELD_1			; BR IF NOT ACTION WAIT PACKET DATA
	BSR	WTACTF			; WAIT SLAVE CPU ACTION END
	MOV.W	R5,R1			; SET WAIT TCB POINTER
	BCLR.B	#QWACTF,R2		; RESET ACTION WAIT FLAG
	MOV.W	R2,@-SP			;
	MOV.W	#FACTF,R2		;
	ORFLG				; WAKE UP ACTION END WAIT TASK
	MOV.W	@SP+,R2			;
RELD_1:	CLR.B	R0			; RESET C-FLAG
RELD_2:	RTS				;
	.PAGE
;
;	WAIT SLAVE CPU COMMAND/ACTION/PRINT END
;
;	IN	NONE
;
;	OUT  R0-R3 : NOT CHNAGE
;	     R5-FP : NOT CHNAGE
;		 Z : 0=COMMAND CANCEL
;

WTCMDE:	MOV.W	#FCMDE,R4		; WAIT COMMAND TRANSMIT ENABLE
	BSR	WTDP3F			;
	BEQ	WTDP_2			; BR IF NOT COMMAND CANCEL
WTACTF:					;
	CLRFLG	@DP3TCB			; CLEAR DP3 EVENT FLAG
	BTST.B	#QSLACT,@INTPRE		;
	BEQ	WTDP_1			; BR IF ALREADY ACTION END
	MOV.W	#FACTF,R4		; WAIT SLAVE CPU ACTION END
	BRA	WTDP3F			;

WTESCE:	MOV.W	#FSTOP+FCMDE,R4		; WAIT COMMAND TRANSMIT ENABLE
	BRA	WTDP3F			;

WTPRTF:					;
	CLRFLG	@DP3TCB			; CLEAR DP3 EVENT FLAG
	BTST.B	#QPRACT,@PRLFF:8	;
	BEQ	WTDP_1			; BR IF NOT PRINT ACTIVE
	MOV.W	#FPRTF,R4		; WAIT PRINT END
WTDP3F:	STM	(R0-R3),@-SP		;
	MOV.W	R4,R2			;
	MOV.B	#XTFOR+XTFCL1+XTFCL0,R3	;
	WAIFLG				; WAIT EVENT FLAG
	LDM	@SP+,(R0-R3)		;
WTDP_1:	BTST.B	#QCCAND,@PRLFF:8	; CHECK COMMAND CANCEL STATUS
WTDP_2:	RTS				;
	.PAGE

;
;	SET PAPER MODE GROUP 2 FLAG
;
SETPM2:	BSET.B	#QPMDG2,@HSRSF:8	; SET PAPER MODE GROUP 2 FLAG
	RTS

;
;	RESET PAPER MODE GROUP 2 FLAG
;
RETPM2:	BCLR.B	#QPMDG2,@HSRSF:8	; RESET PAPER MODE GROUP 2 FLAG
	RTS

;
;	SET/RESET LF POSITION COUNTER
;
;	IN	R3 : LF POSITION
;
;	OUT	R3 : NOT CHANGE
;
SETLFP:	MOV.W	#ZLFPC,R0		; GET LF POSITION COUNT BASE
	ADD.W	R3,R0			; CALCULATE LF POSITION
	BCC	SETL_1			; BR. IF NOT OVERFLOW
	MOV.W	#ZNN,R0			;
SETL_1:	MOV.W	R0,@LFPC:8		; RESET LF POSITION COUNTER
	MOV.W	R0,@LFPS:8		; RESET LF POSITION COUNTER SAVE (SHEET)
	RTS				;

CLRLFP:	CLR.W	R0			;
	BRA	SETL_1			; CLEAR LF POSITION COUNTER

;
;	GET LF POSITION COUNTER
;
;	IN	NONE
;
;	OUT	R0 : ORIGINAL LF POSITION
;		R1 : LF POSITION
;
GETLFP:	MOV.W	@LFPC:8,R0		; GET LF POSITION COUNTER
	MOV.W	R0,R1			; SAVE IT
	SUB.W	#ZLFPC,R1		; - LF POSITION COUNT BASE
	BCC	GETL_1			;
	CLR.W	R1			;
GETL_1:	RTS
	.PAGE
;
;	SET RIBBON SHIFT TABLE		SETRS1 : COLOUR RIBBON
;					SETRS2 : RED/BLACK RIBBON
;	IN	NONE			SETRS3 : BLACK RIBBON
;
;	OUT	 Z : 0=RIBBON TYPE CHANGE
;
SETRS1:	MOV.W	#RBSTB1,R1		; GET COLOUR RIBBON TABLE
	CMP.B	@RBSTP:8,R1		;
	BNE	SETR_3			; BR IF RIBBON TYPE CHANGE
SETR_1:	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CHANGE
	RTS				;

SETRS2:	MOV.W	#RBSTB2,R1		; GET RED/BLACK RIBBON TBALE
	MOV.W	#RBSTB3,R0		;
	CMP.B	@RBSTP:8,R0		; GET CURRENT RIBBON TABLE POINTER
	BHI	SETR_2			; BR IF NOT RIBBON TYPE CHANGE
	BRA	SETR_3			;

SETRS3:	MOV.W	#RBSTB3,R1		; GET BLACK RIBBON TABLE
SETR_2:	CMP.B	@RBSTP:8,R1		;
	BLS	SETR_1			; BR IF NOT RIBBON TYPE CHANGE
SETR_3:	BCLR.B	#QRSDN,@HSRSF:8		; RESET RIBBON SHIFT DOWN FLAG
	MOV.B	R1,@RBSTP:8		; SET RIBBON SHIFT TABLE
	MOV.B	@R1,R1			;
	JSR	@SETRSH			; SET RIBBON SHIFT HOME POSITION
	MOV.B	#1,R0			; RESET Z-FLAG FOR RIBBON TYPE CHNAGE
	RTS				;
	.PAGE
;
;	HEAD SHIFT ADJUST FOR FACTORY ADJUST
;
;	IN	NONE
;
;	OUT	 Z : 0=COMMAND CANCEL
;
HSADJ1:	JSR	@HSPUSH			; PUSH HEAD SHIFT TO PAPER
	BNE	HSUP_1			; BR IF COMMAND CANCEL
	BCLR.B	#QHSDN,@HSRSF:8		; RESET HEAD SHIFT DONE
	BCLR.B	#QHSFD,@HSRSF:8		; RESET HEAD SHIFT FIX DONE
	BCLR.B	#QHSNZ,@HSRSF:8		; RESET OVER Nz FLAG
	MOV.B	#0,R0			; RESET Z-FLAG FOR NOT CANCEL
	RTS				;

;
;	HEAD SHIFT PUSH AND MOVE
;
;	IN	R2 : TARGET POSITION
;
;	OUT	 Z : 0=COMMAND CANCEL
;
HSPUMV:	JSR	@HSPU			; PUSH HEAD SHIFT TO PAPER
	BNE	HSUP_1			; BR IF COMMAND CANCEL
	JMP	@HSMVP			; MOVE HEAD SHIFT TO N0 POSITION

;
;	HEAD SHIFT UP/DOWN ADJUST
;
;	IN	NONE
;
;	OUT	 Z : 0=COMMAND CANCEL
;
HSUP:	MOV.W	@HSPC:8,R2		; GET HEAD SHIFT POSITION
	BEQ	HSUP_1			; BR IF ALREADY HOME POSITION
	ADD.W	#-1,R2			; CALCULATE UP POSITION
	BNE	HSMVP			; BR IF NOT HOME POSITION ADDRESS
HSUP_1:	MOV.B	#1,R0			; RESET Z-FLAG FOR CANCEL
	RTS				;
					;
HSUP_2:	MOV.W	@SP+,R3			;
	BRA	HSUP_1			;
					;
HSDOWN:	MOV.W	@HSPC:8,R2		; GET HEAD SHIFT POSITION
	ADD.W	#1,R2			; CALCULATE DOWN POSITION
	JMP	@HSMVP			;
	.PAGE
;
;	HEAD SHIFT ADJUST FOR HEAD EXCHANGE
;
;	IN	R3 : M1 POSITION
;
;	OUT	 Z : 0=COMMAND CANCEL
;
HSADJ2:	MOV.W	R3,@-SP			; SAVE M1 POSITION
	MOV.W	#10-1,R2		; SET Ms CHECK COUNT
	CLR.W	R3			;
HSAD_2:	JSR	@HSOP			;
	BNE	HSUP_2			; BR IF COMMAND CANCEL
	JSR	@CRHM			; CARRIAGE HOME
	BNE	HSUP_2			; BR IF COMMAND CANCEL
	BSR	HSADJ1			; PUSH HEAD SHIFT TO PAPER
	BNE	HSUP_2			; BR IF COMMAND CANCEL
	ADD.W	@HSPC:8,R3		; ADDER NEW Ms
	SCB/F	R2,HSAD_2		; BR IF NOT CHECK END
	CLR.W	R2			;
	DIVXU.W	#10,R2			; GET AVARAGE OF Ms
	MOV.W	@SP+,R2			; UNSAVE M1 POSITION
	SUB.W	R2,R3			; CALCULATE N = Ms - M1
	BCS	HSUP_1			; BR IF N < 0
	MOV.W	#EEPBF,FP		; GET EEPROM BUFFER POINTER
	MOV.W	R3,@(E2HSN,FP)		; SET NEW HEAD SHIFT N
HSAD_1:	JSR	@HSMVP			; ADJUST HEAD SHIFT POISTION
	BNE	HSUP_1			; BR IF COMMAND CANCEL
	MOV.W	@HSPC:8,R0		;
	MOV.W	R0,@(E2HSM1,FP)		; SET NEW HEAD SHIFT MOTOR PHASE
	CLR.W	R0			;
	MOV.B	@HSPS:8,R0		;
	MOV.W	R0,@(E2HSF,FP)		; SET NEW HEAD SHIFT MOTOR PHASE
	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
	RTS				;

;
;	HEAD SHIFT ADJUST FOR PLATEN EXCHANGE
;
;	IN	NONE
;
;	OUT	 Z : 0=COMMAND CANCEL
;
HSADJ3:	BSR	HSADJ1			; PUSH HEAD SHIFT TO PAPER
	BNE	HSUP_1			; BR IF COMMAND CANCEL
	MOV.W	#EEPBF,FP		; GET EEPROM BUFFER POINTER
	MOV.W	@HSPC:8,R2		; GET HEAD SHIFT Ms
	SUB.W	@(E2HSN,FP),R2		; CALCULATE M1 = Ms - N
	BHI	HSAD_1			; BR IF 0 < M1
	BRA	HSUP_1			;
	.PAGE
;
;	INITIALIZE HEAD SHIFT
;
;	IN	NONE
;
;	OUT  R2-R3 : NOT CHANGE
;		FP : NOT CHNAGE
;		 Z : 0=COMMAND CANCEL
;
HSINIT:	BTST.B	#QHSMM,@HSRSF:8		;
	BNE	HSMM_2			; BR IF MANUAL MODE
	JSR	@HSINI			; INITIALIZE HEAD SHIFT
	BEQ	HSMM_4			; BR IF NOT COMMAND CANCEL
	RTS				;

;
;	SET AUTO/MANUAL HEAD SHIFT MODE
;
;	IN	NONE
;
;	OUT  R2-R3 : NOT CHANGE
;		FP : NOT CHNAGE
;		 Z : 0=COMMAND CANCEL
;
HSAMD:	BTST.B	#QHSMM,@HSRSF:8		;
	BEQ	HSMM_2			; BR IF ALREADY AUTO MODE
	JSR	@HSINI			; INITIALIZE HEAD SHIFT
	BEQ	HSMM_1			; BR IF NOT COMMAND CANCEL
	RTS				;

HSMMD:	BTST.B	#QHSMM,@HSRSF:8		;
	BNE	HSMM_2			; BR IF ALREADY MANUAL MODE
	MOV.B	@EEPBF+E2HSF+1,R1	; GET HEAD SHIFT MOTOR PHASE AT M1
	JSR	@HSPH			; OUTPUT PHASE
	BNE	HSMM_3			; BR IF COMMAND CANCEL
HSMM_1:	BNOT.B	#QHSMM,@HSRSF:8		; CHANGE HEAD SHIFT MANUAL MODE
HSMM_4:	BCLR.B	#QHSDN,@HSRSF:8		; RESET HEAD SHIFT DONE
	BCLR.B	#QHSFD,@HSRSF:8		; RESET HEAD SHIFT FIX DONE
	BCLR.B	#QHSNZ,@HSRSF:8		; RESET OVER Nz FLAG
HSMM_2:	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
HSMM_3:	RTS				;

;
;	HEAD SHIFT PUSH AND OPEN
;
;	IN	NONE
;
;	OUT	 Z : 0=COMMAND CANCEL
;
HSPUOP:	BTST.B	#QHSMM,@HSRSF:8		;
	BNE	HSOP_1			; BR IF HEAD SHIFT MANUAL MODE
	JSR	@HSPUSH			; PUSH HEAD SHIFT TO PAPER
	BRA	HSOPN2			; OPEN HEAD SHIFT
	.PAGE
;
;	HEAD SHIFT OPEN SKIP SET
;
;	IN	NONE
;
;	OUT	NONE
;
HSOPSS:	BSET.B	#QHSSK,@HSRSF:8		; SET HEAD SHIFT OPEN SKIP
	RTS				;

;
;	HEAD SHIFT OPEN
;
;	IN	NONE
;
;	OUT	R3 : NOT CHANGE
;		FP : NOT CHNAGE
;		 Z : 0=COMMAND CANCEL
;
HSOPSR:	BCLR.B	#QHSSK,@HSRSF:8		; RESET HEAD SFIFT OPEN SKIP
HSOPEN:	BTST.B	#QHSSK,@HSRSF:8		;
	BNE	HSOP_1			; BR IF HEAD SHIFT OPEN SKIP
HSOPN1:	BTST.B	#QHSMM,@HSRSF:8		;
	BNE	HSOP_1			; BR IF HEAD SHIFT MANUAL MODE
HSOPN2:	JSR	@HSOP			; OPEN HEAD SHIFT
	BNE	HSOP_2			; BR IF COMMAND CANCEL
	BCLR.B	#QHSDN,@HSRSF:8		; RESET HEAD SHIFT DONE
	BCLR.B	#QHSFD,@HSRSF:8		; RESET HEAD SHIFT FIX DONE
	BCLR.B	#QHSNZ,@HSRSF:8		; RESET OVER Nz FLAG
HSOP_1:	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
HSOP_2:	RTS				;
	.PAGE
;
;	HEAD SHIFT AUTO ADJUST
;
;	IN	NONE
;
;	OUT	FP : NOT CHANGE
;		 Z : 0=COMMAND CANCEL
;
HSFIX:	MOV.B	#0,R3			;
	BRA	HSAU_1			;

HSAUTO:	MOV.B	#1,R3			;
HSAU_1:	BTST.B	#QHSMM,@HSRSF:8		;
	BNE	HSOP_1			; BR IF HEAD SHIFT MANUAL MODE
	BTST.B	#QHSMV,@ERRSF:8		;
	BNE	HSAU_6			; BR IF HEAD SHIFT MOVED
	BTST.B	#QHSDN,@HSRSF:8		;
	BEQ	HSAU_6			; BR IF NOT HEAD SHIFT DONE
	CMP.B	#ZPRTLC,@PRTLC:8	;
	BCS	HSOP_1			; BR IF NOT HEAD SHIFT THERMAL ADJUST
	CLR.W	R0			;
	JSR	@RDHSNT			; READ HEAD SHIFT Nt
	MOV.B	R0,R3			; SAVE HEAD TEMPERATURE
	SUB.B	@HSNTS:8,R0		; CALCULATE Nt-Nt'
	BEQ	HSAU_2			; BR IF Nt-Nt' = 0
	EXTS	R0			;
	MOV.W	@HSPC:8,R2		; GET HEAD SHIFT POASITION
	SUB.W	R0,R2			; CORRECT TO REVERSE
	JSR	@HSMV			; CORRECT FOR HEAD TEMPERATURE
	BNE	HSAU_3			; BR IF COMMAND CANCEL
	MOV.B	R3,@HSNTS:8		; UPDATE HEAD TEMPERATURE
HSAU_2:	CLR.B	@PRTLC:8		; RESET PRINT LINE COUNTER
HSAU_3:	RTS				;
	.PAGE
					;
HSAU_6:	MOV.W	@LFPC:8,R0		;
	BEQ	HSAU_A			; BR IF NOT INSERTED
	MOV.W	#ZLFP5,R2		;
	SUB.W	R0,R2			; - LF POSITION COUNT
	BLS	HSAU_A			; BR IF POSITION >= 150/360 INCH
	JSR	@CHKPM			; GET PAPER MODE
	BCS	HSAU_9			; BR. IF FORMS PAPER
	MOV.W	#ZLFP6,R2		;
	SUB.W	R0,R2			; - LF POSITION COUNT
	BLS	HSAU_8			; BR IF POSITION >= 90/360 INCH
	MOV.W	#ZLFN4,R2		;
	BRA	HSAU_9

HSAU_8:	MOV.W	#ZLFP5,R2		;
	SUB.W	R0,R2			; - LF POSITION COUNT
HSAU_9:	JSR	@LFFW			; FEED TO 150/360 INCH POSITION
	BNE	HSAU_3			; BR IF COMMAND CANCEL
	MOV.W	R2,@-SP			;
	BSR	HSAU_A			; ADJUST HEAD SHIFT
	MOV.W	@SP+,R2			;
	MOV.W	FP,R3			;
	JSR	@GETBLC			; GET BACKLASH FEED COUNT
	ADD.W	FP,R2			; ADD BACKLASH FEED COUNT
	JSR	@LFRW			; RETURN TO PREVIOUS LF POSITION
	MOV.W	FP,R2			; GET BACKLASH FEED COUNT
	JSR	@LFFW			; FEED FORWARD
	MOV.W	R3,FP			;
	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
	RTS

HSAU_A:	JSR	@HSPUSH			; PUSH HEAD SHIFT TO PAPER
	BNE	HSAU_3			; BR IF COMMAND CANCEL
	JSR	@RDHSNT			; READ HEAD SHIFT Nt
	MOV.B	R0,@HSNTS:8		; SAVE HEAD SHIFT Nt
	MOV.W	@EEPBF+E2HSN,R1		; GET HEAD SHIFT N
	MOV.W	@EEPBF+E2HSM1,R2	; GET HEAD SHIFT M1
	MOV.W	@HSPC:8,R4		; GET HEAD SHIFT Ms
	MOV.W	R1,R0			;
	ADD.W	R2,R0			; N + M1
	SUB.W	R4,R0			; Nz = N + M1 - Ms
	BCC	HSAU_B			; BR IF NOT UNDERFLOW
	CLR.W	R0			;
HSAU_B:	BCLR.B	#QHSNZ,@HSRSF:8		; RESET Nz OVER FLAG
	CMP.W	#ZHST,R0		;
	BHI	HSAU_C			; BR IF 1P GAP (Nz > t)
	TST.B	R3			;
	BEQ	HSAU_F			; BR IF FIX ADJUST REQUEST
HSAU_C:	BCLR.B	#QHSFD,@HSRSF:8		; RESET HEAD SHIFT FIX DONE
	MOV.W	R4,R2			; GET Ms
	MOV.W	#HSNYTB-2,R3		; GET HEAD SHIFT Ny TABLE
	CMP.W	#ZHSNZ,R0		;
	BLS	HSAU_D			; BR IF Nz =< CHECK VALUE
	BSET.B	#QHSNZ,@HSRSF:8		; SET Nz OVER CHECK VALUE
HSAU_D:	ADD.W	#2,R3			;
	CMP.W	@R3+,R0			;
	BHI	HSAU_D			; BR IF NOT HIT
	SUB.W	@R3,R2			; Ms - (Ny)
	SUB.W	R1,R2			; Ms - (N + Ny)
	ADD.W	#ZHST,R2		; Ms - (N - t + Ny)
HSAU_E:	JSR	@HSOP			; HEAD SHIFT OPEN
	JSR	@RSMV1			; RIBBON SHIFT
	JSR	@CRHM			; CARRIAGE HOME
	JSR	@HSMV			; ADJUST HEAD SHIFT POISTION
	CLR.B	@PRTLC:8		; RESET PRINT LINE COUNTER
	BSET.B	#QHSDN,@HSRSF:8		; SET HEAD SHIFT DONE
	MOV.B	#0,R0			; SET Z-FLAG FOR NO CANCEL
	RTS
					;
HSAU_F:	BSET.B	#QHSFD,@HSRSF:8		; SET HEAD SHIFT FIX DONE
	BRA	HSAU_E			;
	.PAGE
;
;	 FEED REVERSE
;
;	IN	R2 : FEED COUNT
;
;	OUT	R3 : NOT CHNAGE
;		 Z : 0=FEED CANCEL
;
LFRVS0:	CLR.W	FP			; SET NO BACKLASH FEED
	BRA	LFRVSN			;

LFRVS:	JSR	@GETBLC			; GET BACKLASH FEED COUNT
LFRVSN:	TST.W	R2			;
	BEQ	LFRV_1			; BR IF NO FEED
	BSR	PBHOC:16		; CLOSE PAPER BAIL AT HALF OPEN
	ADD.W	FP,R2			; ADD BACKLASH FEED COUNT
	BSR	LFR3			; SEND REVERSE FEED COMMAND
	BNE	LFRV_1			; BR IF FEED CANCEL
	MOV.W	FP,R2			; SET BACKLASH FEED COUNT
	BNE	LFFWD			; BR IF BACKLASH FEED EXIST
LFRV_1:	RTS				;

LFR3:	JSR	@LFR1			; SEND REVERSE FEED COMMAND
	BNE	LFR3_2			; BR IF FEED CANCEL
	JSR	@SETECD			; DISABLE PE CHECK FOR NEXT LF
	MOV.W	@LFPC:8,R0		;
	BNE	LFR3_9			; BR IF ALREADY COUNT UP
	MOV.B	@SNSF:8,R4		; GET SENSOR STATUS
	AND.B	#XBPES+XFPES+XSPES,R4	;
	BEQ	LFR3_2			; BR IF NO PAPER
LFR3_9:	SUB.W	R2,R0			; UPDATE LF POSITION COUNTER
	BCC	LFR3_1			; BR IF NOT UNDERFLOW
	CLR.W	R0			;
LFR3_1:	MOV.W	R0,@LFPC:8		;
	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
LFR3_2:	RTS				;

LFF3:	BSR	PBHOC:16		; CLOSE PAPER BAIL AT HALF OPEN
	JSR	@LFF1			; SEND FORWARD FEED COMMAND
	BNE	LFF3_3			; BR IF FEED CANCEL
LFF3_1:	JSR	@SETECD			; DISABLE PE CHECK FOR NEXT LF
	MOV.W	@LFPC:8,R0		;
	BNE	LFF3_9			; BR IF ALREADY COUNT UP
	MOV.B	@SNSF:8,R4		; GET SENSOR STATUS
	AND.B	#XBPES+XFPES+XSPES,R4	;
	BEQ	LFF3_3			; BR IF NO PAPER
	MOV.W	#ZLFPC,R0		; LF POSITION COUNTER BASE
	JSR	@CHKPM			; CHECK PAPER MODE
	BCS	LFF3_4			; BR. IF FORMS
	SUB.W	@EEPBF+E2INS0,R0	;
	BCC	LFF3_9			; BR IF NOT UNDERFLOW
	CLR.W	R0			;
	BRA	LFF3_9			;

LFF3_4:	SUB.W	@EEPBF+E2INF,R0		;
	BCC	LFF3_5			; BR IF NOT UNDERFLOW
	CLR.W	R0			;
LFF3_5:	ADD.W	#ZLFP8,R0		; ADJUST LF COUNT FOR FORMS
LFF3_9:	ADD.W	R2,R0			; UPDATE LF POSITION COUNTER
	BCC	LFF3_2			; BR IF NOT OVERFLOW
	MOV.W	#ZNN,R0			;
LFF3_2:	MOV.W	R0,@LFPC:8		;
	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
LFF3_3:	RTS				;

LFF4:	BSR	LFF3_1			; UPDATE LF POSITION COUNTER
	MOV.W	#ZLFP2,R0		;
	MOV.W	R0,@LFPS:8		; SAVE LF POSITION AT BAIL OPEN (SHEET)
	RTS				;
	.PAGE
;
;	FEED FORWARD
;
;	IN	R2 : FEED COUNT
;
;	OUT	R3 : NOT CHNAGED
;		 Z : 0=FEED CANCEL
;
LFFWD:	TST.W	R2			;
	BEQ	LFFW_3:16		; BR IF NO FEED
	JSR	@CHKPM			;
	BEQ	LFF3			; BR IF BOTTOM MODE
	BCS	LFFW_D			; BR IF FORMS MODE
	MOV.W	@SOPC:8,R0		; GET OVER PE COUNT
	ADD.W	R2,R0			;
	BCS	LFFW_E			; BR IF OVERFLOW
	CMP.W	#ZLFP9,R0		;
	BCS	LFFW_D			;
LFFW_E:	JSR	@CRHM			;
LFFW_D:	MOV.B	@SNSF:8,R0		; GET SENSOR STATUS
	AND.B	#XBPES+XFPES+XSPES,R0	;
	BEQ	LFF3			; BR IF NO PAPER
	MOV.W	R2,FP			; SAVE FEED COUNT
	BTST.B	#QPMDG2,@HSRSF:8	;
	BEQ	LFFW_4			; BR IF PAPER MODE GROUP 3
	MOV.W	@LFPC:8,R0		; GET LF POSITION
	CMP.W	#ZLFP2,R0		;
	BCC	LFF3			; BR IF AFTER PAPER BAIL PASS
	ADD.W	R2,R0			; CALCULATE LF POSITION AFTER FEED
	BCS	LFFW_1			; BR IF OVERFLOW
	CMP.W	#ZLFP2,R0		;
	BCC	LFFW_1			; BR IF PAPER BAIL PASS
	CMP.W	#ZLFP1,R0		;
	BCS	LFF3			; BR IF NOT PAPER BAIL LOWER LIMIT POSITION
	JSR	@CRHM			; MOVE CR TO HOME
	BRA	LFF3			; SEND FORWARD FEED COMMAND

LFFW_9:	JSR	@PBOP			; OPEN PAPER BAIL
	BNE	LFFW_3			; BR IF PAPER BAIL OPEN CANCEL
LFFW_1:	MOV.W	@LFPC:8,R2		;
	SUB.W	#ZLFP1,R2		;
	BEQ	LFFW_2			; BR IF PAPER BAIL LOWER LIMIT
	BCS	LFFW_B			; BR IF NO NEED REVERSE FEED
	MOV.W	FP,@-SP			;
	JSR	@GETBLC			; GET BACKLASH FEED COUNT
	ADD.W	FP,R2			; ADD BACKLASH FEED COUNT
	MOV.W	@SP+,FP			;
	ADD.W	R2,FP			; ADJUST FEED COUNT
	BSR	LFR3			; SEND REVESE FEED COMMAND
	BNE	LFFW_8			; BR IF FEED CANCEL
	MOV.W	FP,@-SP			;
	JSR	@GETBLC			; GET BACKLASH FEED COUNT
	MOV.W	FP,R2			;
	MOV.W	@SP+,FP			;
	BRA	LFFW_7

LFFW_A:	JSR	@PBOP			; OPEN PAPER BAIL
	BNE	LFFW_3			; BR IF PAPER BAIL OPEN CANCEL
LFFW_B:	MOV.W	#ZLFP1,R2		;
	SUB.W	@LFPC:8,R2		;
LFFW_7:	SUB.W	R2,FP			;
	BEQ	LFFW_6			; BR IF FEED COUNT = 0
	BSR	LFF3			; SEND FORWARD FEED COMMAND
	BNE	LFFW_8			; BR IF FEED CANCEL
LFFW_2:	MOV.W	FP,R2			;
LFFW_6:	JSR	@LFPO			; OPEN PAPER BAIL AND FEED FORWARD
	BNE	LFFW_8			; BR IF FEED CANCEL
	BSR	LFF4			; UPDATE LF POSITION COUNTER
	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
LFFW_3:	RTS				;

LFFW_8:	JSR	@PBCL			; PAPER BAIL CLOCE
	MOV.B	#1,R0			; RESET Z-FLAG FOR CANCEL
	RTS

LFFW_4:	MOV.W	@LFPC:8,R0		; GET LF POSITION
	CMP.W	#ZLF3P2,R0		;
	BCC	LFF3			; BR IF AFTER PAPER BAIL PASS
	ADD.W	R2,R0			; CALCULATE LF POSITION AFTER FEED
	BCS	LFFW_5			; BR IF OVERFLOW
	CMP.W	#ZLF3P2,R0		;
	BCC	LFFW_5			; BR IF PAPER BAIL PASS
	BRA	LFF3			; BR IF NO NEED REVERSE FEED

LFFW_5:	MOV.W	@LFPC:8,R2		;
	SUB.W	#ZLF3P1,R2		;
	BEQ	LFFW_2			; BR IF PAPER BAIL LOWER LIMIT
	BCS	LFFW_C			; BR IF NO NEED REVERSE FEED
	BSR	LFR3			; SEND REVESE FEED COMMAND
	BNE	LFFW_8			; BR IF FEED CANCEL
	ADD.W	R2,FP			; CALCULATE LF POSITION AFTER FEED
LFFW_C:	MOV.W	#ZLF3P1,R2		;
	SUB.W	@LFPC:8,R2		;
	JSR	@PBOP			; OPEN PAPER BAIL
	BNE	LFFW_3			; BR IF PAPER BAIL OPEN CANCEL
	BRA	LFFW_7
	.PAGE
;
;	CHECK CONDITION FOR PRINT START
;
;	IN	NONE
;
;	OUT	R3 : NOT CHNAGED
;		FP : NOT CHANGE
;		 Z : 0=COMMAND CANCEL
;
PRCHK:	BTST.B	#QSPES,@SNSF:8		;
	BEQ	PRCH_1			; BR. IF SENSOR PE
	BTST.B	#QHOPON,@HSRSF:8	;
	BNE	PRCH_1			; BR IF NOT HALF OPEN
	JSR	@CRCHK			; CHECK CR MOVE CONDITION
	JSR	@CHKPM			;
	BLS	PRCH_1			; BR IF NOT SHEET/ACSF MODE
	MOV.W	@LFPC:8,R0		; GET LF POSITION
	CMP.W	#ZLFP3,R0		;
	BCS	PRCH_1			; BR IF BEFORE HALF OPEN POSITION
;	SUB.W	@LFPS:8,R0		;
;	BCS	PRCH_1			;
;	CMP.W	#ZLFP4,R0		;
;	BCS	PRCH_1			; BR IF NOT HALF OPEN INTERVAL
	JSR	@PBHO			; HALF OPEN PAPER BAIL
	BNE	PRCH_1			; BR IF COMMAND CANCEL
	BSET.B	#QHOPON,@HSRSF:8	; SET HALF OPEN FLAG ON
;	MOV.W	#50/ZTI,R2		;
;	WAITSK				; DELAY 0.5mS
;	JSR	@PBCL1			; CLOSE PAPER BAIL
;	BNE	PRCH_1			; BR IF FEED CANCEL
	MOV.W	@LFPC:8,R0		;
	MOV.W	R0,@LFPS:8		; SAVE LF POSITION AT BAIL OPEN (SHEET)
PRCH_1:	BTST.B	#QCCAND,@PRLFF:8	; CHECK COMMAND CANCEL STATUS
	RTS				;

;
;	HALF OPEN CLOSE
;
;	IN/OUT	NONE
;
;			PBHOC  : PRINT / LF
;			PBHOC1 : EJECT / INSERT
;
PBHOC:	BTST.B	#QSPES,@SNSF:8		;
	BNE	PBHC_2			; BR. IF NOT SENSOR PE
PBHOC1:	BTST.B	#QHOPON,@HSRSF:8	;
	BEQ	PBHC_2			; BR. IF NOT HALF OPEN ON
	JSR	@PBCL1			; CLOSE PAPER BAIL (HALF OPEN)
	BNE	PBHC_2			; BR. IF COMMAND CANCEL
	BCLR.B	#QHOPON,@HSRSF:8	; RESET HALF OPEN FLAG ON
	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
PBHC_2:	RTS

;
;	CHECK CONDITION FOR PAPER HOTCHKISS (& SF-261 ATTACHED)
;
;	IN	NONE
;
;	OUT	R3 : NOT CHNAGED
;		FP : NOT CHANGE
;		 Z : 0=COMMAND CANCEL
;
PHCHK:	JSR	@CRCHK			; CHECK CR MOVE CONDITION
	MOV.W	@LFPC:8,R0		; GET LF POSITION
	CMP.W	#ZLFP3,R0		;
	BCS	LFF3			; BR IF BEFORE HALF OPEN POSITION
;+	SUB.W	@LFPH:8,R0		;
	BCS	LFF3			;
	CMP.W	#ZLFP7,R0		;
	BCS	LFF3			; BR IF NOT HALF OPEN INTERVAL
	JSR	@PBOP			; OPEN PAPER BAIL
	MOV.W	R2,@-SP			; SAVE FEED COUNT
	MOV.W	#50/ZTI,R2		;
	WAITSK				; DELAY 0.5mS
	MOV.W	@SP+,R2			; UNSAVE FEED COUNT
	JSR	@PBCL			; CLOSE PAPER BAIL
	BNE	PHCH_1			; BR IF FEED CANCEL
	BSR	LFF3			; FEED FORWARD
	MOV.W	@LFPC:8,R0		;
PHCH_1:	BTST.B	#QCCAND,@PRLFF:8	; CHECK COMMAND CANCEL STATUS
	RTS				;
	.PAGE
;
;	EJECT FORMS
;
;	IN	R2 : FORMS ESCAPE TYPE
;
;	OUT	 Z : 0=COMMAND CANCEL
;
EJCFRM:	BSR	WTACTF			; WAIT SLAVE CPU ACTION END
	JSR	@SELPMF			; SELECT FORMS MODE
	BSR	HSOPEN			; OPEN HEAD SHIFT
	JSR	@CRHM			; MOVE CR TO HOME
	BSR	EJCF_5			; EJECT FORMS
	BNE	EJCF_4			; BR IF COMMAND CANCEL
	JSR	@RETPM			; RETURN PAPER MODE
	JSR	@LVPM			; CHANGE LEVER BY PAPER MODE
	BTST.B	#QJAME,@ERRSF:8		; RESET JECET JAM STATUS
	BEQ	EJCF_2			; BR IF NOT EJECT ERROR
	MOV.W	@LFPC:8,R0		;
	SUB.W	R2,R0			; UPDATE LF POSITION COUNTER
	BCC	EJCF_3			;
EJCF_2:	CLR.W	R0			;
EJCF_3:	MOV.W	R0,@LFPC:8		;
	MOV.W	R0,@LFPS:8		;
	RTS				;
					;
EJCF_4:	JSR	@RETPM			; RETURN PAPER MODE
	MOV.B	#1,R0			; RESET Z-FLAG FOR CANCEL
	RTS				;
	;
EJCF_5:	BTST.B	#QFPES,@SNSF:8		;
	BNE	EJCF_7			; BR IF SENSOR PE
	JSR	@GETEJF			; CALCULATE EJECT FEED COUNT
	BEQ	EJCF_6			; BR IF ALREADY EJECT DONE
	JSR	@LVFM			; CHANGE LEVR TO FORMS SIDE
	JMP	@EJCF			; SEND FORMS EJECT COMMAND
					;
EJCF_6:	JSR	@LVSH			; CHANGE LEVER TO SHEET SIDE
	JMP	@EJCF			; SEND FORMS EJECT COMMAND
					;
EJCF_7:	JSR	@LVFM			; CHANGE LEVR TO FORMS SIDE
	JMP	@ESCF			; SEND FORMS ESCAPE COMMAND
	.PAGE
;
;	EJECT BOTTOM
;
;	IN	NONE
;
;	OUT	 Z : 0=COMMAND CANCEL
;
EJCBTM:	JSR	@SELPMB			; SELECT BOTTOM MODE
	BSR	HSOPEN			; OPEN HEAD SHIFT
	JSR	@CRHM			; MOVE CR TO HOME
	JSR	@LVSH			; CHANGE LEVER TO SHEET SIDE
	BTST.B	#QBPES,@SNSF:8		;
	BEQ	EJCB_2			; BR IF SENSOR PE
	JSR	@EJCB			; SEND BOTTOM EJECT COMMAND
	BRA	EJCS_3			;

EJCB_2:	JSR	@GETEJB			;
	JSR	@LFFW			; SEND FORWARD FEED COMMAND
	BNE	EJCB_4			; BR IF COMMAND CANCEL
	BCLR.B	#QJAME,@ERRSF:8		; RESET EJECT JAM STATUS
	MOV.W	#ZNN,@BOPC:8		; RESET OVER PE COUNTER
	CLR.W	R2			; SET Z-FLAF FOR NOT CANCEL
	BRA	EJCS_3			;

EJCB_4:	RTS				;
;
;	EJECT SHEET/ACSF
;
;	IN	NONE
;
;	OUT	 Z : 0=COMMAND CANCEL
;
EJCSHT:	BSR	WTACTF			; WAIT SLAVE CPU ACTION END
	JSR	@SELPMS			; SELECT SHEET MODE
	BSR	PBHOC1			; CLOSE PAPER BAIL AT HALF OPEN
	BSR	HSOPEN			; OPEN HEAD SHIFT
	JSR	@CRHM			; MOVE CR TO HOME
	JSR	@LVSH			; CHANGE LEVER TO SHEET SIDE
	BTST.B	#QSPES,@SNSF:8		;
	BEQ	EJCS_6			; BR IF SENSOR PE
	JSR	@GETEJS			;
	BNE	EJCS_1			; BR IF NOT EJECT DONE
	MOV.W	R3,@-SP			;
	MOV.W	#ZLFP2-ZLFPC,R3		; SET PAPER BAIL PASS POSITION
	BSR	INSSHT:16		; INSERT SHEET
	MOV.W	@SP+,R3			;
	BCLR.B	#QJAMI,@ERRSF:8		; RESET INSERT JAM STATUS
EJCS_1:	MOV.W	#ZLFP2,R2		;
	SUB.W	@LFPC:8,R2		;
	BLS	EJCS_2			; BR IF AFTER PAPER BAIL PASS
	BSR	LFFWD			; FEED FOR PAPER BAIL PASS
EJCS_2:	JSR	@EJCS			; SEND SHEET EJECT COMMAND
EJCS_3:	BNE	EJCS_5			; BR IF COMMAND CANCEL
	JSR	@RETPM			; RETURN PAPER MODE
	JSR	@LVPM			; CHANGE LEVER BY PAPER MODE
	BTST.B	#QJAME,@ERRSF:8		; CHECK EJECT RESULT
	BEQ	EJCF_2			; BR IF NOT EJECT ERROR
	ADD.W	@LFPC:8,R2		;
	BCC	EJCS_4			; BR IF NOT OVERFLOW
	MOV.W	#ZNN,R2			;
EJCS_4:	MOV.W	R2,@LFPC:8		; UPDATE LF POSITION COUNTER
	MOV.W	R2,@LFPS:8		;
	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
	RTS				;
					;
EJCS_5:	JSR	@RETPM			; RETURN PAPER MODE
	MOV.B	#1,R0			; RESET Z-FLAG FOR CANCEL
	RTS				;

EJCS_6:	JSR	@GETEJS			;
	JSR	@LFFW			; SEND FORWARD FEED COMMAND
	BNE	EJCS_8			; BR IF COMMAND CANCEL
	BCLR.B	#QJAME,@ERRSF:8		; RESET EJECT JAM STATUS
	MOV.W	#ZNN,@SOPC:8		; RESET OVER PE COUNTER
	CLR.W	R2			; SET Z-FLAF FOR NOT CANCEL
	BRA	EJCS_3			;

EJCS_8:	RTS				;
	.PAGE
;
;	INITIALIZE SHEET/ACSF
;
;	IN	R3 : LF POSITION
;
;	OUT	 Z : 0=COMMAND CANCEL
;
INISHT:	BSR	SETLFP			; SET LF POSITION COUNTER
	BSR	WTACTF			; WAIT SLAVE CPU ACTION END
	JSR	@SELPMS			; SELECT SHEET MODE
	BSR	HSOPEN			; OPEN HEAD SHIFT
	JSR	@LVSH			; CHANGE LEVER TO SHEET SIDE
	CLR.W	FP			;
	BTST.B	#QSPES,@SNSF:8		;
	BEQ	INIS_2			; BR IF SENSOR PE
	MOV.W	@LFPC:8,R2		; GET LF POSITION
	CMP.W	#ZLFP2,R2		;
	BCC	INIS_2			; BR IF AFTER PAPER BAIL PASS
	SUB.W	#ZLFP1,R2		;
	BLS	INIS_1			; BR IF LF POSITION =< 0.5 INCH
	ADD.W	#ZBLN1,R2		; ADD FEED COUNT FOR 6/360 INCH
	JSR	@LFRW			; FEED TO 0.5 INCH POSITION
	MOV.W	#ZLFP1,R0		;
	SUB.W	#ZBLN1,R0		;
	MOV.W	R0,@LFPC:8		; UPDATE LF POSITION COUNTER
INIS_1:	BSR	INIS_3			; OPEN PAPER BAIL
	MOV.W	@LFPC:8,R0		;
	MOV.W	R2,@LFPC:8		; UPDATE LF POSITION COUNTER
	SUB.W	R0,R2			; CALCULATE BAIL PASS FEED COUNT
	MOV.W	R2,FP			;
	BSR	INIS_4			; FEED FORWARD AND CLOSE PAPER BAIL
INIS_2:	MOV.W	@EEPBF+E2INS0,R2	; GET INSERT FEED COUNT
	SUB.W	FP,R2			;
	JSR	@LFFW			; FEED FORWARD
	BSR	INIS_3			; OPEN PAPER BAIL
	SUB.W	#ZLFPC,R2		; CALCULATE PAPER BAIL PASS FEED COUNT
	BSR	INIS_4			; FEED FORWARD AND CLOSE PAPER BAIL
	BRA	EJCS_2			; EJECT SHEET
	;
INIS_3:	JSR	@PBOP			; OPEN PAPER BAIL
	MOV.W	#300/ZTI,R2		;
	WAITSK				; DELAY 0.3 SEC.
	MOV.W	#ZLFP2,R2		;
	RTS				;
					;
INIS_4:	JSR	@LFFW			; FEED FORWARD
	JMP	@PBCL			; CLOSE PAPER BAIL
	.PAGE
;
;	SEND FORMS INSERT COMMAND
;
;	IN	R3 : TOP MARGIN
;
;	OUT	 Z : 0=COMMAND CANCEL
;
INSFRM:	BSR	WTACTF			; WAIT SLAVE CPU ACTION END
	BTST.B	#QFPES,@SNSF:8		;
	BNE	INSS_1			; BR IF ALREADY FORMS PRESENT
	BSR	HSOPEN			; OPEN HEAD SHIFT
	JSR	@CRHM			; MOVE CR TO HOME POSITION
	MOV.W	#INSF,R1		; SET FORMS INSERT ENTRY
	MOV.W	@EEPBF+E2INF,R2		; GET FORMS INSERT FEED COUNT
	BRA	INSCMD			; INSERT FORMS

;
;	SEND SHEET INSERT COMMAND
;
;	IN	R3 : TOP MARGIN
;
;	OUT	 Z : 0=COMMAND CANCEL
;
INSSHT:	BSR	WTACTF			; WAIT SLAVE CPU ACTION END
	BSR	PBHOC1			; CLOSE PAPER BAIL AT HALF OPEN
	BSR	HSOPEN			; OPEN HEAD SHIFT
	JSR	@CRHM			; MOVE CR TO HOME POSITION
	MOV.W	@EEPBF+E2INS0,R2	; GET INSERT FEED COUNT
	MOV.W	#INSS_3,R1		; SET SHEET INSERT ENTRY
	BSR	INSCMD			; INSERT SHEET
	BNE	INSS_2			; BR IF COMMAND CANCEL
	BCLR.B	#QJAMI,@ERRSF:8		; RESET INSERT JAM STATUS
INSS_1:	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
INSS_2:	RTS				;
	;
INSS_3:	JSR	@LFFW			; INSERT SHEET
	BNE	INSS_2			; BR IF COMMAND CANCEL
	BTST.B	#QSPES,@SNSF:8		;
	BEQ	INSS_4			; BR IF SENSOR PE
	BCLR.B	#QJAMI,@ERRSF:8		; RESET INSERT JAM STATUS
	BRA	INSS_1			;
					;
INSS_4:	BSET.B	#QJAMI,@ERRSF:8		; SET INSERT JAM STATUS
	BRA	INSS_1			;
	.PAGE
					;
INSLF:	MOV.W	#LFFW,R1		; SET INSERT ENTRY
INSCMD:	BTST.B	#QPMDG2,@HSRSF:8	;
	BNE	INSC_8			; BR. IF PAPER MODE GROUP 2
	CMP.W	#ZLF3P2-ZLFPC,R3	;
	BCS	INSC_1			; BR IF NOT PAPER BAIL PASS
INSC_5:	ADD.W	#ZLF3P1-ZLFPC,R2	;
	JSR	@R1			; SEND INSERT COMMAND
	BNE	INSC_4			; BR IF COMMAND CANCEL
	BTST.B	#QJAMI,@ERRSF:8		;
	BNE	INSC_3			; BR IF INSERT ERROR
	MOV.W	#ZLF3P1,@LFPC:8		; SET LF POSITION COUNTER
	MOV.W	#ZLF3P1,@LFPS:8		; SET LF POSITION COUNTER SAVE (SHEET)
	MOV.W	R3,R2			; GET TOP MARGIN
	SUB.W	#ZLF3P1-ZLFPC,R2	;
	BRA	LFFWD			; FEED TO TOP POSITION

INSC_8:	CMP.W	#ZLFP2-ZLFPC,R3		;
	BCS	INSC_1			; BR IF NOT PAPER BAIL PASS
	ADD.W	#ZLFP1-ZLFPC,R2		;
	JSR	@R1			; SEND INSERT COMMAND
	BNE	INSC_4			; BR IF COMMAND CANCEL
	BTST.B	#QJAMI,@ERRSF:8		;
	BNE	INSC_3			; BR IF INSERT ERROR
	MOV.W	#ZLFP1,@LFPC:8		; SET LF POSITION COUNTER
	MOV.W	#ZLFP1,@LFPS:8		; SET LF POSITION COUNTER SAVE (SHEET)
	MOV.W	R3,R2			; GET TOP MARGIN
	SUB.W	#ZLFP1-ZLFPC,R2		;
	BRA	LFFWD			; FEED TO TOP POSITION
					;
INSC_1:	ADD.W	R3,R2			; CALCULATE INSERT FEED COUNT
	JSR	@R1			; SEND INSERT COMMAND
	BNE	INSC_4			; BR IF COMMAND CANCEL
	BTST.B	#QJAMI,@ERRSF:8		;
	BNE	INSC_3			; BR IF INSERT ERROR
INSC_2:	ADD.W	#ZLFPC,R3		; ADD LF POSITION COUNT BASE
	BCC	INSC_7			; BR. IF NOT OVERFLOW
	MOV.W	#ZNN,R3			;
INSC_7:	MOV.W	R3,@LFPC:8		; SET LF POSITION COUNTER
	MOV.W	R3,@LFPS:8		; SET LF POSITION COUNTER SAVE (SHEET)
	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
	RTS				;
					;
INSC_3:	CLR.W	R3			;
	MOV.W	R3,@LFPC:8		; RESET LF POSITION COUNTER
	MOV.W	R3,@LFPS:8		; RESET LF POSITION COUNTER SAVE (SHEET)
INSC_4:	RTS				;
	.PAGE
;
;	SEND SF-260 INSERT COMMAND
;
;	IN	R3 : TOP MARGIN
;
;	OUT	 Z : 0=COMMAND CANCEL
;
INS260:	BSR	INSEJC			; EJECT BEFORE INSERT
	BCS	INSSHT			; BR IF SHEET INTERRUPT
	BNE	INS2_6			; BR IF EJECT ERROR
	MOV.W	#ACFTB,FP		; GET SF-260 INSERT FEED COUNT TABLE
	JSR	@SETLF2			; SET LF SPEED 2
	MOV.W	@FP,R2			; GET INSERT FEED COUNT 1
	JSR	@INS2			; GET SHEET FROM HOPPER
	BNE	INS2_5			; BR IF COMMAND CANCEL
	BTST.B	#QJAMI,@ERRSF:8		;
	BNE	INS2_3			; BR IF INSERT ERROR
	JSR	@SETLF3			; SET LF SPEED 3
	MOV.W	@(2,FP),R2		; GET INSERT FEED COUNT 2
	JSR	@LFRW			; PUSH SHEET
	MOV.W	#300/ZTI,R2		;
	WAITSK				; DELAY 0.3 SEC.
	BTST.B	#QSPES,@SNSF:8		;
	BEQ	INS2_2			; BR IF SENSOR PE
	JSR	@SETLF2			; SET LF SPEED 2
	MOV.W	@EEPBF+E2INA0,R2	; GET SF-260 INSERT FEED COUNT
INS2_1:	BSR	INSLF			; INSERT SHEET
	BTST.B	#QSPES,@SNSF:8		;
	BNE	INS2_3			; BR IF NOT SENSOR PE
	MOV.W	@SOPC:8,R0		; GET OVER PE COUNT
	CMP.W	@EEPBF+E2OPCS,R0	;
	BCS	INS2_3			; BR IF PE COUNT 1 > OPC
INS2_2:	BSET.B	#QJAMI,@ERRSF:8		; SET INSER ERROR
INS2_3:	JSR	@SETLF1			; SET LF SPEED 1
	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
	RTS				;
					;
INS2_4:	MOV.W	@SP+,R2			; ADJUST STACK
INS2_5:	JSR	@SETLF1			; SET LF SPEED 1
	MOV.B	#1,R0			; RESET Z-FLAG FOR CANCEL
INS2_6:	RTS				;
	.PAGE
;
;	EJECT BEFOR ACSF INSERT
;
;	IN	NONE
;
;	OUT	R3 : NOT CHNAGE
;		 C : 1=SHHET INTERRUPT
;		 Z : 0=EJECT ERROR
;
INSEJC:	BSR	WTACTF			; WAIT SLAVE CPU ACTION END
	BSR	PBHOC1			; CLOSE PAPER BAIL AT HALF OPEN
	BTST.B	#QSPES,@SNSF:8		;
	BEQ	INSE_1			; BR IF SENSOR PE
	JSR	@GETEJS			;
	BNE	INSE_1			; BR IF NOT EJECT DONE
	MOV.B	#1,R0			;
	SHLR	R0			; SET C=1, Z=1 FOR SHEET INTERRUPT
	RTS				;

INSE_1:	BSR	HSOPEN			; OPEN HEAD SHIFT
	JSR	@CRHM			; MOVCE CR TO HOME
	JSR	@EJCA			; EJECT ACSF
	BSR	WTACTF			; WAIT SLAVE CPU ACTION END
	BNE	INSE_2			; BR IF COMMAND CANCEL
	CLR.W	R0			; RESET C-FLAG
	BTST.B	#QJAME,@ERRSF:8		; CHECK EJECT JAM
	RTS				;
					;
INSE_2:	CLR.W	R0			; RESET C-FLAG
	MOV.B	#1,R0			; RESET Z-FLAG FOR CANCEL
INSE_3:	RTS				;
	.PAGE
;
;	SEND MULTI BIN ACSF INSERT COMMAND
;
;	IN	R3 : TOP MARGIN
;
;	OUT	 Z : 0=COMMAND CANCEL
;
INSAF1:	BSR	INSEJC			; EJECT BEFORE INSERT
	BCS	INSSHT			; BR IF SHEET INTERRUPT
	BNE	INSE_3			; BR IF EJECT ERROR
	MOV.W	#ACFTB1,FP		; GET ACSF1 INSERT FEED COUNT TABLE
	MOV.W	@EEPBF+E2INA1,R2	; GET BIN 1 INSERT FEED COUNT
	BRA	INSAF			; FEED TO TOF POSITION

INSAF2:	BSR	INSEJC			; EJECT BEFORE INSERT
	BCS	INSSHT			; BR IF SHEET INTERRUPT
	BNE	INSE_3			; BR IF EJECT ERROR
	MOV.W	#ACFTB2,FP		; GET ACSF2 INSERT FEED COUNT TABLE
	MOV.W	@EEPBF+E2INA2,R2	; GET BIN 2 INSERT FEED COUNT
	BRA	INSAF			; FEED TO TOF POSITION

INSAF3:	BSR	INSEJC			; EJECT BEFORE INSERT
	BCS	INSSHT			; BR IF SHEET INTERRUPT
	BNE	INSE_3			; BR IF EJECT ERROR
	MOV.W	#ACFTB3,FP		; GET ACSF3 INSERT FEED COUNT TABLE
	MOV.W	@EEPBF+E2INA3,R2	; GET BIN 3 INSERT FEED COUNT
	BRA	INSAF			; FEED TO TOF POSITION

INSAF4:	BSR	INSEJC			; EJECT BEFORE INSERT
	BCS	INSSHT			; BR IF SHEET INTERRUPT
	BNE	INSE_3			; BR IF EJECT ERROR
	MOV.W	#ACFTB4,FP		; GET ACSF4 INSERT FEED COUNT TABLE
	MOV.W	@EEPBF+E2INS1,R2	; GET MANUAL BIN INSERT FEED COUNT
INSAF:	MOV.W	R2,@-SP			;
	JSR	@SETLF4			; SET LF SPEED 4
	MOV.W	@FP,R2			; GET INSERT FEED COUNT 1
	JSR	@LFRW			; SELECT ACSF BIN
	BNE	INS2_4			; BR IF COMMAND CANCEL
	MOV.W	@(2,FP),R2		; GET INSERT FEED COUNT 2
	JSR	@INSA			; GET SHEET FROM HOPPER
	MOV.W	@(4,FP),R2		; GET INSERT FEED COUNT 3
	JSR	@LFRW			; RESET BIN SELECT
	MOV.W	@SP+,R2			; UNSAVE INSERT FEED COUNT
	BTST.B	#QJAMI,@ERRSF:8		; SET INSER ERROR
	BEQ	INS2_1			; BR IF NOT INSERT ERROR
	JSR	@SETLF1			; SET LF SPEED 1
	MOV.W	#ZIAN2,R2		; RESET CLUTCH
	JSR	@LFFW			; FORWARD FEED
	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
	RTS				;
	.PAGE
;
;	SET UP FOR PRINT START
;
;	IN	FP : PRINT COMMAND BUFFER POINTER
;
;	OUT	FP : NOT CHANGE
;
SETPRT:	BTST.B	#QPSNC,@FP		;
	BNE	SETPRS			; BR IF PRINT SPEED NOT CHNAGE
	BTST.B	#Q7PP,@FP		;
	BNE	SETPSD			; BR IF COPY ENHANCE 2 PASS PRINT
	BTST.B	#QDOVR,@FP		;
	BNE	SETPSD			; BR IF DUTY OVER 2 PASS PRINT
	BTST.B	#QPSD,@(YPCDPI,FP)	;
	BNE	SETPSD			; BR IF PRINT SPEED D
	BTST.B	#QHSMM,@HSRSF:8		;
	BNE	SETPSC			; BR IF HEAD SHIFT MANUAL MODE
	BTST.B	#QHSNZ,@HSRSF:8		;
	BNE	SETPSC			; BR IF HEAD SHIFT Nz OVER
SETPRS:	MOV.B	@(YPCDPI,FP),R0		; GET PRINT SPEED MODE
	BTST.B	#QPSD,R0		;
	BNE	SETPSD			; BR IF PRINT SPEED D
	BTST.B	#QPSC,R0		;
	BNE	SETPSC			; BR IF PRINT SPEED C
	BTST.B	#QPSB,R0		;
	BNE	SETPSB			; BR IF PRINT SPEED B
	MOV.W	#PRTTB1,R2		; GET PRINT SPEED/TIMER TABLE
	BRA	SETP_1			;

SETPSB:	MOV.W	#PRTTB2,R2		; GET PRINT SPEED/TIMER TABLE
	BRA	SETP_1			;

SETPSC:	MOV.W	#PRTTB3,R2		; GET PRINT SPEED/TIMER TABLE
	BRA	SETP_1			;

SETPSD:	MOV.W	#PRTTB4,R2		; GET PRINT SPEED/TIMER TABLE
SETP_1:	BSET.B	#QPFMT,@FP		; SET PHYSICAL FORMAT
	BNE	SETP_4			; BR IF ALREADY PHYSICAL FORMAT
	MOV.B	@(YPCDPI,FP),R0		;
	AND.W	#ZDPMSK,R0		; GET PRINT DPI NO.
	MOV.B	@(PCLMTB,R0),R1		; GET PRINT COLUMN UNIT
	MOV.W	R2,R5			;
	SHLL.W	R0			; PRINT PITCH NO. x 2
	SHLL.W	R0			; PRINT PITCH NO. x 4
	ADD.W	R0,R2			; CALCULATE PRINT SPEED TABLE POINTER
	SHLL.W	R0			; PRINT PITCH NO. x 8
	ADDS.B	#4*4,R5			; ADD PRINT TIMER TABLE OFFSET
	ADD.W	R0,R5			; CALCULATE PRINT TIMER TABLE POINTER
	MOV.W	R5,@(YPCPTP,FP)		; SAVE PRINT TIMER TABLE POINTER
	MOV.W	@EEPBF+E2PRSP,R4	; GET PRINT START COLUMN
	CLR.W	R5			;
	MOV.B	@(YPCFC,FP),R5		; GET PRINT FIELD COUNT
	ADD.W	#-1,R5			; ADJUST FOR LOOP
	MOV.W	FP,@-SP			;
	ADDS.B	#YPCFLD,FP		; GET PRINT FIELD POINTER
SETP_2:	MOV.W	R2,R0			; GET PRINT SPEED TABLE BASE
	ADDS.B	@FP,R0			;
	MOV.B	@R0,R0			;
	MOV.B	R0,@FP+			; COVERT PRINT SPEED NO. TO FLAG BIT
	MOV.B	@(1,FP),R0		; GET LEFT COLUMN
	SWAP	R0			;
	MOV.B	@FP,R0			;
	ADD.W	R4,R0			; ADD PRINT BASE COLUMN
	MOV.B	R0,@FP+			; CONVERT LOGICAL TO PHYSICAL COLUMN
	SWAP	R0			;
	MOV.B	R0,@FP+			;
	MOV.B	@(1,FP),R0		; GET RIGHT COLUMN
	SWAP	R0			;
	MOV.B	@FP,R0			;
	MOV.W	R0,R3			; SAVE RIGHT COLUMN
	ADD.W	R4,R0			; ADD PRINT BASE COLUMN
	SUBS.B	R1,R0			; ADJUST 1 COLUMN UNIT
	MOV.B	R0,@FP+			; CONVERT LOGICAL TO PHYSICAL COLUMN
	SWAP	R0			;
	MOV.B	R0,@FP+			;
	SCB/F	R5,SETP_2		;
	MOV.B	@(-YPCSZ,FP),R0		;
	BPL	SETP_3			; BR IF NOT 3.O PRINT SPEED
	CMP.W	#ZP3MAX,R3		;
	BLS	SETP_3			; BR IF NOT MAX OVER
	MOV.B	@(2,R2),R0		;
	MOV.B	R0,@(-YPCSZ,FP)		; SET 2.0 PRINT SPEED
SETP_3:	MOV.W	@SP+,FP			; UNSAVE PRINT COMMAND BUFFER POINTER
	MOV.W	R3,@(YPCMAX,FP)		; SET MAX PRINT COLUMN
	BSR	SETPRD			; SET PRINT DIRECTION
	BTST.B	#QPRSA,@FP		;
	BEQ	SETP_4			; BR IF NOT PHYSICAL RIBBON ADDRESS
	MOV.B	@(YPCRSA,FP),R1		; GET RIBBON SHIFT ADDRESS
	JSR	@RSADJ			; ADJUST RIBBON SHIFT ADDRESS
	MOV.B	R1,@(YPCRSA,FP)		; SET NEW RIBBON SHIFT ADDRESS
SETP_4:	BSR	WTPRTF			; WAIT PREVIOUS PRINT END
	MOV.B	@(YPCDPI,FP),R0		;
	AND.W	#ZDPMSK,R0		; GET PRINT DPI NO.
	MOV.B	@(PDPITB,R0),R1		;
	MOV.B	R1,@(YPCPIT,FP)		; SET PRINT PITCH FLAG
	MOV.B	R1,@PITCNT		; SET PRINT PITCH TO GA
	MOV.B	R1,@DPR			;
	CLR.W	R1			;
	MOV.B	@(PGAPTB,R0),R1		; GET PRINT HEAD GAP COUNT
	MOV.W	@(YPCBLP,FP),R2		; GET PRINT BUFFER LEFT POINTER
	BCLR.W	#QMSBW,R2		; CONVERT PRINT BUFFER RAM ADDRESS
	MOV.B	R2,@BSP0		; SET PRINT BUFFER LEFT POINTER
	SWAP	R2			;
	MOV.B	R2,@BSP1		;
	SWAP	R2			;
	SUB.W	R1,R2			; ADJUST POINTER FOR HEAD GAP
	MOV.B	R2,@BSP2		; SET PRINT BUFFER LEFT POINTER
	SWAP	R2			;
	MOV.B	R2,@BSP3		;
	MOV.W	@(YPCBRP,FP),R2		; GET PRINT BUFFER RIGHT POINTER
	BCLR.W	#QMSBW,R2		; CONVERT TO PRINT BUFFER RAM ADDRESS
	ADD.W	#-1,R2			; ADJUST POINTER FOR REVERSE PRINT
	MOV.B	R2,@BEP0		; SET PRINT BUFFER RIGHT POINTER
	SWAP	R2			;
	MOV.B	R2,@BEP1		;
	SWAP	R2			;
	ADD.W	R1,R2			; ADJUST POINTER FOR HEAD GAP
	MOV.B	R2,@BEP2		;
	SWAP	R2			;
	MOV.B	R2,@BEP3		;
	RTS				;
	.PAGE
;
;	SET PRINT DIRECTION
;
;	IN	FP : PRINT COMMAND BUFFER POINTER
;
;	OUT	FP : NOT CHANGE
;
SETPRD:	MOV.B	@(YPCF2,FP),R1		; GET PRINT OPTION FLAG 2
	MOV.B	#ZPFWD,R0		;
	BTST.B	#QPFWD,R1		;
	BNE	SETP_A			; BR IF FORWARD PRINT
	MOV.B	#ZPREV,R0		;
	BTST.B	#QPREV,R1		;
	BNE	SETP_A			; BR IF REVERSE PRINT
	MOV.B	#ZPBID,R0		;
	BTST.B	#QPSAM,R1		;
	BEQ	SETP_A			; BR IF LOGICAL SEEK PRINT
	MOV.B	#ZPSAM,R0		;
	BTST.B	#Q7PP,@FP		;
	BEQ	SETP_A			; BR IF NOT COPY ENHANCE PRINT
SETP_C:	MOV.B	#ZPFWD,R0		; GET FORWARD PRINT
	BTST.B	#QPRFWD,@PRLFF:8	;
	BEQ	SETP_A			; BR IF BEFORE FORWARD PRINT
	MOV.B	#ZPREV,R0		; GET REVERSE PRINT
SETP_A:	MOV.B	R0,@(YPCCOF,FP)		; SET PRINT DIRECTION
SETP_B:	RTS				;
	.PAGE
;
;	LEVEL 1 PRINT  (PRINT COLOUR CONTROL)
;
;	IN	FP : PRINT COMMAND BUFFER POINTER
;
;	OUT	FP : NOT CHANGE
;		 Z : 0=PRINT CANCEL
;
PRT11:	BTST.B	#QPRSA,@FP		;
	BNE	PRT2L			; BR IF PHYSICAL RIBBON ADDRESS
	MOV.B	@(YPCF2,FP),R0		;
	MOV.B	#ZRBSB,R5		;
	BTST.B	#QRBSB,R0		;
	BNE	PRT1_4			; BR IF BLACK BAND OF COLOUR RIBBON
	BTST.B	#QRBSY,R0		;
	BEQ	PRT1_1			; BR IF NO YELLOW PRINT
	MOV.B	#ZRBSY,R5		;
	AND.B	#XRBSC+XRBSM,R0		;
	BEQ	PRT1_4			; BR IF LAST COLOUR
	BSR	PRT1_5			; PRINT YELLOW
	BNE	SETP_B			; BR IF PRINT CANCEL
	BCLR.B	#QPRSA,@FP		; RESET PHYSICAL RIBBON SHIFT ADDRESS
	MOV.B	@(YPCF2,FP),R0		;
PRT1_1:	BTST.B	#QRBSM,R0		;
	BEQ	PRT1_2			; BR IF NO MAGENTA PRINT
	MOV.B	#ZRBSM,R5		;
	AND.B	#XRBSC,R0		;
	BEQ	PRT1_4			; BR IF LAST COLOUR
	BSR	PRT1_5			; PRINT MAGENTA
	BNE	SETP_B			; BR IF PRINT CANCEL
	BCLR.B	#QPRSA,@FP		; RESET PHYSICAL RIBBON SHIFT ADDRESS
PRT1_2:	MOV.B	#ZRBSC,R5		;
	BRA	PRT1_4			; PRINT CYAN

PRT12:	MOV.B	@(YPCF2,FP),R0		; GET PRINT OPTION FLAG 2
	AND.B	#XRBSB+XRBSY+XRBSC+XRBSM,R0
	MOV.B	#ZRBSR,R5		;
	CMP.B	#XRBSM,R0		;
	BEQ	PRT1_3			; BR IF RED PRINT
PRT13:	MOV.B	#ZRBSS,R5		;
PRT1_3:	BTST.B	#QPRSA,@FP		;
	BNE	PRT2L			; BR IF PHYSICAL RIBBON ADDRESS
PRT1_4:	MOV.B	R5,@(YPCRSA,FP)		; SET RIBBON SHIFT BAND NO.
	BRA	PRT2L			; PRINT OUT BUFFER
					;
PRT1_5:	MOV.B	R5,@(YPCRSA,FP)		; SET RIBBON SHIFT BAND NO.
;	BRA	PRT2			;
	.PAGE
;
;	LEVEL 2 PRINT  (PRINT PASS CONTROL)
;
;	IN	FP : PRINT COMMAND BUFFER POINTER
;
;	OUT	FP : NOT CHANGE
;		 Z : 0=PRINT CANCEL
;
PRT2:	BTST.B	#Q7PP,@FP		;
	BEQ	PRT2_1			; BR IF NOT COPY ENHANCE PRINT
	BSR	PRT3			; BR IF COPY ENHANCE 1 ST PASS
	BNE	PRT4E			; BR IF PRINT CANCEL
	MOV.B	#ZPBID,R0		;
	BSR	SETP_A			; SET ORIGINAL PRINT DIRECTION
	BSR	PRT3			; PRINT COPY ENHANCE 2ND PASS
	BNE	PRT4E			;
	BSR	SETP_C			; SET NEXT PRINT DIRECTION
	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
	RTS
					;
PRT2_1:	BTST.B	#QDBSP,@FP		;
	BEQ	PRT3			; BR IF NOT DOUBLE STRIKE PRINT
	BSR	PRT3			; PRINT DOUBLE STRIKE 1ST PASS
	BNE	PRT4E			; BR IF PRINT CANCEL
	BRA	PRT3			; PRINT DOUBLE STRIKE 2ND PASS

PRT2L:	BTST.B	#Q7PP,@FP		;
	BEQ	PRT2_2			; BR IF NOT COPY ENHANCE PRINT
	BSR	PRT3			; BR IF COPY ENHANCE 1 ST PASS
	BNE	PRT4E			; BR IF PRINT CANCEL
	MOV.B	#ZPBID,R0		;
	BSR	SETP_A			; SET ORIGINAL PRINT DIRECTION
	BSR	PRT3L			; PRINT COPY ENHANCE 2ND PASS
	BNE	PRT4E			;
	BSR	SETP_C			; SET NEXT PRINT DIRECTION
	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
	RTS
					;
PRT2_2:	BTST.B	#QDBSP,@FP		;
	BEQ	PRT3L			; BR IF NOT DOUBLE STRIKE PRINT
	BSR	PRT3			; PRINT DOUBLE STRIKE 1ST PASS
	BNE	PRT4E			; BR IF PRINT CANCEL
;	BRA	PRT3L			; PRINT DOUBLE STRIKE 2ND PASS
	.PAGE
;
;	LEVEL 3 PRINT  (PRINT PASS CONTROL FOR DUTY)
;
;	IN	FP : PRINT COMMAND BUFFER POINTER
;
;	OUT	FP : NOT CHANGE
;		 Z : 0=PRINT CANCEL
;
PRT3L:	MOV.B	#ZPRNP,R3		;
	BTST.B	#QDOVR,@FP		;
	BEQ	PRT4L			; BR IF NOT DUTY OVER PRINT
	MOV.B	#ZPR1P,R3		;
	BSR	PRT4			; PRINT HIGH DUTY 1ST PASS
	BNE	PRT4E			; BR IF PRINT CANCEL
	MOV.B	#ZPR2P,R3		;
	BRA	PRT4L			; PRINT HIGH DUTY 2ND PASS

PRT3:	MOV.B	#ZPRNP,R3		;
	BTST.B	#QDOVR,@FP		;
	BEQ	PRT4			; BR IF NOT DUTY OVER PRINT
	MOV.B	#ZPR1P,R3		;
	BSR	PRT4			; PRINT HIGH DUTY 1ST PASS
	BNE	PRT4E			; BR IF PRINT CANCEL
	MOV.B	#ZPR2P,R3		;
;	BRA	PRT4			; PRINT HIGH DUTY 2ND PASS
	.PAGE
;
;	SEND PRINT COMMAND
;
;	IN	R3 : HEAD OUTPUT CONTROL FLAG
;		FP : PRINT COMMAND BUFFER POINTER
;
;	OUT	FP : NOT CHANGE
;		 Z : 0=PRINT CANCEL
;
PRT4:	BSR	PBHOC			; CLOSE PAPER BAIL AT HALF OPEN
	JSR	@CRCHK			; CHECK PRINT CONDITION
	JSR	@SELPRB			; SELECT PRINT BUFFER
	BNE	PRT4E			; BR IF COMMAND CANCEL
	MOV.B	#QMSB+1,R4		; SET DUMMY BIT NO.
	BRA	PRT4_1			;
					;
PRT4E:	RTS				;

PRT4L:	BSR	PBHOC			; CLOSE PAPER BAIL AT HALF OPEN
	JSR	@CRCHK			; CHECK PRINT CONDITION
	JSR	@SELPRB			; SELECT PRINT BUFFER
	BNE	PRT4E			; BR IF COMMAND CANCEL
	BCLR.B	#QPBDI,@PRBFF:8		; RESET PRINT BUFFER RAM CHANGE DISABLE
	MOV.B	#QPBAB,R4		; SET PRINT BUFFER A BUSY BIT NO.
	BTST.B	#QPBBS,@FP		;
	BEQ	PRT4_1			; BR IF PRINT BUFFER RAM A
	MOV.B	#QPBBB,R4		; SET PRINT BUFFER B BUSY BIT NO.
PRT4_1:	JSR	@UPSEQ			; UPDATE SEQUENCE NO.
	MOV.B	R0,@(YPCFMT,FP)		; SET CMDFMT
	MOV.B	@(YPCFC,FP),R5		; GET NO. OF PRINT FIELD
	MULXU.B	#YPCSZ,R5		; CALCULATE PRINT FIELD SIZE
	ADD.B	#YPCFLD-YPCFMT,R5	; ADD PRINT COMMAND HEADER SIZE
	SWAP	R5			;
	MOV.B	R4,R5			; SET PRINT BUFFER BUSY RESET NO.
	LDC.B	#0,EP			;
	MOV.W	FP,R4			; GET PRINT COMMAND BUFFER POINTER
	ADDS.B	#YPCFMT,R4		; GET TRANSMIT START POINTER
	MOV.W	R3,@-SP			; SAVE HEAD OUTPUT CONTROL FLAG
	MOV.B	@HSRSF:8,R2		; GET RIBBON SHIFT STATUS
	MOV.W	#RBSTB1,R3		;
	MOV.B	@RBSTP:8,R3		; GET RIBBON SHIFT TABLE POINTER
	BTST.B	#QPRSA,@FP		; SET PHYSICAL RIBBON SHIFT ADDRESS
	BNE	PRT4_6			; BR IF ALREADY PHYSICAL RIBBON ADDRESS
	MOV.B	@(YPCRSA,FP),R1		; GET RIBBON BAND NO.
	CMP.B	#ZRBSS,R1		;
	BCC	PRT4_3			; BR IF BLACK RIBBON SHIFT
	EXTU	R1			;
	ADD.W	#RBSTB1,R1		;
	MOV.B	@R1,R1			; CHANGE BAND NO. TO ADDRESS
	BSET.B	#QPRSA,@FP		; SET PHYSICAL RIBBON SHIFT ADDRESS
	BRA	PRT4_5			;
	.PAGE
					;
PRT4_3:	BTST.B	#QRSDN,R2		;
	BNE	PRT4_4			; BR IF RIBBON SHIFT DOWN MODE
	MOV.B	@R3+,R1			; GET RIBBON SHIFT ADDRESS
	BNE	PRT4_5			; BR IF NOT TABLE END
	BSET.B	#QRSDN,R2		; SET RIBBON SHIFT DOWN MODE
	ADD.W	#-2,R3			;
PRT4_4:	MOV.B	@-R3,R1			; GET RIBBON SHIFT ADDRESS
	BNE	PRT4_5			; BR IF NOT TABLE END
	BCLR.B	#QRSDN,R2		; RESET RIBBON SHIFT DOWN MODE
	ADD.W	#2,R3			;
	MOV.B	@R3+,R1			;
PRT4_5:	JSR	@RSADJ			; ADJUST RIBBON SHIFT ADDRESS
	MOV.B	R1,@(YPCRSA,FP)		; SET NEW RIBBON SHIFT ADDRESS
PRT4_6:	MOV.W	@SP+,R0			; UNSAVE HEAD CONTROL FLAG
	JSR	@SENDP			; SEND PRINT COMMAND
	BNE	PRT4E			; BR IF COMMAND CANCEL
	BSET.B	#QPRACT,@PRLFF:8	; SET PRINT ACTIVE
	MOV.B	R2,@HSRSF:8		; UPDATE RIBBON SHIFT STATUS
	MOV.B	R3,@RBSTP:8		; UPDATE RIBBON SHIFT TABLE POINTER
	BNOT.B	#QPBBP,@PRBFF:8		; UPDATE PRINTED BUFFER RAM FLAG
	JSR	@RSMVX			; RESET RIBBON SHIFT POSITION FLAG
	MOV.W	@EEPBF+E2PRSP,R4	; GET PRINT BASE COLUMN
	CMP.W	#ZH,R4			;
	BCC	PRT4_9			; BR IF START COLUMN >= 0100H
	MOV.W	#ZH,R4			; SET START COLUMN = 0100H
PRT4_9:	MOV.W	@(YPCFLD+1,FP),R0	; GET PRINT START COLUMN
	SUB.W	R4,R0			; CALCULATE LOGICAL PRINT COLUMN
	MOV.W	@(YPCMAX,FP),R1		; GET PRINT END COLUMN
	BTST.B	#QPRFWD,@PRLFF:8	;
	BNE	PRT4_A			; BR IF FORWARD PRINT
	XCH	R0,R1			; EXCHANGE START/END COLUMN
PRT4_A:	JSR	@CRMVPR			; UPDATE CR POSITION COUNTER
	MOV.W	@(YPCFC,FP),R0		; GET FIELD COUNT,PRINT SPEED
	MOV.W	@(YPCDOT,FP),R1		; GET PRINT DOT COUNT
	MOV.W	R1,R2			;
	BTST.B	#QDOVR,@FP		;
	BEQ	PRT4_7			; BR IF 1 PASS PRINT
	SHLR.W	R1			; GET 1/2
PRT4_7:	JSR	@UPDOTC			; UPDATE PRINT DOT COUNTER
	ADD.B	#1,@PRTLC:8		; UPDATE PRINT LINE COUNT
	BCC	PRT4_8			;
	ADD.B	#-1,@PRTLC:8		;
PRT4_8:	JSR	@SETECD			; SET PE CHECK DISABLE
	MOV.B	#ZPSAM,R0		;
	MOV.B	R0,@(YPCCOF,FP)		; SET SLOCF FOR SAME DIRECTION PRINT
	MOV.B	#0,R0			; SET Z-FLAG FOR NOT CANCEL
	RTS				;
	.END
