	.PROGRAM	sysios
	.HEADING	"M4324 I/O SYSTEM MODULE"
	.LIST		NOCOND,NOEXP
;********************************************************
;							*
;	M4324 I/O SYSTEM MAIN MODULE			*
;							*
;	FILE NAME	SYSIOS.MAR			*
;	CREATED 	16/JUL/1991			*
;							*
;********************************************************
;
	.EXPORT 	IOSTBL
	.EXPORT 	INTGA, INTER1,INTRX1,INTFAN,INTPNL
	.EXPORT 	CALIOS,INIPNL,SETALM
	.EXPORT 	SCICAL,SCINMI,SCIHSP,SCISNS
	.EXPORT 	SCIADS,SCIADW,SCIVER,SCISTS
	.EXPORT 	SCICAN,SCISTP,SCICLC,SCICLE
	.EXPORT 	SCIADV,SCIPEC,SCILFT,SCIPRA
	.EXPORT 	SCIBDT,SCIDAT,SCIPRT,SCICMD
	.EXPORT 	SWPDI, SWPEN, SWPT1S,SWPT2S
	.EXPORT 	CHKRBW,UPCRDC,UPDOTC,GETDEL,RDHSNT

	.IMPORT 	IOSTCB,IOSSTK,SWPTCB,D3WPKT,SLVVER,SYS$FG
	.IMPORT 	DOTTB1,DOTTB2,DOTTB3,DOTTB4,DOTTB5
	.IMPORT 	BSRTB, HSNTTB,PRATB,PDELTB
	.IMPORT 	INTP0, INTP1, INTACT,INTUSR,INTPON,INTAER
	.IMPORT 	INTACF,INTCVR,INTHSM,INTOPC,INTSNS,ZSWMK
	.IMPORT 	RETOR2,RETIH3,INTTMR,CALTSK,PECOPC
	.IMPORT 	INILCD,INILBF,LCDCAL,LCDCON,LCDDEC,BZOFF, EEWRDI

	.INCLUDE	"COMMON.H"
	.INCLUDE	"M43RTM.H"
	.INCLUDE	"SYSDP3.H"
	.INCLUDE	"ALARM.H"
	.INCLUDE	"SLVRAM.H"
	.INCLUDE	"SLVCMD.H"
	.INCLUDE	"PNLRAM.H"
	.INCLUDE	"GAHEAD.H"
	.INCLUDE	"GAPNL.H"
	.INCLUDE	"GAINT.H"
	.INCLUDE	"GAIFP.H"
	.INCLUDE	"GAIOP.H"
	.INCLUDE	"CPUIO.H"
	.INCLUDE	"ADCNV.H"
	.INCLUDE	"SYSRAM.H"
	.PAGE
;
;	TIMER INTERVAL
;
ZTI1:	.EQU	    5		;   5mS INTFAN INTERRUPT INTERVAL
ZTFON:	.EQU	   15/ZTI1	;  15mS COOLING FAN ON/OFF ON  TIME
ZTFOF:	.EQU	   85/ZTI1	;  85mS COOLING FAN ON/OFF OFF TIME
ZTFSTP: .EQU	   50/ZTI1	;  50mS COOLING FAN STOP WAIT TIME
ZTFCHK: .EQU	  100/ZTI1	; 100mS COOLING FAN CHECK TIME
ZTFANI: .EQU	 2000/ZTI1	;   2S	COOLING FAN INITIAL ON TIME
ZTFAN:	.EQU	80000/ZTI1	;  80S	COOLING FAN ON TIME
				;
ZTI2:	.EQU	   25		;  25mS INTPNL INTERRUPT INTERVAL 1
ZTSWR:	.EQU	  500/ZTI2	; 500mS PANEL SW REPEAT START TIME

ZTI3:	.EQU	 ZTI2*2 	;  50mS INTPNL INTERRUPT INTERVAL 2
ZTSLV:	.EQU	12750/ZTI3	;  12.75S  SLAVE CPU WATCH DOG TIME

;
;	CR DUTY, PRINT DOT DUTY COUNT
;
ZCRMV:	.EQU	     279	; CR PRE. MOVE CHECK DISTANCE
ZCRDV1: .EQU	      10	; CR DUTY VALUE FOR INITIALIZE
ZCRDV2: .EQU	      10	; CR DUTY VALUE FOR MOVE
ZCRDV3: .EQU	      10	; CR DUTY VALUE FOR SKIP
ZCRDV4: .EQU	       8	; CR DUTY VALUE FOR 1.0 PRINT
ZCRDV5: .EQU	      14	; CR DUTY VALUE FOR 1.5 PRINT
ZCRDV6: .EQU	      23	; CR DUTY VALUE FOR 2.0 PRINT
ZCRDV7: .EQU	      29	; CR DUTY VALUE FOR 3.0 PRINT
ZCRDV:	.EQU	     512	; PRINT ENABLE CR DUTY COUNT
ZPRDC:	.EQU	       5	; SAME PATTERN PRINT LINE COUNT FOR DUTY
ZXPRDC: .EQU	       5	; SAME PATTERN PRINT LIMIT LINE COUNT
ZDOTR:	.EQU	      50	; SAME PATTERN CHECK DOT MARGIN RANGE
ZDOTL1: .EQU	 1200000&65535	; PRINT ENABLE DOT COUNT LOW
ZDOTH1: .EQU	 1200000/65536	; PRINT ENABLE DOT COUNT HIGH
ZDOTL2: .EQU	  700416&65535	; PRINT CAUTION DOT COUNT LOW
ZDOTH2: .EQU	  700416/65536	; PRINT CAUTION DOT COUNT HIGH
ZDOTL3: .EQU	 1240000&65535	; PRINT CAUTION DOT COUNT LOW  2
ZDOTH3: .EQU	 1240000/65536	; PRINT CAUTION DOT COUNT HIGH 2

;
;	A/D CONVERTOR CHECK COUNT
;
ZCHDT:	.EQU	 150/ZTI2	; AN0 (150ms) HEAD THERMAL ERROR CHECK COUNT
ZCRB1:	.EQU	6399/ZTI2	; AN1 (6.4S ) RIBBON   1ST ERROR CHECK COUNT
ZCRB2:	.EQU	1000/ZTI2	;     (  1S )	       2ND ERROR CHECK COUNT
ZCFAN:	.EQU	2000/(ZTI1*2)	; AN2 (  2S ) COOLING FAN  ERROR CHECK COUNT
ZCPWR:	.EQU	 150/ZTI2	; AN3 (150mS) POWER SUPPLY ERROR CHECK COUNT
	.PAGE
;	.SECTION	SYSRAM,DUMMY,LOCATE=H'FEC0
;
;	I/O SYSTEM LOCAL AREA
;
	.ORG	H'FEE4
IOSF:	.RES.B	  1			; I/O SYSTEM FLAG
Q10MS:	.EQU	  0			;   1:10mS TIMER FLAG
Q50MS:	.EQU	  1			;   1:50mS TIMER FLAG
QFANCE: .EQU	  2			;   1:COOLING FAN CHECK ENABLE
QDOT4S: .EQU	  3			;   1:SAME PRINT PATTERN CONTINUE
QWSNS:	.EQU	  4			;   1:SENSOR STATUS WAIT
QWHSP:	.EQU	  5			;   1:HEAD SHIFT MOTOR PHASE WAIT
QWADS:	.EQU	  6			;   1:TOP SENSOR A/D PORT STATUS WAIT
QWVER:	.EQU	  7			;   1:VERSION STATUS WAIT

DOTC:	.RES.B	  3			; PRINT DOT COUNTER
CRDC:	.RES.W	  1			; CR DUTY COUNTER
PRTTP:	.RES.W	  1			; PRINT TIMER TABLE POINTER
STSBP:	.RES.B	  1			; SLAVE CPU STATUS BUFFER POINTER
SLVT:	.RES.B	  1			; SLAVE CPU CHECK TIMER COUNTER
FANT:	.RES.W	  1			; COOLING FAN ON/OFF TIMER COUNTER
QFANON: .EQU	  6			;   1:COOLING FAN ON START REQUEST
QFANCK: .EQU	  7			;   1:COOLING FAN CHECK MODE

FANEC:	.RES.B	  1			; COOLING FAN ERROR COUNTER
HDTEC:	.RES.B	  1			; PRINT HEAD THERMAL ERROR COUNTER
PWREC:	.RES.B	  1			; POWER SUPPLY THERMAL ERROR COUNTER
RBMEC:	.RES.B	  1			; RIBBON WIND MOTOR ERROR COUNTER
SWTP:	.RES.W	  1			; PANEL SW TABLE POINTER
SWRP:	.RES.W	  1			; PANEL SW REPEAT TABLE POINTER
SWRT:	.RES.B	  1			; PANEL SW REPEAT TIMER COUNTER
	.RES.B	  4			;
PRBRF:	.RES.B	  1			; PRINT BUFFER BUSY RESET FLAG
	.RES.B	 26			;
PRDLC:	.RES.B	  1			; SAME PATTERN PRINT LINE COUNT
STSBF:	.RES.B	  1			; SLAVE CPU STATUS BUFFER
	.RES.W	  1			;
	.RES.B	  1			;
STSBE:					; SLAVE COU STATUS BUFFER END
	.RES.B	  5			; RESERVED AREA
DOTS:	.RES.W	  1			; PREVIOUS PRINT DOT COUNT SAVE
	.PAGE
	.SECTION	SYS1,CODE,ALIGN=16
;
;	I/O SYSTEM TASK DEFINITION TABLE
;
	.ALIGN		  2
IOSTBL: .DATA.W 	IOSTCB		; TCB
	.DATA.B 	  0		; PRIORITY
	.DATA.B 	ZTIST3		; STATUS
	.DATA.W 	IOSSTK		; STACK
	.DATA.W 	IOSINI		; ENTRY
	.DATA.B 	PAGE IOSINI	; CP
	.DATA.B 	  0		; DP
	.DATA.B 	  0		; EP
	.DATA.B 	ZBR		; BR
	.DATA.W 	  0		; NO MAIL BOX
	.DATA.W 	  0		; NO PACKET
	.PAGE
;
;	I/O EXPANDER GA INTERRUPT HANDLER
;
INTGA:					;
	PUSHDP				;
	LDC.B	#0,DP			;
	MOV.W	R0,@-SP 		;
	MOV.B	@INTREQ,R0		; READ INTERRUPT REQUEST
	BPL	INTSA			; BR IF INT7 (SLVACT)
	SHLL.B	R0			;
	BPL	INTSB			; BR IF INT6 (SLVBSY)
	SHLL.B	R0			;
	BPL	INTSPD			; BR IF INT5 (SPDINT)
	SHLL.B	R0			;
	BPL	INTPB			; BR IF INT4 (PRTBSY)
	SHLL.B	R0			;
	BPL	INTTRS:16		; BR IF INT3 (TRSREQ)
	SHLL.B	R0			;
;	BPL	INTG_?			; BR IF INT2 (NO FUNCTION)
	SHLL.B	R0			;
	BPL	INTG_2			; BR IF INT1 (INPUT PRIME 1)
;	BRA	INTG_1			;

;
;	INPUT PRIME INTERRUPT HANDLER
;
INTG_1: BCLR.B	#QIPRM0,@INTMSK 	; SET INTERRUPT MASK
	JMP	@INTP0			; GOTO INPUT PRIME 0 HANDLER

INTG_2: BCLR.B	#QIPRM1,@INTMSK 	; SET INTERRUPT MASK
	JMP	@INTP1			; GOTO INPUT PRIME 1 HANDLER
	.PAGE
;
;	SLAVE CPU CPNTROL INTERRUPT HANDLER
;
INTSA:	MOV.B	#ZN-XSLACT,@INTDAT	; SLVACT HIGH -> LOW
	MOV.B	R0,@INTRST		; RESET INTERRUPT REQUEST
	MOV.W	R1,@-SP 		;
	MOV.W	FP,@-SP 		;
	JSR	@INTACT 		; CALL ACTION END INTERRUPT HANDLER
	BCLR.B	#QLFACT,@PRLFF:8	; RESET FEED ACTIVE
	MOV.W	#FACTF,R1		; SET ACTION FINISH
	MOV.W	#DP3TCB,FP		;
	JMP	@RETOR2 		; SET EVENT FLAG

INTSB:	MOV.B	#ZN-XSLBSY,@INTDAT	; SLVBSY HIGH -> LOW
	MOV.B	R0,@INTRST		; RESET INTERRUPT REQUEST
	MOV.W	R1,@-SP 		;
	MOV.W	FP,@-SP 		;
	BCLR.B	#QCCANE,@PRLFF:8	; RESET COMMAND CANCEL ENABLE
	MOV.W	#FCMDE,R1		; SET COMMAND TRASNMIT ENABLE
	MOV.W	#DP3TCB,FP		;
	JMP	@RETOR2 		; SET EVENT FLAG

INTPB:	MOV.B	#ZN-XPRBSY,@INTDAT	; PRTBSY HIGH -> LOW
	MOV.B	R0,@INTRST		; RESET INTERRUPT REQUEST
	CLR.B	@OUTC			; SET OUTPUT DISABLE
	MOV.W	R1,@-SP 		;
	MOV.W	FP,@-SP 		;
	MOV.B	#ZCRB1,R0		; GET 1ST ERROR CHECK COUNT
	MOV.B	R0,@RBMEC:8		; RESET RIBBON MOTOR ERROR COUNTER
	BCLR.B	#QPRACT,@PRLFF:8	; RESET PRINT ACTIVE
	MOV.B	@PRBRF:8,R0		;
	BCLR.B	R0,@PRBFF:8		; RESET PRINT BUFFER BUSY
	MOV.W	#FPRTF,R1		; SET PRINT FINISH
	MOV.W	#DP3TCB,FP		;
	JMP	@RETOR2 		; SET EVENT FLAG
	.PAGE
;
;	PRINT SPEED CHANGE INTERRUPT HANDLER
;
INTSPD: MOV.B	#ZN-XSPDIN,@INTDAT	;
	MOV.B	R0,@INTRST		; RESET INTERRUPT REQUEST
	MOV.W	FP,@-SP 		;
	CLR.W	FP			;
	MOV.B	@CTRL,FP		; READ PRINT SPEED
	AND.B	#XSPD3+XSPD2,FP 	;
	SHLR.W	FP			;
	ADD.W	@PRTTP:8,FP		; GET PRINT TIMER TABLE DIRECTORY
	MOV.W	@FP,FP			; GET PRINT TIMER TABLE POINTER
	BTST.B	#QOLDPB,@P5DR		;\\ 920320
	BEQ	INTS_A			;\\
	MOV.W	@FP,R0			;
	MOV.W	R0,@TRA1		; SET TRA1, TRA2
	MOV.W	@(2,FP),R0		;
	MOV.W	R0,@TRA3		; SET TRA3, TRB
	MOV.W	@(4,FP),R0		;
	MOV.W	R0,@TRC 		; SET TRC,  TRD
	BRA	INTS_B			;\\ 920320
;
INTS_A: MOV.W	@(14,FP),R0		;\\
	MOV.W	R0,@TRA1		;\\
	MOV.W	@(16,FP),R0		;\\
	MOV.W	R0,@TRA3		;\\
	MOV.W	@(18,FP),R0		;\\
	MOV.W	R0,@TRC 		;\\
INTS_B: 				;\\
	MOV.B	@(7,FP),R0		;
	MOV.B	R0,@DTR1		; SET DTR1
	MOV.W	@(8,FP),R0		;
	MOV.W	R0,@DTR2		; SET DTR2, DTR3
	MOV.W	@(10,FP),R0		;
	MOV.W	R0,@DTR4		; SET DTR4, DTR5
	MOV.B	@(12,FP),R0		;
	MOV.B	R0,@DTR6		; SET DTR6
	MOV.W	@SP+,FP 		;
	MOV.W	@SP+,R0 		;
	POPDP				;
	RTE				;
	.PAGE

;
;	TRANSMIT REQUEST INTERRUPT HANDLER
;
INTTRS: MOV.B	#ZN-XTRSRQ,@INTDAT	;
	MOV.B	R0,@INTRST		; RESET INTERRUPT REQUEST
	BTST.B	#QMBUSY,@EXPNDB 	;
	BEQ	INTT_2			; BR IF SLAVE CPU PROTOCOL ERROR
	MOV.B	#XRIE+XRE+XCKE0,@SCR1	; SET RECEIVE ENABLE
INTT_1: MOV.W	@SP+,R0 		;
	POPDP				;
	RTE				;
					;
INTT_2: MOV.W	#ZESL1,R0		;
	BSR	SETAL2:16		; SET SLAVE CPU ALARM ERROR
	BRA	INTT_1			;
	.PAGE
;
;	DATA RECEIVE INTERRUPT HANDLER
;
INTER1: 				;
INTRX1: 				;
	PUSHDP				;
	LDC.B	#0,DP			;
	MOV.W	R1,@-SP 		;
	MOV.W	R0,@-SP 		;
	MOV.B	@RDR1,R0		; READ RECEIVE DATA
	MOV.B	#XCKE0,@SCR1		; RESET RECEIVE ENABLE
	MOV.B	@SSR1,R1		; DUMMY READ
	MOV.B	#XTDRE,@SSR1		; RESET INTERRUPT REQUEST
	MOV.W	#STSBF,R1		;
	MOV.B	@STSBP:8,R1		; GET STATUS BUFFER POINTER
	MOV.B	R0,@R1+ 		; SAVE RECEIVE DATA
	CMP.B	#STSBE&ZN,R1		;
	BCS	INTR_1			; BR IF NOT DATA END
	MOV.W	R2,@-SP 		;
	MOV.W	#BSRTB,R2		; GET BIT SEQUENCE REVERSE TABLE
	MOV.W	#STSBF,R1		; GET STATUS BUFFER START POINTER
	MOV.B	@R1+,R2 		;
	MOV.B	@R2,R0			; GET STATUS ADDRESS
	BSR	CHKSTS			; CHECK STATUS
	MOV.B	#XTE+XCKE0,@SCR1	; SET TRANSMIT ENABLE
	MOV.W	@SP+,R2 		;
	MOV.B	#STSBF&ZN,R1		;
INTR_1: MOV.B	R1,@STSBP:8		; UPDATE STATUS BUFFER POINTER
	MOV.W	@SP+,R0 		;
	MOV.W	@SP+,R1 		;
	BNOT.B	#QMARE,@EXPNDB		; OUTPUT RECEIVE READY
	JMP	@RETIH3 		;
	.PAGE
;
;	CHECK SLAVE CPU STATUS
;
;	IN	R0 : STATUS ADDRESS
;		R1 : STATUS VALUE POINTER
;		R2 : BIT SEQUENCE REVERSE TABLE
;
;	OUT	NONE
;
CHKSTS: CMP.B	#TMRCTF,R0		;
	BEQ	CHKS_3			; BR IF SLAVE CPU RUN STATUS
	CMP.B	#SLREV0,R0		;
	BCS	CHKS_4			; BR IF NOT REVISION STATUS
	MOV.W	R3,@-SP 		;
	MOV.W	#SLVVER,R3		;
	CMP.B	#SLREV2,R0		;
	BEQ	CHKS_1			; BR IF 1ST REVISION NO.
	ADDS.B	#4,R3			;
	CMP.B	#SLREV1,R0		;
	BEQ	CHKS_1			; BR IF 2ND REVISION NO.
	ADDS.B	#4,R3			;
	CLR.B	@STSBF+3		;
CHKS_1: MOV.B	@R1+,R2 		;
	MOV.B	@R2,R0			; COPY SLAVE CPU VERSION NO.
	MOV.B	R0,@R3+ 		;
	CMP.B	#STSBE&ZN,R1		;
	BCS	CHKS_1			;
	CMP.W	#SLVVER+11,R3		;
	BEQ	CHKS_2			; BR IF 3RD REVISION NO.
	MOV.B	#".",@R3                ;
CHKS_2: MOV.W	@SP+,R3 		;
	BCLR.B	#QWVER,@IOSF:8		; RESET VERSION STATUS WAIT FLAG
	RTS				;
					;
CHKS_3: MOV.B	#ZTSLV,R0		;
	MOV.B	R0,@SLVT:8		; RESTART SLAVE CPU CHECK TIMER
	RTS				;
					;
CHKS_4: CMP.B	#ADTOPS,R0		;
	BHI	CHKSER			; BR IF INVALID STATUS ADDRESS
	SUB.B	#PRNSF,R0		;
	BCS	CHKSER			; BR IF INVALID STATUS ADDRESS
	MOV.W	@R1,R1			; GET STATUS VALUE
	MOV.B	R1,R2			;
	MOV.B	@R2,R1			; GET STATUS HIGH VALUE
	SWAP	R1			;
	MOV.B	R1,R2			;
	MOV.B	@R2,R1			; GET STATUS LOW VALUE
	MULXU.B #3,R0			;
	JMP	@(CHKS_9:16,R0) 	; CHECK SLAVE CPU STATUS
					;
CHKSER: MOV.W	#ZESL4,R0		;
	BRA	SETAL2:16		; SET SLAVE CPU ALARM ERROR
	.PAGE
					;
CHK1:	MOV.B	R1,@SNSF:8		; SAVE SENSOR STATUS
	BCLR.B	#QWSNS,@IOSF:8		; RESET SENSOR STATUS WAIT FLAG
	JMP	@INTSNS 		; CALL SENSOR STATUS INTERRUPT HANDLER
					;
CHK2:	MOV.B	R1,@HSPS:8		; SAVE HEAD SHIFT MOTOR PHASE STATUS
	BCLR.B	#QWHSP,@IOSF:8		; RESET PHASE STATUS WAIT FLAG
	RTS				;
					;
CHK3:	MOV.W	R1,@HSPC:8		; SAVE HEAD SHIFT POSITION STATUS
	RTS				;
					;
CHK4:	BSET.B	#QHSMV,@ERRSF:8 	; SET HEAD SHIFT MOVE STATUS
	JMP	@INTHSM 		; CALL HEAD SHIFT INTERRUPT HANDLER
					;
CHK5:	BSET.B	#QCCAND,@PRLFF:8	; SET COMMAND CANCEL DONE STATUS
	BCLR.B	#QPRACT,@PRLFF:8	; RESET PRINT ACTIVE
	BTST.B	#QSLACT,@INTPRE 	;
	BNE	CHK5_1			; BR IF SLAVE CPU ACTIVE
	BCLR.B	#QLFACT,@PRLFF:8	; RESET FEED ACTIVE
CHK5_1: RTS				;
					;
CHK6:	BCLR.B	#QLFACT,@PRLFF:8	; RESET FEED ACTIVE
	BSET.B	#QFANON,@FANT:8 	; SET COOLING FAN ON REQUEST
	BTST.B	#QPRFWD,R1		;
	BEQ	CHK6_1			; BR IF REVERSE PRINT
	BSET.B	#QPRFWD,@PRLFF:8	; SET FORWARD PRINT DIRECTION
	RTS				;
					;
CHK6_1: BCLR.B	#QPRFWD,@PRLFF:8	; SET REVERSE PRINT DIRECTION
	RTS				;
	.PAGE
					;
CHK7:	MOV.W	#SOPC,R0		; GET OPC POINTER
	MOV.B	#QSPES,R2		; SET SHEET PE STATUS BIT
CHK7_3: TST.W	R1			;
	BNE	CHK7_1			; BR IF SHEET OPC <> 0
	BTST.B	R2,@SNSF:8		;
	BNE	CHK7_1			; BR IF NOT PE
	ADD.W	#1,R1			; ADJUST SHEET OPC
CHK7_1: BTST.B	#QIGOPC,@PRLFF:8	;
	BNE	CHK5_1			; BR IF IGNORE OPC STATUS
	MOV.B	@PECOPC+1,R2		; GET PE ERROR CHECK OPC LIMIT VALUE
	SWAP	R2			;
	MOV.B	@PECOPC,R2		;
	CMP.W	R2,R1			;
	BCC	CHK5_1			; BR IF OPC AT REVERSE FEED
	TST.W	R1			;
	BEQ	CHK7_2			; BR IF OPC = 0
	CMP.W	#ZNN,@R0		;
	BEQ	CHK5_1			; BR IF EJECTED OPC COUNT
CHK7_2: MOV.W	@R0,R2			; GET OPC STATUS
	MOV.W	R1,@R0			; SAVE OPC STATUS
	JMP	@INTOPC 		; CALL OPC STATUS INTERRUPT HANDLER
					;
CHK8:	MOV.W	#FOPC,R0		; GET OPC POINTER
	MOV.B	#QFPES,R2		; SET FORMS PE STATUS BIT
	BRA	CHK7_3			;
					;
CHK9:	MOV.W	#BOPC,R0		; GET OPC POINTER
	MOV.B	#QBPES,R2		; SET BOTTOM PE STATUS BIT
	BRA	CHK7_3			;
					;
CHKA:	MOV.B	R1,@ADPS:8		; SAVE TOP SENSOR A/D PORT STATUS
	BCLR.B	#QWADS,@IOSF:8		; RESET A/D PORT STATUS WAIT FLAG
	RTS				;
					;
CHKS_9: BRA	CHK1:16 		; C8  SENSOR STATUS
	BRA	CHKER0:16		; C9  ERROR STATUS 0
	BRA	CHKER1:16		; CA  ERROR STATUS 1
	BRA	CHK2:16 		; CB  HEAD SHIFT MOTOR PHASE STATUS
	BRA	CHK3:16 		; CC  HEAD SHIFT MOTOR POSITION STATUS
	BRA	CHKSER:16		; CD
	BRA	CHK4:16 		; CE  HEAD SHIFT MANUAL MOVE STATUS
	BRA	CHK5:16 		; CF  COMMAND ABORT STATUS
	BRA	CHK6:16 		; D0  PRINT DIRECTION STATUS
	BRA	CHKSER:16		; D1
	BRA	CHK7:16 		; D2  SHEET OPC STATUS
	BRA	CHKSER:16		; D3
	BRA	CHK8:16 		; D4  FORMS OPC STATUS
	BRA	CHKSER:16		; D5
	BRA	CHK9:16 		; D6  BOTTOM OPC STATUS
	BRA	CHKSER:16		; D7
	BRA	CHKA:16 		; D8  TOP SENSER A/D PORT STATUS
	.PAGE
;
;	CHECK SLAVE CPU ERROR STATUS
;
;	IN	R1 : ERROR STATUS
;
;	OUT	NONE
;
CHKER0: MOV.B	#ZESPD,R0		;
	BTST.B	#QESPD,R1		;
	BNE	SETAL1			; BR IF CR SPEED ERROR
	MOV.B	#ZEFRM,R0		;
	BTST.B	#QEFRM,R1		;
	BNE	SETAL1			; BR IF FRAME WIDTH ERROR
	MOV.B	#ZEEC,R0		;
	BTST.B	#QECREC,R1		;
	BNE	SETAL1			; BR IF CR ENCODER ERROR
	MOV.B	#ZEHD,R0		;
	BTST.B	#QEHD,R1		;
	BNE	SETAL1			; BR IF HEAD DRIVER ERROR
	MOV.B	#ZETR,R0		;
	BTST.B	#QETR,R1		;
	BNE	SETAL1			; BR IF STEP MOTOR DRIVER ERROR
	MOV.B	#ZEDRV,R0		;
	BTST.B	#QEDRV,R1		;
	BNE	SETAL1			; BR IF CR/LF MOTOR DRIVER ERROR
	RTS				;
					;
CHKER1: MOV.B	#ZEHDS,R0		;
	BTST.B	#QEHSEC,R1		;
	BNE	SETAL1			; BR IF HEAD SHIFT ENCODER ERROR
	BTST.B	#QEHDS,R1		;
	BEQ	CHKE_1			; BR IF NOT HEAD SHIFT ERROR
	BCLR.B	#QHSER,@ERRSF:8 	; SET HEAD SHIFT MOTOR ERROR
	BEQ	SETAL1			; BR IF NO ERROR RETRY
	RTS				;
					;
CHKE_1: MOV.B	#ZERBS,R0		;
	BTST.B	#QERBS,R1		;
	BNE	SETAL1			; BR IF RIBBON SHIFT ERROR
	MOV.B	#ZELVR,R0		;
	BTST.B	#QELVR,R1		;
	BNE	SETAL1			; BR IF LEVER CHANGE ERROR
	BTST.B	#QEINEJ,R1		;
	BEQ	CHKE_2			; BR IF NOT INSERT/EJECT ERROR
	BSET.B	#QJAM,@ERRSF:8		; SET INSERT/EJECT ERROR
CHKE_2: RTS				;
	.PAGE
;
;	SET ALARM ERROR
;
;	IN	R0 : ERROR CODE
;
;	OUT	NONE
;
SETALM: BSR	SETAL1			; SET ALARM ERROR MODE
	RETINT				;

SETAL1: EXTU	R0			; CLEAR ALARM CODE HIGH
SETAL2: STC.W	SR,@-SP 		;
	LDC.W	#XI2+XI1+XI0,SR 	; DISABLE INTERRUPT
	PUSHDP				;
	LDC.B	#0,DP			;
	CLR.B	@OUTC			; STOP PRINT HEAD OUTPUT
	BSET.B	#QMDVS,@P7DR		; CUT OFF P5V
	BCLR.B	#QCMIEA,@TCR		; DISABLE INTFAN
	BSET.B	#QFANC,@EXPNDB		; SET COOLING FAN OFF
	BSET.B	#QDALM,@PSWDF:8 	; DISABLE PANEL SW PROCESS
	CMP.B	#ZERBW,R0		;
	BNE	SETA_2			; BR IF NOT RIBBON WIND MOTOR ERROR
	BSET.B	#QERBW,@ERRSF:8 	; SET RIBBON WIND MOTOR ERROR
	BEQ	SETA_2			; BR IF 1ST TIME
SETA_1: BCLR.B	#QMPDN,@P5DR		; CUT OFF POWER SUPPLY
	BRA	SETA_1			;
					;
SETA_2: CLR.B	@SLVT:8 		; STOP SLAVE CPU RUN STATUS CHECK
	JSR	@INTAER 		; CALL ALARM ERROR INTERRUPT HANDLER
	POPDP				;
	LDC.W	@SP+,SR 		; ENABLE INETRRUPT
	RTS				;
	.PAGE
;
;	COOLING FAN INTERRUPT HANDLER  (8 BIT TIMER CMI)
;
INTFAN: 				;
	PUSHDP				;
	LDC.B	#0,DP			;
	BCLR.B	#QCFMA,@TCSR		; RESET INTERRUPT REQUEST
	BTST.B	#QFANCK,@FANT:8 	;
	BNE	CHKFAN:16		; BR IF POWER ON FAN CHECK MODE
	BTST.B	#QFANCE,@IOSF:8 	;
	BNE	INTF_5			; BR IF FAN CHECK ENABLE
	BTST.B	#QFANON,@FANT:8 	;
	BNE	INTF_3			; BR IF FAN ON REQUEST
	ADD.W	#-1,@FANT:8		; UPDATE FAN ON/OFF TIMER
	BNE	RETIH3			; BR IF NOT TIME OUT
	BNOT.B	#QFANC,@EXPNDB		; CHANGE FAN ON/OFF
	BEQ	INTF_2			; BR IF FAN ON -> OFF
	MOV.W	#ZTFON,@FANT:8		; START FAN ON TIMER
	JMP	@RETIH3 		;
					;
INTF_1: BSET.B	#QFANC,@EXPNDB		; SET FAN OFF
	BCLR.B	#QFANCE,@IOSF:8 	; SET FAN CHECK DISABLE
INTF_2: MOV.W	#ZTFOF,@FANT:8		; START FAN OFF TIMER
	JMP	@RETIH3 		;
					;
INTF_3: BCLR.B	#QFANC,@EXPNDB		; SET FAN ON
	BCLR.B	#Q10MS,@IOSF:8		; RESET 10MS INTERVAL FLAG
	BSET.B	#QFANCE,@IOSF:8 	; SET FAN CHECK ENABLE
	MOV.B	#ZCFAN,@FANEC:8 	; RESET FAN ERROR COUNTER
INTF_4: MOV.W	#ZTFAN,@FANT:8		; START FAN ON TIMER
	JMP	@RETIH3 		;

INTF_5: BNOT.B	#Q10MS,@IOSF:8		;
	BEQ	INTF_7			; BR IF NOT 10mS INTERVAL
	CMP.B	#ZAFAN,@ADDRC		;
	BCC	INTF_9			; BR IF FAN ERROR
INTF_6: MOV.B	#ZCFAN,@FANEC:8 	; RESET FAN ERROR COUNTER
INTF_7: BTST.B	#QFANON,@FANT:8 	;
	BNE	INTF_4			; BR IF FAN ON REQUEST
	ADD.W	#-1,@FANT:8		; UPDATE FAN ON/OFF TIMER
	BNE	RETIH3			; BR IF NOT TIME OUT
	BTST.B	#QHDALM,@ERRSF:8	;
	BNE	INTF_8			; BR IF HEAD THERMAL ALARM MODE
	CMP.B	#ZAHD3,@ADDRA		;
	BCC	INTF_1			; BR IF NOT HEAD TEMPERATURE CAUTION
INTF_8: MOV.B	#1,@FANT+1:8		; CONTINUE FAN ON
	JMP	@RETIH3 		;
	.PAGE
					;
INTF_9: BSR	RDFANS			; CHECK FANSNS AGAIN
	BCS	INTF_6			; BR IF NOT FAN ERROR
	ADD.B	#-1,@FANEC:8		; UPDATE FAN ERROR COUNT
	BNE	INTF_7			; BR IF NOT TIME OUT
INTF_A: MOV.W	R0,@-SP 		;
	MOV.B	#ZEFAN,R0		;
	BSR	SETAL1			; SET COOLIN FAN ALARM ERROR
	MOV.B	#ZCFAN,R0		;
	MOV.B	R0,@FANEC:8		; RESET FAN ERROR COUNTER
	MOV.W	@SP+,R0 		;
	JMP	@RETIH3 		;
	.PAGE
;
;	POWER ON COOLING FAN CHECK
;
CHKFAN: TST.B	@FANT+1:8		;
	BPL	CHKF_1			; BR IF NOT FAN STOP WAIT
	ADD.B	#1,@FANT+1:8		; UPDATE FAN CHECK TIMER COUNT
	JMP	@RETIH3 		;
					;
CHKF_1: BNE	CHKF_2			; BR IF NOT 1ST TIME
	MOV.B	#ZTFCHK,@FANT+1:8	; SET FAN CHECK TIME
CHKF_2: CMP.B	#ZAFAN,@ADDRC		;
	BCS	CHKF_3			; BR IF NOT FAN ERROR
	BSR	RDFANS			; READ FANSNS
	BCS	CHKF_3			; BR IF NOT FAN ERROR
	ADD.B	#-1,@FANEC:8		; UPDATE FAN ERROR COUNT
	BRA	CHKF_4			;
					;
CHKF_3: ADD.B	#1,@FANEC:8		; UPDATE NOT FAN ERROR COUNT
CHKF_4: ADD.B	#-1,@FANT+1:8		;
	BNE	RETIH3			; BR IF NOT TIME OUT
	BSET.B	#QFANC,@EXPNDB		; SET FAN OFF
	BNE	CHKF_5			; BR IF ALREADY FAN STOP
	CMP.B	#ZMSB+ZTFCHK-3,@FANEC:8 ;
	BCS	INTF_A			; BR IF FAN ERROR
	MOV.B	#ZMSB,@FANEC:8		; RESET FABN ERROR COUNTER
	MOV.B	#ZH-ZTFSTP,@FANT+1:8	; SET FAN STOP WAIT TIME
	JMP	@RETIH3 		;
					;
CHKF_5: CMP.B	#ZMSB-ZTFCHK+3,@FANEC:8 ;
	BHI	INTF_A			; BR IF FAN CHECK CIRCUIT ERROR
	BCLR.B	#QFANC,@EXPNDB		; SET FAN ON
	BSET.B	#QFANCE,@IOSF:8 	; SET FAN CHECK ENABLE
	MOV.B	#ZCFAN,@FANEC:8 	; RESET FAN ERROR COUNTER
	MOV.W	#ZTFANI,@FANT:8 	; SET INITIAL FAN ON TIME
	JMP	@RETIH3 		;
	;
RDFANS: BCLR.B	#QADF,@ADCSR		;
RDFA_1: BTST.B	#QADF,@ADCSR		;
	BEQ	RDFA_1			; BR IF NOT A/D CONVERSION FINISH
	CMP.B	#ZAFAN,@ADDRC		; READ FANSNS
	RTS				;
	.PAGE
;
;	PANEL INTERRUPT HANDLER  (FRT2 OCIA)
;
INTPNL: 				;
	PUSHDP				;
	LDC.B	#0,DP			;
	BCLR.B	#QOCFA,@TCSR2		; RESET INTERRUPT REQUEST
	STM	(R0-R2,FP),@-SP 	;
	MOV.W	R3,@-SP 		;
	MOV.W	R4,@-SP 		;
	MOV.B	@SWPDBA,R2		; READ SW1->SW8
	MOV.B	@EXPNDA,R1		; READ ACSF SW
	MOV.B	@SWPDBG,R0		; READ SW9->SW11, COVER SW
	MOV.B	@SWPDBC,R3		; READ SW12
	OR.B	@SWPDBA,R2		; READ AGAIN SW1->SW8
	AND.B	@EXPNDA,R1		; READ AGAIN ACSF SW
	OR.B	@SWPDBG,R0		; READ AGAIN SW9->SW11, COVER SW
	OR.B	@SWPDBC,R3		; READ AGAIN SW12
	OR.B	#ZN-XCVRS-XPSW11-XPSW10-XPSW9,R0
	OR.B	#ZSWMK,R3		;
	AND.B	R3,R0			; MERGE SW12
	SWAP	R0			;
	MOV.B	R2,R0			; MERGE SW9->SW12, COVER SW
	NOT.W	R0			; SET BIT ON IF SW ON
	MOV.B	@ADDRA,R3		; READ HEAD THERMISTER
	MOV.B	@ADDRD,R4		; READ POWER SUPPLY THERMISTER
	BCLR.B	#QADF,@ADCSR		; RESET A/D CONVERSION FINISH FLAG
	MOV.B	@OPTAF:8,R2		; GET OPTION ATTACHMENT STATUS
	MOV.B	R1,@OPTAF:8		;
	XOR.B	R2,R1			; GET CHANGE STATUS
	AND.B	#ZN-XSLRE-XSBUSY,R1	;
	BEQ	INTP_1			; BR IF NOT STATUS CHANGE
	MOV.W	R0,@-SP 		;
	JSR	@INTACF 		; CALL ACSF SW INTERRUPT HANDLER
	MOV.W	@SP+,R0 		;
INTP_1: MOV.W	@SWSF:8,R1		; GET OLD PANEL SW STATUS
	XOR.W	R0,R1			; GET CHANGE SW BIT
	MOV.W	R0,@SWSF:8		; UPDATE PANEL SW STATUS
	BTST.W	#QCVRS+8,R1		; RESET COVER SW BIT
	BEQ	INTSW			; BR IF NOT COVER STATUS CHANGE
	BCLR.W	#QCVRS+8,R1		; RESET COVER SW BIT
	MOV.W	R1,@-SP 		;
	JSR	@INTCVR 		; CALL COVER SW INTERRUPT HANDLER
	MOV.W	@SP+,R1 		;
	MOV.W	@SWSF:8,R0		;
;	BRA	INTSW			;
	.PAGE
;
;	PANEL SW INETRRUPT HANDLER
;
INTSW:	AND.W	R0,R1			; GET OFF -> ON SW BIT
	BEQ	INTS_2			; BR IF NO SW OFF -> ON
	BTST.B	#QBZOF,@PNLCF:8 	;
	BEQ	INTS_1			; BR IF NOT BUZZER OFF BY SW
	JSR	@BZOFF			; STOP BUZZER
INTS_1: BTST.B	#QESCSS,@PNLCF:8	;
	BEQ	INTS_2			; BR IF NOT FORMS ESCAPE STOP BY SW ON
	BCLR.B	#QESCSS,@PNLCF:8	; RESET FORMS ESCAPE STOP REQUEST
	MOV.W	R1,@-SP 		;
	MOV.W	#DP3TCB,R1		;
	MOV.W	#FSTOP,R2		;
	ORFLG				; WAKE UP DP3 TASK FOR STOP ESCPAE
	MOV.W	@SP+,R1 		;
	MOV.W	@SWSF:8,R0		;
INTS_2: BCLR.W	#QCVRS+8,R0		; RESET COVER SW BIT
	MOV.W	@SWTP:8,FP		; GET PANEL SW TABLE POINTER
	BEQ	INTS_5			; BR IF NO PANEL SW TABLE
	MOV.B	@PSWDF:8,R2		;
	BNE	INTS_5			; BR IF PANEL SW DISABLE
	TST.W	R1			;
	BEQ	INTS_6			; BR IF NO SW OFF -> ON
	BTST.B	#QSWT2S,@PNLCF:8	;
	BEQ	INTS_3			; BR IF SW TABEL 1 SELECT
	ADD.W	#2,FP			;
INTS_3: MOV.W	@FP,FP			; GET PANEL SW TABLE
	XOR.W	R0,R1			; GET ALREADY ON SW BIT
	OR.W	@FP,R1			;
	CMP.W	@FP,R1			;
	BNE	INTS_6			; BR IF ALREADY NOT SHIFT SW ON
INTS_4: ADD.W	#2,FP			;
	CMP.W	@FP+,R0 		; CHECK SW STATUS
	BHI	INTS_4			; BR IF NOT HIT
	BNE	INTS_6			; BR IF UNDEFINED SW STATUS
	MOV.W	FP,@SWRP:8		; SET REPEAT SW TABLE POINTER
	MOV.B	@(1,FP),R1		; CHECK REAPEAT INTERVAL
	BEQ	INTS_7			; BR IF REPEAT DISABLE SW
	MOV.B	#ZTSWR,R1		; SET REAPEAT START CHECK TIME
	BRA	INTS_7			;
					;
INTS_5: CLR.B	@SWRT:8 		; RESET SW REPEAT MODE
	BRA	INTLED			;
	.PAGE
					;
INTS_6: MOV.B	@SWRT:8,R1		;
	BEQ	INTLED			; BR IF NOT REAPEAT MODE
	MOV.W	@SWRP:8,FP		; GET REPEAT SW TABLE POINTER
	MOV.W	@(-2,FP),R1		; GET REPEAT SW STATUS
	AND.W	R1,R0			; RESET OTHER SW BIT
	CMP.W	R0,R1			;
	BNE	INTS_5			; BR IF REPEAT SW OFF
	ADD.B	#-1,@SWRT:8		;
	BNE	INTLED			; BR IF NOT TIME OUT
	MOV.B	@(1,FP),R1		; GET REAPEAT INTERVAL
INTS_7: MOV.B	R1,@SWRT:8		; SET REAPEAT SW TIMER
	CLR.W	R1			;
	MOV.B	@FP,R1			; GET LOGICAL SW NO.
	MOV.W	#SWPTCB,R0		;
;	CALTSK				; CALL SW PROCESSING TASK
	MOV.W	R0,FP			;
	LDC.W	#XI2+XI1+XI0,SR 	; DISABLE INETRRUPT
	MOV.W	@(4,FP),R2		; GET TASK STATUS
	BTST.W	#QTSUS,R2		;
	BNE	INTS_8			; BR IF SUSPEND STATUS
	AND.B	#XTWTMR+XTWSLP,R2	;
	BEQ	INTS_8			; BR IF NOT TIMER WAIT OR SLEEP
	BSET.W	#QTRDY,R2		; SET READY STATUS
	CLR.B	R2			; RESET WAIT STATUS
	MOV.W	R2,@(4,FP)		; UPDATE TASK STATUS
	MOV.B	R2,@SYS$FG:8		; SET SCHEDULER REQUEST
	MOV.W	@(8,FP),FP		; GET STACK POINTER
	MOV.B	#ZE_CAL,R2		;
	MOV.B	R2,@(3,FP)		; SET TASK CALL ANSWER CODE
	MOV.W	R1,@(4,FP)		; SET LOGICAL SW NO.
	MOV.W	@(6,R0),FP		; GET SCHEDULE LIST POINTER
	MOV.W	@(2,FP),R1		; ENQUEU TCB TO SCHEDULE LIST
	MOV.W	R0,@R1			;
	MOV.W	R0,@(2,FP)		;
	MOV.W	FP,@R0+ 		;
	MOV.W	R1,@R0			;
INTS_8: LDC.W	#XI1,SR 		; ENABLE OTHER INTERRUPT
;	BRA	INTLED			;
	.PAGE
;
;	LED INTERRUPT HANDLER
;
;INTLED:CLR.W	R1			;
;	MOV.W	#ZLEDTC-1,R2		; GET BLINK TIMER COUNT
;	MOV.W	#LEDT,FP		; GET LED BLINK TIMER POINTER
;INTL_1:TST.B	@FP			;
;	BNE	INTL_3			; BR IF LED BLINK TIMER ACTIVE
;	ADDS.B	#YLEDSZ,FP		; GET NEXT LED BLINK TIMER
;	SCB/F	R2,INTL_1		;
;	MOV.B	@LEDF:8,R0		; GET LED STATUS
;	MOV.B	R0,@SWPDBE		; OUTPUT LED STATUS
;	BRA	INTBUZ			;
					;
INTLED: MOV.W	#LEDT,FP		; GET LED BLINK TIMER POINTER
	MOV.B	@(YLEDSZ,FP),R0 	;
	OR.B	@FP,R0			;
	BEQ	INTL_6			; BR IF NO BLINK LED
	CLR.W	R1			;
	MOV.W	#ZLEDTC-1,R2		; GET BLINK TIMER COUNT
INTL_2: MOV.B	@(YLEDT,FP),R0		;
	BEQ	INTL_5			; BR IF NOT TIMER ACTIVE
INTL_3: ADD.B	#-1,@FP 		; UPDATE BLINK TIMER COUNT
	BNE	INTL_4			; BR IF NOT TIME OUT
	MOV.B	@(YLEDTS,FP),R0 	; GET LED BLINK INTERVAL TIME
	MOV.B	R0,@(YLEDT,FP)		; RESTART BLINK TIMER
	SWAP	R1			;
	OR.B	@(YLEDS,FP),R1		; GET TIME OUT BLINK LED
	SWAP	R1			;
INTL_4: OR.B	@(YLEDS,FP),R1		; GET BLINK LED
INTL_5: ADDS.B	#YLEDSZ,FP		; GET NEXT LED BLINK TIMER
	SCB/F	R2,INTL_2		;
	SWAP	R1			;
	MOV.B	@SWPDBE,R0		; READ LED STATUS
	XOR.B	R1,R0			; CHANGE BLINK LED BIT
	SWAP	R1			;
	AND.B	R1,R0			; GET BLINK LED
	NOT.B	R1			;
	AND.B	@LEDF:8,R1		; GET NOT BLINK LED
	OR.B	R1,R0			;
	BRA	INTL_7			;
					;
INTL_6: MOV.B	@LEDF:8,R0		; GET LED STATUS
INTL_7: MOV.B	R0,@SWPDBE		; OUTPUT LED STATUS
;	BRA	INTBUZ			;
	.PAGE
;
;	BUZZER INTERRUPT HANDLER
;
INTBUZ: MOV.W	#BUZT,FP		; GET BUZZER TIMER POINTER
	MOV.W	@(YBZT1,FP),R0		;
	BNE	INTB_2			; BR IF BUZZER ON TIMER ACTIVE
	MOV.W	@(YBZT2,FP),R0		;
	BEQ	INTDOT			; BR IF BUZZER OFF TIMER INACTIVE
	ADD.W	#-1,@(YBZT2,FP) 	;
	BNE	INTDOT			; BR IF NOT TIME OUT
	MOV.W	@(YBZTS1,FP),R0 	;
	MOV.W	R0,@(YBZT1,FP)		; START BUZZER ON TIMER
INTB_1: BCLR.B	#QBZON,@P7DR		; SET BUZEER ON
	BRA	INTDOT			;
					;
INTB_2: ADD.W	#-1,@FP 		;
	BNE	INTB_1			; BR IF NOT TIME OUT
	MOV.W	@(YBZC,FP),R0		;
	BEQ	INTB_3			; BR IF NOT BUZZER INTERMITTENT MODE
	ADD.W	#-1,R0			;
	MOV.W	R0,@(YBZC,FP)		;
	BEQ	INTB_3			; BR IF BUZZER INTERMITTENT MODE END
	MOV.W	@(YBZTS2,FP),R0 	;
	MOV.W	R0,@(YBZT2,FP)		; START BUZZER OFF TIMER
INTB_3: BSET.B	#QBZON,@P7DR		; SET BUZZER OFF
;	BRA	INTDOT			;
	.PAGE
;
;	PRINT DOT COUNTER UPDATE INTERRUPT HANDLER
;
INTDOT: BTST.B	#QADF,@ADCSR		;
	BEQ	INTDOT			; BR IF NOT A/D CONVERSION FINISH
	ADD.B	@ADDRA,R3		; READ AGAIN HEAD THERMISTER
	ROTXR.B R3			;
	ADD.B	@ADDRD,R4		; READ AGAIN POWER SUPPLY THERMISTER
	ROTXR.B R4			;
	MOV.W	#DOTTB3-4,FP		; GET DOT COUNT TABLE 3
	BTST.B	#QDOT4S,@IOSF:8 	;
	BEQ	INTD_1			; BR IF NOT SAME PATTERN CONTINUE
	MOV.W	#DOTTB4-4,FP		; GET DOT COUNT TABLE 3
INTD_1: ADDS.B	#4,FP			;
	CMP.B	@FP,R3			; SEARCH A/D RANGE
	BHI	INTD_1			;
	CLR.W	R0			;
	MOV.B	@(1,FP),R0		; GET CR DUTY DECREMENT VALUE
	MOV.W	@CRDC:8,R2		;
	SUB.W	R0,R2			; UPDATE CR DUTY COUNTER
	BCC	INTD_2			;
	CLR.W	R2			;
INTD_2: MOV.W	R2,@CRDC:8		;
	MOV.W	@(2,FP),R0		; GET DECREMENT DOT COUNT
	MOV.W	#DOTTB5-2,FP		; GET DOT COUNT TABLE 4
INTD_3: ADD.B	#2,FP			;
	CMP.B	@FP,R4			; SEARCH A/D RANGE
	BHI	INTD_3			;
	CLR.W	R1			;
	MOV.B	@(1,FP),R1		; GET DECREMENT ADJUST VALUE
	SUB.W	R1,R0			; ADJUST DECREMENT DOT COUNT
	BCC	INTD_7			;
	CLR.W	R0			;
INTD_7: MOV.W	@DOTC+1:8,R1		;
	SUB.W	R0,R1			; UPDATE PRINT DOT COUNTER
	BCC	INTD_4			;
	ADD.B	#-1,@DOTC:8		;
	BCS	INTD_4			; BR IF NOT UNDERFLOW
	CLR.W	R1			;
	MOV.B	R1,@DOTC:8		;
INTD_4: MOV.W	R1,@DOTC+1:8		;
	CMP.W	#ZCRDV,R2		;
	BCS	INTD_6			; BR IF NOT CR THERMAL ALARM MODE
INTD_5: BSET.B	#QHDALM,@ERRSF:8	; SET HEAD THERMAL ALARM MODE
	BRA	INTTHM			;
					;
INTD_6: MOV.B	@DOTC:8,R0		;
	CMP.W	#ZDOTL1,R1		; CHECK PRINT DOT COUNTER
	SUBX.B	#ZDOTH1,R0		;
	BCC	INTD_5			; BR IF HEAD THERMAL ALARM MODE
	BCLR.B	#QHDALM,@ERRSF:8	; RESET HEAD THERMAL ALARM MODE
	BEQ	INTTHM			; BR IF ALREADY NOT HEAD ALARM MODE
	MOV.W	#D3WPKT,R1		;
	SDCPKT				; ATTENTION HEAD COOLING END
	MOV.W	@DOTC+1:8,R1		;
;	BRA	INTTHM			;
	.PAGE
;
;	THERMISTER CHECK INTERRUPT HANDLER
;
INTTHM: MOV.B	@DOTC:8,R0		;
	CMP.W	#ZDOTL2,R1		; CHECK PRINT DOT COUNTER
	SUBX.B	#ZDOTH2,R0		;
	BCS	INTT_5			; BR IF NOT HIGH DUTY STATUS
	CMP.B	#ZAHD1,R3		;
	BLS	INTT_3			; BR IF HEAD THERMISTER OK
	ADD.B	#-1,@HDTEC:8		; UPDATE HEAD THERMAL ERROR COUNTER
	BNE	INTT_4			; BR IF NOT TIME OUT
	MOV.B	#ZEHDT,R0		;
	BSR	SETAL1			; SET HEAD THERMAL ALARM ERROR
INTT_3: MOV.B	#ZCHDT,R0		;
	MOV.B	R0,@HDTEC:8		; RESET HEAD THERMAL ERROR COUNTER
INTT_4: CMP.B	#ZAPW1,R4		;
	BLS	INTT_7			; BR IF POWER SUPPLY THERMISTER OK
	ADD.B	#-1,@PWREC:8		; UPDATE POWER SUPPLY ERROR COUNTER
	BNE	INTALM			; BR IF NOT TIME OUT
	MOV.B	#ZEPWR,R0		;
	BSR	SETAL1			; SET POWER SUPPLY ALARM ERROR
	BRA	INTT_9			;
					;
INTT_5: CMP.B	#ZAHD2,R3		;
	BHI	INTT_6			; BR IF NOT HEAD THERMAL ERROR
	ADD.B	#-1,@HDTEC:8		; UPDATE HEAD THERMAL ERROR COUNTER
	BNE	INTT_7			; BR IF NOT TIME OUT
	MOV.B	#ZEHDT,R0		;
	BSR	SETAL1			; SET HEAD THERMAL ALARM ERROR
INTT_6: MOV.B	#ZCHDT,R0		;
	MOV.B	R0,@HDTEC:8		; RESET HEAD THERMAL ERROR COUNTER
INTT_7: CMP.B	#ZAPW2,R4		;
	BHI	INTT_9			; BR IF NOT POWER SUPPLY THERMAL ERROR
INTT_8: ADD.B	#-1,@PWREC:8		; UPDATE POWER SUPPLY ERROR COUNTER
	BNE	INTALM			; BR IF NOT TIME OUT
	MOV.B	#ZDOTH3,R0		;
	MOV.B	R0,@DOTC:8		; SET HIGH DUTY STATUS
	MOV.W	#ZDOTL3,@DOTC+1:8	;
INTT_9: MOV.B	#ZCPWR,R0		;
	MOV.B	R0,@PWREC:8		; RESET POWER SUPPLY ERROR COUNTER
;	BRA	INTALM			;
	.PAGE
;
;	RIBBON WIND ALARM ERROR CHECK INTERRUPT HANDLER
;
INTALM: BTST.B	#QERBW,@ERRSF:8 	;
	BEQ	INTA_3			; BR IF 1ST CHECK MODE
	CMP.B	#ZARBM,@ADDRB		; CHECK RBMSNS
	BCS	INTA_2			; BR IF NOT RIBBON WIND MOTOR ERROR
	BSR	RDRBMS			; CHECK RBMSNS AGAIN
	BCS	INTA_2			; BR IF NOT RIBBON MOTOR ERROR
INTA_1: ADD.B	#-1,@RBMEC:8		; UPDATE RIBBON MOTOR ERROR COUNTER
	BNE	INTA_6			; BR IF NOT TIME OUT
	MOV.B	#ZERBW,R0		;
	BSR	SETAL1			; SET RIBBON WIND MOTOR ALARM ERROR
INTA_2: MOV.B	#ZCRB2,R0		; GET 2ND ERROR CHECK COUNT
	BRA	INTA_5			;
					;
					;
INTA_3: BTST.B	#QPRBSY,@INTPRE 	;
	BNE	INTA_4			; BR IF PRINT BUSY
	CMP.B	#ZARBM,@ADDRB		; CHECK RBMSNS
	BCS	INTA_4			; BR IF NOT RIBBON WIND MOTOR ERROR
	BSR	RDRBMS			; CHECK RBMSNS AGAIN
	BCC	INTA_1			; BR IF RIBBON MOTOR ERROR
INTA_4: MOV.B	#ZCRB1,R0		; GET 1ST ERROR CHECK COUNT
INTA_5: MOV.B	R0,@RBMEC:8		; RESET RIBBON MOTOR ERROR COUNTER
INTA_6: BNOT.B	#Q50MS,@IOSF:8		; UPDATE 50mS TIMER FLAG
	BEQ	INTA_8			; BR IF NOT 50mS INTERVAL
	MOV.B	@SLVT:8,R0		;
	BEQ	INTA_7			; BR IF SLAVE CPU CHECK SKIP
	ADD.B	#-1,@SLVT:8		; UPDATE SLAVE CPU CHECK TIMER
	BNE	INTA_7			; BR IF NOT TIME OUT
	MOV.B	#ZESLV,R0		;
	BSR	SETAL1			; SET SLAVE CPU ALARM ERROR
INTA_7: JSR	@INTUSR 		; CALL USER TIMER INTERRUPT HANDLER
INTA_8: MOV.W	@SP+,R4 		;
	MOV.W	@SP+,R3 		;
	JMP	@INTTMR 		; GOTO REAL TIME MONITOR
					;
RDRBMS: BCLR.B	#QADF,@ADCSR		;
RDRB_1: BTST.B	#QADF,@ADCSR		;
	BEQ	RDRB_1			; BR IF NOT A/D CONVERSION FINISH
	CMP.B	#ZARBM,@ADDRB		; RE-READ RBMSNS
	RTS				;
	.PAGE
;
;	INITIALIZE PANEL I/O
;
;	IN	NONE
;
;	OUT	NONE
;
INIPNL: MOV.B	#XCCLR0+XCKS1+XCKS0,@TCR;
	MOV.B	#ZTI1*10000/1024-1,@TCORA; SET 8 BIT TIMER INTERVAL
	MOV.B	@EXPNDA,R0		;
	MOV.B	R0,@OPTAF:8		; SET OPTION ATTACHMENT STATUS
	MOV.B	#ZCHDT,R0		;
	MOV.B	R0,@HDTEC:8		; RESET HEAD THERMAL ERROR COUNTER
	MOV.B	#ZCPWR,R0		;
	MOV.B	R0,@PWREC:8		; RESET POWER SUPPLY ERROR COUNTER
	MOV.B	#ZCRB2-1,R0		; GET 2ND ERROR CHECK COUNT
	MOV.B	R0,@RBMEC:8		; RESET RIBBON MOTOR ERROR COUNTER
	BSET.B	#QERBW,@ERRSF:8 	; SET ERROR MODE FOR POWER ON CHECK
	MOV.B	@ADDRA,R3		; READ HEAD THERMISTER
	MOV.B	@ADDRD,R4		; READ POWER SUPPLY THERMISTER
	BCLR.B	#QADF,@ADCSR		;
INIP_1: BTST.B	#QADF,@ADCSR		;
	BEQ	INIP_1			; BR IF NOT A/D CONVERSION FINISH
	ADD.B	@ADDRA,R3		; READ AGAIN HEAD THERMISTER
	ROTXR.B R3			;
	ADD.B	@ADDRD,R4		; READ AGAIN POWER SUPPLY THERMISTER
	ROTXR.B R4			;
	MOV.W	#DOTTB1-6,FP		; GET DOT COUNT TABLE 1
INIP_2: ADDS.B	#6,FP			;
	CMP.B	@FP,R3			; SEARCH A/D RANGE
	BHI	INIP_2			;
	MOV.B	@(1,FP),R0		;
	MOV.W	@(2,FP),R1		; GET DOT COUNT INITIAL VALUE
	MOV.W	@(4,FP),R2		; GET CR DUTY INITIAL VALUE
	MOV.W	#DOTTB2-4,FP		; GET DOT COUNT TABLE 2
INIP_3: ADDS.B	#4,FP			;
	CMP.B	@FP,R4			; SEARCH A/D RANGE
	BHI	INIP_3			;
	SUB.W	@(2,FP),R1		; ADJUST DOT COUNT INITIAL VALUE
	SUBX.B	@(1,FP),R0		;
	MOV.B	R0,@DOTC:8		;
	MOV.W	R1,@DOTC+1:8		; SET PRINT DOT COUNT INITIAL VALUE
	MOV.W	R2,@CRDC:8		; SET CR DUTY COUNT INITIAL VALUE
	JMP	@INILCD 		; INITIALIZE LCD
	.PAGE
;
;	I/O SYSTEM CALL
;
;	IN	R1-R5 : CALL PARAMETER
;		   EP : CALL PARAMETER
;
;	OUT	NONE
;
CALIOS: MOV.W	#IOSTCB,R0		; SET I/O SYSTEM TCB POINTER
	JMP	@CALTSK 		; WAKE UP I/O SYSTEM TASK

;
;	INITIALIZE I/O SYSTEM
;
IOSINI: BSET.B	#QMBUSY,@EXPNDB 	; RESET MAIN CPU TRANSMIT BUSY
	CLR.B	@INTDAT 		;
	MOV.B	R0,@INTRST		; RESET INTERRUPT REQUEST
	MOV.B	#ZN-XINTNF-XIPRM1-XIPRM0,@INTMSK
	MOV.B	#2,@BRR1		; SET 833K bps
	MOV.B	#XCKE0,@SCR1		; SET SCK(P75) OUTPUT MODE
	MOV.B	#XCA,@SMR1		; SET CLOCK SYNCHRONOUS MODE
	MULXU.B #0,R0			; DELAY 1 BIT INTERVAL
	MOV.B	#XTE+XCKE0,@SCR1	; SET TRANSMIT ENABLE
	MOV.B	#STSBF&ZN,R0		;
	MOV.B	R0,@STSBP:8		; SET STATUS BUFFER POINTER
	MOV.B	#H'65,@IPRC             ; SET INTFAN, INTER1/INTRX1 PRIORITY
	MOV.B	#H'70,@IPRA             ; SET INTGA PRIORITY
	MOV.B	#ZMSB,@FANEC:8		; RESET FABN ERROR COUNTER
	BSET.B	#QFANCK,@FANT:8 	; SET POWER ON COOLING FAN CHECK MODE
	BSET.B	#QCMIEA,@TCR		; ENABLE INTFAN
	JSR	@EEWRDI 		; SET EEPROM WRITE DISABLE
	MOV.W	#ZNN,R0 		;
	MOV.W	R0,@SOPC:8		; RESET SHEET OPC
	MOV.W	R0,@FOPC:8		; RESET FORMS OPC
	MOV.W	R0,@BOPC:8		; RESET BOTTOM OPC
	JSR	@INILBF 		; INITIALIZE LCD BUFFER
	BSR	IOSI_5			; CHECK RIBBON WIND MOTOR ERROR
	LDC.W	#XI2+XI1+XI0,SR 	; DISABLE INTERRUPT
	BTST.B	#QDALM,@PSWDF:8 	;
	BNE	IOSI_1			; BR IF ALARM ERROR MODE
	BCLR.B	#QMDVS,@P7DR		; SET P5V ON
	BCLR.B	#QERBW,@ERRSF:8 	; SET NORMAL CHECK MODE
IOSI_1: LDC.W	#0,SR			; ENABLE INTERRUPT
	.PAGE
					;
	BSR	WTSLVI			; WAIT SLAVE CPU INITIALIZE END
	BTST.B	#QDALM,@PSWDF:8 	;
	BNE	IOSI_4			; BR IF ALARM ERROR MODE
	MOV.B	@IFPOTC,R0		; READ DIP SW
	NOT.B	R0			;
	MOV.B	@OPTAF:8,R1		; GET OPTION ATTACHMENT STATS
	AND.B	#ZN-XSLRE-XSBUSY,R1	;
	MOV.W	@SWSF:8,R2		; GET PANEL SW STATUS
	BCLR.W	#QCVRS+8,R2		; RESET COVER SW BIT
	JSR	@INTPON 		; CALL USER POWER ON INTERRUPT HANDLER
	MOV.W	#SCISPC,R1		;
	BSR	IOSCAL			; SEND INITIAL PARAMETER TRANSMIT END
IOSI_4: 				;
	SLPTSK				; WAIT TASK CALL
	CMP:E	#ZE_CAL,R0		;
	BNE	IOSI_4			; BR IF NOT WAKE UP BY TASK CALL
	BSR	IOSCAL			; EXECUTE I/O CALL
	BRA	IOSI_4			;

;
;	CHECK RIBBON WIND MOTOR
;
;	IN	NONE
;
;	OUT	NONE
;
IOSI_5: BSR	IOSI_6			; CHECK RIBBON WIND MOTOR
	MOV.B	#ZCRB2-1,R0		;
	MOV.B	R0,@RBMEC:8		; RESET RIBBON WIND MOTOR ERROR COUNTER
IOSI_6: BTST.B	#QDALM,@PSWDF:8 	;
	BNE	IOSI_7			; BR IF ALARAM ERROR MODE
	CMP.B	#ZCRB2,@RBMEC:8 	;
	BCS	IOSI_6			; BR IF NOT RIBBON WIND MOTOR OK
IOSI_7: RTS				;
	.PAGE
;
;	EXECUTE I/O SYSTEM CALL
;
;	IN	R1 : ENTRY
;
;	OUT	R0 : SLRE STATUS		(SCI I/O CALL)
;		FP : BIT REVERSE TABLE POINTER	(SCI I/O CALL)
;		FP : LCD BUFFER POINTER 	(LCD I/O CALL)
;
IOSCAL: CMP.W	#SCICMD,R1		;
	BLS	SCICAL			; BR IF SCI I/O CALL
	CMP.W	#LCDCON,R1		;
	BLS	IOSC_1			; BR IF NOT LCD BUFFER I/O
	CMP.W	#LCDDEC,R1		;
	BLS	LCDCAL			; BR IF LCD BUFFER I/O CALL
IOSC_1: JMP	@R1			; EXECUTE I/O CALL
					;
SCICAL: BSR	CHKSCI			; CHECK SCI TRANSMIT CONDITION
	JMP	@R1			; EXECUTE SCI I/O

;
;	WAIT SLAVE CPU INTIALIZE END
;
;	IN	NONE
;
;	OUT	NONE
;
WTSLVI: MOV.B	#ZTSLV,R0		;
	MOV.B	R0,@SLVT:8		; START SLAVE CPU CHECK TIMER
WTSL_1: BTST.B	#QDALM,@PSWDF:8 	;
	BNE	WTSL_2			; BR IF ALARM ERROR MODE
	BTST.B	#QSLBSY,@INTPRE 	;
	BNE	WTSL_1			; BR IF NOT SLAVE CPU INITIALIZE END
WTSL_2: CLR.B	@SLVT:8 		; STOP SLAVE CPU CHECK TIMER
	RTS				;
	.PAGE
;
;	CHECK TRANSMIT CONDITION
;
;	IN	NONE
;
;	OUT	R0 : SLRE STATUS
;	     R1-R5 : NOT CHNAGE
;		FP : BIT SEQUENCE REVERSE TABLE
;
CHKS_Z: LDC.W	#0,SR			; ENABLE INTERRUPT
CHKSCI: BTST.B	#QTE,@SCR1		;
	BEQ	CHKSCI			; BR IF MAIN CPU RECEIVE MODE
	BTST.B	#QSBUSY,@EXPNDA 	;
	BNE	CHKSCI			; BR IF SLAVE TRANSMIT BUSY
	LDC.W	#XI2+XI1+XI0,SR 	; DISABLE INTERRUPT
	BTST.B	#QTE,@SCR1		;
	BEQ	CHKS_Z			; BR IF MAIN CPU RECEIVE MODE
	BTST.B	#QSBUSY,@EXPNDA 	;
	BNE	CHKS_Z			; BR IF SLAVE TRANSMIT BUSY
	BCLR.B	#QMBUSY,@EXPNDB 	; SET MAIN CPU TRANSMIT BUSY
	LDC.W	#0,SR			; ENABLE INTERRUPT
	MOV.B	@EXPNDA,R0		; GET SLRE STATUS
	MOV.W	#BSRTB,FP		; GET BIT SEQUENSE REVERSE TABLE
	RTS				;

;
;	RESET SLAVE CPU
;
;	IN	R2 : SPECIFICATION FLAG
;
;	OUT	NONE
;
SCINMI: LDC.W	#XI2+XI1+XI0,SR 	; DISABLE INTERRUPT
	BSET.B	#QSNMI,@EXPNDB		; OUTPUT NMI SIGNAL TO SLAVE CPU
	BSR	SCIS_3			; DELAY FOR NMI PULSE WIDTH
	BCLR.B	#QSNMI,@EXPNDB		;
SCIN_1: BTST.B	#QSLBSY,@INTPRE 	;
	BEQ	SCIN_1			; BR IF NOT NMI ACCEPT
	LDC.W	#0,SR			; ENABLE INTERRUPT
	BSR	WTSLVI			; WAIT SLAVE CPU INITIALIZE END
	BSR	CHKSCI			; CHECK SCI TRANSMIT CONDITION
	BRA	SCISPC			; SEND NMI END PARAMETER
	.PAGE
;
;	SEND HEAD SHIFT MOTOR PHASE STATUS REQUEST AND WAIT STATUS
;
;	IN	R0 : SLRE STATUS
;		FP : BIT SEQUENCE REVERSE TABLE
;
;	OUT	NONE
;
SCIHSP: MOV.W	#PSPH*ZH+QWHSP,R2	; SET HEAD SHIFT MOTOR PHASE ADDRESS
	BRA	SCISTW			;

;
;	SEND TOP SENSOR A/D STATUS REQUEST AND WAIT STATUS
;
;	IN	R0 : SLRE STATUS
;		FP : BIT SEQUENCE REVERSE TABLE
;
;	OUT	NONE
;
SCIADW: MOV.W	#ADTOPS*ZH+QWADS,R2	; SET TOP SENSOR A/D STATUS ADDRESS
	BRA	SCISTW			;

;
;	SEND VERSION STATUS REQUEST AND WAIT STATUS
;
;	IN	R0 : SLRE STATUS
;		FP : BIT SEQUENCE REVERSE TABLE
;
;	OUT	NONE
;
SCIVER: MOV.W	#SLREV2*ZH+QWVER,R2	; SET 1ST VERSION STATUS ADDRESS
	BSR	SCISTW			;
	BSR	CHKSCI			; CHECK SCI TRANSMIT CONDITION
	MOV.W	#SLREV1*ZH+QWVER,R2	; SET 2ND VERSION STATUS ADDRESS
	BSR	SCISTW			;
	BSR	CHKSCI			; CHECK SCI TRANSMIT CONDITION
	MOV.W	#SLREV0*ZH+QWVER,R2	; SET 3RD VERSION STATUS ADDRESS
	BRA	SCISTW			;
	.PAGE
;
;	SEND STATUS REQUEST COMMAND AND WAIT STATUS
;
;	IN	R0 : SLRE STATUS
;		R2 : STATUS ADDRESS
;		FP : BIT SEQUENCE REVERSE TABLE
;
;	OUT	NONE
;
SCISNS: MOV.W	#PRNSF*ZH+QWSNS,R2	; SET SENSOR STATUS ADDRESS
SCISTW: BSET.B	R2,@IOSF:8		; SET STATUS WAIT FLAG
	SWAP	R2			;
	BSR	SCISTS			; SEND SENSOR STATUS REQUEST COMMAND
	SWAP	R2			;
	MOV.W	#4-1,R4 		;
SCIS_1: MOV.W	#ZNN,R3 		;
SCIS_2: BTST.B	#QDALM,@PSWDF:8 	;
	BNE	SCIS_3			; BR IF ALARM ERROR MODE
	BTST.B	R2,@IOSF:8		;
	BEQ	SCIS_3			; BR IF STATUS RECEIVE
	BTST.B	#QSLACT,@INTPRE 	;
	BNE	SCIS_2			; BR IF SLAVE CPU ACTIVE
	SCB/F	R3,SCIS_2		; BR IF NOT TIME OUT
	SCB/F	R4,SCIS_1		;
	MOV.W	#ZESL3,R0		;
	BSR	SETAL2			; SET SLAVE CPU ALARM ERROR
SCIS_3: RTS				;

;
;	SEND STATUS REQUEST COMMAND
;
;	IN	R0 : SLRE STATUS
;		R2 : STATUS ADDRESS
;		FP : BIT SEQUENCE REVERSE TABLE
;
;	OUT	NONE
;
SCIADS: MOV.B	#ADTOPS,R2		; SET TOP SENSOR A/D STATUS ADDRESS
SCISTS: MOV.W	#ZCSTS,R1		; SET STATUS REQUEST COMMAND CODE
	BSR	SCID_2:16		; TRANSMIT CMDFMT, SLCOF
	MOV.B	R2,R1			;
	BRA	SCIC_3:16		; TRANSMIT STATUS ADDRESS
	.PAGE
;
;	SEND SPECIAL COMMAND
;
;	IN	R0 : SLRE STATUS
;		FP : BIT SEQUENCE REVERSE TABLE
;
;	OUT	NONE
;
SCICAN: BSET.B	#QCCANS,@PRLFF:8	; SET COMMAND CANCEL SEND
	MOV.W	#XCANCM*ZH+CANCMD,R2	; CANCEL COMMAND EXECUTION
	BRA	SCIBDT			;

SCISTP: MOV.W	#XSTOPE*ZH+CANCMD,R2	; STOP FORMS ESCAPE
	BRA	SCIBDT			;

SCICLC: MOV.W	#CANCMD,R2		; CLEAR CANCEL FLAG
	BRA	SCIBDT			;

SCICLE: MOV.W	#ERRF1,R2		; CLEAR ERROR FLAG 1
	BRA	SCIBDT			;

SCISPC: BSET.B	#QSIPTE,R2		; SET INITIAL PAREMTER END FLAG
	SWAP	R2			;
	MOV.B	#SPECF,R2		; SET SPECIFICATION FLAG ADDRESS
	BSR	SCIBDT			;
	MOV.B	#ZTSLV,R0		;
	MOV.B	R0,@SLVT:8		; START SLAVE CPU RUN STATUS CHECK
	RTS				;

SCIADV: SWAP	R2			;
	MOV.B	#ADTOPV,R2		; SEND TOP SENSOR THRESHOLD
;	BRA	SCIBDT			;

;
;	SEND BYTE DATA TRANSFER COMMAND
;
;	IN	R0 : SLRE STATUS
;		R2 : DATA, ADDRESS
;		FP : BIT SEQUENCE REVERSE TABLE
;
;	OUT	NONE
;
SCIBDT: BSR	SCIDT2			; TRANSMIT CMDFMT, SLCOF, ADDRESS
	SWAP	R1			;
	BRA	SCIC_3			; TRANSMIT DATA
	.PAGE
;
;	SEND PE CHECK COUNT DATA
;
;	IN	R0 : SLRE STATUS
;	     EP R4 : DATA POINTER
;		FP : BIT SEQUENCE REVERSE TABLE
;
;	OUT	NONE
;
SCIPEC: MOV.B	#PECNST,R2		; SEND PE CHECK COUNT
	BSR	SCIDT2			; TRANSMIT CMDFMT, SLCOF, ADDRESS
	MOV.W	@R4+,R1 		;
	BSR	SCID_2			; TRANSMIT PE COUNT FOR SHEET
	MOV.W	@R4+,R1 		;
	BSR	SCID_2			; TRANSMIT PE COUNT FOR FORMS
	MOV.W	@R4+,R1 		;
	BSR	SCIC_4			; TRANSMIT PE COUNT FOR BOTTOM
	SWAP	R1			;
	BRA	SCIC_3			;

;
;	SEND PRINT POSITION ADJUST DATA
;
;	IN	R0 : SLRE STATUS
;		R2 : CORRECTION VALUE
;	     EP R4 : DATA POINTER
;		FP : BIT SEQUENCE REVERSE TABLE
;
;	OUT	NONE
;
SCIPRA: SWAP	R2			;
	MOV.B	#CLM10D,R2		; SEND PRINT COLUMN ADJUST VALUE
	BSR	SCIDT2			; TRANSMIT CMDFMT, SLCOF, ADDRESS
	MOV.W	#PRATB,R1		; GET PRINT ADJUST VALUE TABLE
	SWAP	R2			;
	ADD.B	@R1+,R2 		; ADD +/- LEVEL
	MOV.W	#CLMEND-CLM10D,R5	; GET DATA SIZE
	MULXU.B R5,R2			; CALCULATE TABLE OFFSET
	ADD.W	R1,R2			; GET PRINT ADJUST TABLE POINTER
	ADD.W	#-1,R5			; ADJUST FOR LOOP
	BRA	SCIP_2			;
	;
SCIP_1: BSR	SCIC_4			; SEND PRINT ADJUST DATA
SCIP_2: MOV.B	@R4+,R1 		; GET PRINT ADJUST DATA
	BPL	SCIP_3			; BR IF PLUS VALUE
	BCLR.B	#QMSB,R1		;
	NEG.B	R1			;
SCIP_3: ADD.B	@R2+,R1 		; CORRECT VALUE
	BPL	SCIP_4			; BR IF PLUS VALUE
	NEG.B	R1			;
	BSET.B	#QMSB,R1		;
	CMP.B	#ZMSB,R1		;
	BNE	SCIP_4			; BR IF NOT MINUS ZERO
	CLR.B	R1			;
SCIP_4: SCB/F	R5,SCIP_1		;
	BRA	SCIC_3			;
	.PAGE
;
;	SEND LF SPEED TABLE DATA
;
;	IN	R0 : SLRE STATUS
;	     EP R4 : DATA POINTER
;		FP : BIT SEQUENCE REVERSE TABLE
;
;	OUT	NONE
;
SCILFT: MOV.B	#LFINLK,R2		; SEND LF MOTOR SPEED TABLE
	MOV.B	#ADTOPV-LFINLK,R5	; SET DATA SIZE
;	BRA	SCIDAT			;

;
;	SEND DATA TRANSFER COMMAND
;
;	IN	R0 : SLRE STATUS
;		R2 : DATA TRANSFER ADDRESS
;	     EP R4 : DATA POINTER
;		R5 : DATA BYTE SIZE
;		FP : BIT SEQUENCE REVERSE TABLE
;
;	OUT	NONE
;
SCIDAT: BSR	SCIDT2			; TRANSMIT CMDFMT, SLCOF, ADDRESS
	BRA	SCICMD			; SEND ADDRESS, DATA
	;
SCIDT2: MOV.W	#ZCDTB,R1		; SET DATA TRANSFER B COMMAND CODE
SCID_1: BSR	SCID_2			; TRANSMIT CMDFMT, SLCOF
	MOV.W	R2,R1			;
	BRA	SCIC_4			; TRANSMIT DATA TRANSFER ADDRESS
	;
SCID_2: BSR	SCIC_4			; TRANSMIT 2ND BYTE
	SWAP	R1			;
	BRA	SCIC_4			; TRANSMIT 1ST BYTE
	.PAGE
;
;	SEND COMMNAD
;
;	IN	R0 : SLRE STATUS
;	     EP R4 : DATA POINTER
;		R5 : DATA BYTE SIZE/PRINT BUFFER BUSY RESET FLAG
;		FP : BIT SEQUENCE REVERSE TABLE
;
;	OUT	NONE
;
SCIPRT: MOV.W	@(-2,R4),R2		; GET PRINT TIMER TABLE POINTER
	MOV.W	R2,@PRTTP:8		; SET PRINT TIMER TABLE POINTER
	MOV.B	R5,@PRBRF:8		; SET PRINT BUFFER BUSY RESET FLAG
	SWAP	R5			;
;	BRA	SCICMD			; SEND PRINT COMMAND

;
;	SEND COMMNAD
;
;	IN	R0 : SLRE STATUS
;	     EP R4 : DATA POINTER
;		R5 : DATA BYTE SIZE
;		FP : BIT SEQUENCE REVERSE TABLE
;
;	OUT	NONE
;
SCICMD: EXTU	R5			;
	ADD.W	#-2,R5			; ADJUST FOR LOOP
	BCC	SCIC_2			; BR IF DATA SIZE < 2
SCIC_1: MOV.B	@R4+,R1 		; GET SEND DATA
	BSR	SCIC_4			; TRANSMIT DATA
	SCB/F	R5,SCIC_1		;
SCIC_2: MOV.B	@R4+,R1 		; GET SEND DATA
SCIC_3: BSET.B	#QMBUSY,@EXPNDB 	; RESET MAIN CPU TRANSMIT BUSY
SCIC_4: MOV.B	R1,FP			; GET SEND DATA
	MOV.B	@FP,R1			; REVERSE BIT SEQUENCE
	MOV.B	R1,@TDR1		; OUTPUT TRNASMIT DATA
	BCLR.B	#QTDRE,@SSR1		; START TRANSMIT
	MOV.W	#ZNN,R3 		; SET SLRE TIME OUT COUNT
SCIC_5: MOV.B	@EXPNDA,R1		;
	XOR.B	R0,R1			;
	BTST.B	#QSLRE,R1		;
	BNE	SCIC_6			; BR IF RECEIVE READY
	BTST.B	#QDALM,@PSWDF:8 	;
	BNE	SCIC_6			; BR IF ALARM ERROR MODE
	SCB/F	R3,SCIC_5		; BR IF NOT TIME OUT
	MOV.W	R0,@-SP 		;
	MOV.W	#ZESL2,R0		;
	BSR	SETAL2			; SET SLAVE CPU ALARM ERROR
	MOV.W	@SP+,R0 		;
SCIC_6: BNOT.B	#QSLRE,R0		;
	RTS				;
	.PAGE
;
;	PANEL SW PROCESS DISABLE
;
;	IN	NONE
;
;	OUT	NONE
;
SWPDI:	CLR.W	@SWTP:8 		; DISABLE PANEL SW
	RTS				;

;
;	PANEL SW PROCESS ENABLE
;
;
;	IN	R2 : PANEL SW TABLE
;
;	OUT	NONE
;
SWPEN:	CMP.W	@SWTP:8,R2		; BR IF SAME SW TABLE
	BEQ	SWPE_2			;
	MOV.W	R2,@SWTP:8		; SET PANEL SW TABLE
SWPE_1: CLR.B	@SWRT:8 		; RESET REAPEAT SW MODE
SWPE_2: RTS				;

;
;	PANEL SW TABLE SELECT
;
;	IN	NONE
;
;	OUT	NONE
;
SWPT1S: BCLR.B	#QSWT2S,@PNLCF:8	; SELECT PANEL SW TABLE 1
	BNE	SWPE_1			; BR IF SW TABLE CHANGE
	RTS				;

SWPT2S: BSET.B	#QSWT2S,@PNLCF:8	; SELECT PANEL SW TABLE 2
	BEQ	SWPE_1			; BR IF SW TABLE CHANGE
	RTS				;
	.PAGE
	.SECTION	SYS2,CODE,ALIGN=16
;
;	CHECK RIBBON WIND MOTOR CHECK CIRCUIT
;
;	IN	NONE
;
;	OUT  R3-R4 : NOT CHANGE
;		FP : NOT CHNAGE
;		 Z : COMMAND CANCEL
;
CHKRBW: BTST.B	#QCCAND,@PRLFF:8	;
	BNE	CHKR_7			; BR IF COMMANDE CANCEL
	BTST.B	#QSLACT,@INTPRE 	;
	BEQ	CHKRBW			; BR IF NOT CR INITIALIZE START
	MOV.B	#ZCRB1,R0		; GET 1ST ERROR CHECK COUNT
	MOV.B	R0,@RBMEC:8		; RESET RIBBON MOTOR ERROR COUNTER
	MOV.W	#200/ZTI,R2		;
	WAITSK				; WAIT 200mS
	MOV.W	#ZCRDV1,R0		;
	BSR	UPCR_1			; UPDATE CR DUTY COUNTER
CHKR_1: MOV.W	#3-1,R5 		; SET CHECK COUNT
CHKR_2: MOV.W	#50/ZTI,R2		;
	WAITSK				; WAIT 50mS
	BTST.B	#QSLACT,@INTPRE 	;
	BNE	CHKR_3			; BR IF NOT CR INITIALIZE END
	BTST.B	#QCCAND,@PRLFF:8	;
	BNE	CHKR_7			; BR IF COMMANDE CANCEL
	SETALM	#ZERBW			; SET RIBBON WIND MOTOR ERROR
	BRA	CHKR_6			;
					;
CHKR_3: CMP.B	#ZARBM,@ADDRB		; CHECK RBMSNS
	BCC	CHKR_5			; BR IF CHECK CIRCIT OK
	BCLR.B	#QADF,@ADCSR		;
CHKR_4: BTST.B	#QADF,@ADCSR		;
	BEQ	CHKR_4			; BR IF NOT A/D CONVERSION FINISH
	CMP.B	#ZARBM,@ADDRB		; RE-READ RBMSNS
	BCS	CHKR_1			; BR IF CHECK CIRCIT ERROR
CHKR_5: SCB/F	R5,CHKR_2		; BR IF NOT CIRCIT CHECK END
CHKR_6: MOV.B	#0,R0			; RESET Z-FLAG FOR NOT CANCEL
CHKR_7: RTS				;
	.PAGE
;
;	UPDATE CR DUTY COUNTER
;
;	IN	R0 : CR CUTY COUNT
;
;	OUT  R1-FP : NOT CHANGE
;
UPCRDC: MOV.W	#ZCRDV2,R0		;
UPCR_1: BTST.B	#QCCANS,@PRLFF:8	;
	BNE	UPCR_3			; BR IF COMMAND CANCEL
	BCLR.B	#QOCIEA,@TCR2		; DISABLE INTPNL
	ADD.W	@CRDC:8,R0		; UPDATE CR DUTY COUNTER
	BVC	UPCR_2			; BR IF NOT OVER FLOW
	MOV.W	#ZNN-ZMSBW,R0		;
UPCR_2: MOV.W	R0,@CRDC:8		;
	BSET.B	#QOCIEA,@TCR2		; ENABLE INTPNL
UPCR_3: RTS				;
	.PAGE
;
;	UPDATE PRINT DOT COUNTER
;
;	IN	R0 : PRINT FIELD COUNT, SPEED
;		R1 : PRINT DOT DUTY COUNT
;		R2 : PRINT DOT COUNT
;		R4 : CR MOVE DISTANCE BEFORE PRINT
;
;	OUT  R5-FP : NOT CHNAGE
;
UPDOTC: CLR.W	R3			;
	CMP.W	#ZCRMV,R4		; CHECK CR PRE. MOVE DISTANCE
	BCS	UPDO_7			; BR IF ENOUGH CR PRE. MOVE
	MOV.W	#ZCRDV7,R3		; SET CR DUTY FOR PRE. MOVE
UPDO_7: MOV.W	#ZCRDV4-ZCRDV3,R4	;
	CMP.B	#H'20,R0                ;
	BCS	UPDO_1			; BR IF 1.0 PRINT
	MOV.W	#ZCRDV5-ZCRDV3,R4	;
	CMP.B	#H'40,R0                ;
	BCS	UPDO_1			; BR IF 1.5 PRINT
	MOV.W	#ZCRDV6-ZCRDV3,R4	;
	CMP.B	#H'80,R0                ;
	BCS	UPDO_1			; BR IF 2.0 PRINT
	MOV.W	#ZCRDV7-ZCRDV3,R4	;
UPDO_1: SWAP	R0			; GET NO. OF PRINT FIELD
	MULXU.B #ZCRDV3,R0		; CALCULATE CR DUTY FOR SKIP
	ADD.W	R3,R0			; ADD CR DUTY FOR CR PRE. MOVE
	ADD.W	R4,R0			; ADD CR DUTY FOR PRINT
	MOV.W	@DOTS,R4		; GET PREVIOUS PRINT DOT COUNT
	MOV.W	R2,@DOTS		; SET NEW PRINT DOT COUNT
	SUB.W	#ZDOTR,R2		;
	BCS	UPDO_2			; BR IF TOO SMALL DOT COUNT
	CMP.W	R2,R4			;
	BCS	UPDO_2			; BR IF (NEW DOT-MARGIN) > OLD DOT
	ADD.W	#ZDOTR*2,R2		;
	CMP.W	R2,R4			;
	BHI	UPDO_2			; BR IF (NEW DOT+MARGIN) < OLD DOT
	MOV.B	@PRDLC,R2		; GET PRINT LINE COUNT
	ADD.B	#1,R2			; UPDATE SAME PATTERN LINE COUNT
	BCS	UPDO_4			; BR IF OVERFLOW
	CMP.B	#ZXPRDC,R2		;
	BCS	UPDO_3			; BR IF NOT REACH LIMIT
	BSET.B	#QDOT4S,@IOSF:8 	; SET DOT TABLE 4 SELECT
	BRA	UPDO_3			;
					;
UPDO_2: BCLR.B	#QDOT4S,@IOSF:8 	; RESET DOT TABLE 4 SELECT
	MOV.B	#0,R2			; RESET SAME PATTERN LINE COUNT
UPDO_3: MOV.B	R2,@PRDLC		;
UPDO_4: BCLR.B	#QOCIEA,@TCR2		; DISABLE INTPNL
	ADD.W	@DOTC+1:8,R1		;
	MOV.W	R1,@DOTC+1:8		; UPADATE PRINT DOT COUNTER
	BCC	UPDO_5			;
	ADD.B	#1,@DOTC:8		;
	BVC	UPDO_5			; BR IF NOT OVERFLOW
	MOV.W	#ZNN,R1 		;
	ADD.B	#-1,@DOTC:8		;
UPDO_5: MOV.W	R1,@DOTC+1:8		;
	ADD.W	@CRDC:8,R0		; UPDATE CR DUTY COUNTER
	BVC	UPDO_6			; BR IF NOT OVER FLOW
	MOV.W	#ZNN-ZMSBW,R0		;
UPDO_6: MOV.W	R0,@CRDC:8		;
	BSET.B	#QOCIEA,@TCR2		; ENABLE INTPNL
	RTS				;

;
;	GET PRINT DELETE TABLE
;
;	IN	R0 : PRINT DPI NO. x 4
;		R1 : PRINT SPEED NO.
;
;	OUT	R0 : NOT CHNAGE
;		R1 : PRINT DELETE TABLE POINTER
;		R5 : DUTY LIMIT VALUE
;		FP : NOT CHNAGE
;
GETDEL: ADD.B	R0,R1			;
	MULXU.B #6,R1			; (SPEED x 6) + (DPI x 24)
	ADD.W	#PDELTB,R1		; GET DELETE TABLE POINTER
	MOV.W	@R1+,R5 		; GET NORMAL DUTY LIMIT
	CMP.B	#ZPRDC,@PRDLC		;
	BCS	GETD_1			; BR IF NOT SAME DUTY CONTINUE
	MOV.W	@R1,R5			; GET CONTINUEOUS DUTY LIMIT
GETD_1: ADD.W	#2,R1			; SET DELETE VALUE POINTER
	RTS				;
	.PAGE
;
;	READ HEAD TEMPERATURE CORRECTION VALUE FOR HEAD SHIFT
;
;	IN	NONE
;
;	OUT	R0 : HEAD SHIFT Nt
;	     R2-FP : NOT CHNAGE
;
RDHSNT: MOV.B	@ADDRA,R0		; READ HEAD TEMPERATURE
	BCLR.B	#QADF,@ADCSR		;
RDHS_1: BTST.B	#QADF,@ADCSR		;
	BEQ	RDHS_1			; BR IF NOT A/D CONVERSION FINISH
	ADD.B	@ADDRA,R0		; READ AGAIN
	ROTXR.B R0			; GET AVERAGE
	MOV.W	#HSNTTB-1,R1		; GET HEAD SHIFT Nt TABLE
RDHS_2: ADD.W	#1,R1			;
	CMP.B	@R1+,R0 		;
	BHI	RDHS_2			; BR IF NOT HIT
	MOV.B	@R1,R0			; GET HEAD SHIFT Nt
	RTS				;
	.END
